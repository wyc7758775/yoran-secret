<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Yoran Wu 的博客</title>
        <link>https://wyc7758775.github.io/yoran-secret/</link>
        <description>个人学习总结记录</description>
        <lastBuildDate>Mon, 25 Aug 2025 15:59:54 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>zh-CN</language>
        <image>
            <title>Yoran Wu 的博客</title>
            <url>https://wyc7758775.github.io/yoran-secret//favicon.ico</url>
            <link>https://wyc7758775.github.io/yoran-secret/</link>
        </image>
        <copyright>All rights reserved 2025, Yoran Wu</copyright>
        <item>
            <title><![CDATA[如何设计组件？]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/如何设计组件？</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/如何设计组件？</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[如何设计组件？ 要讨论标题这个问题，我们首先要了解这个问题包含哪一些内容。如下图： ![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753365280885-1b743f18-a034-4fd9-a599-5fe7e836a471.png) 图上面需要注意的是业务组件和基础组件的关系，它们虽然是并列的关系，但是大多数人都应该知道业务组件里面是由很多基础组件构成的。所以给它们都添加了一个备注，里面涉及两个概念：特性逻辑和共性逻辑。 顾名思义，共性逻辑或者交互代表的是多个业务组件，多个模块中一样的逻辑。而特性逻辑/交互是只存在在特定的组件当中，...]]></description>
            <content:encoded><![CDATA[# 如何设计组件？

要讨论标题这个问题，我们首先要了解这个问题包含哪一些内容。如下图：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753365280885-1b743f18-a034-4fd9-a599-5fe7e836a471.png)

图上面需要注意的是业务组件和基础组件的关系，它们虽然是并列的关系，但是大多数人都应该知道业务组件里面是由很多基础组件构成的。所以给它们都添加了一个备注，里面涉及两个概念：特性逻辑和共性逻辑。

顾名思义，共性逻辑或者交互代表的是多个业务组件，多个模块中一样的逻辑。而特性逻辑/交互是只存在在特定的组件当中，而这个组件又可能存在和其他组件一样的逻辑或交互，这样的组件就是业务组件。它是由特性+共性构成的。如下图：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753366125488-49aafebd-fb79-49ce-97e7-da096df056f6.png)

当然业务组件之间也是可以相互嵌套的，也就是说他们业务组件的层级越高，那么它的特性的越多，需要定制化的代码就越多，可以通过下马这张图表示：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753368101554-114464e8-d3d0-4eb1-ad6b-cc9ee0d40fbc.png)

这样说，可能有点抽象，举一个例子, 有如下两个组件写法：

```vue
<!-- 组件 1 -->
<y-input>
  <template #icon>
    <el-icon v-if="iconText === 'warn'" name='warn' />
    <el-icon v-else name='success' />
  </template>
</y-input>
```

```vue
<!-- 组件 2 -->
<c-input :iconText="warn">

<!-- c-input.vue -->
<template>
  <el-inpute />
  <el-icon v-if="iconText === 'warn'" name='warn' />
  <el-icon v-else name='success' />
</template>
```

可以预想到， 当我需要添加一个'danger'的图标的话，组件 1 只需要在父级组件添加对应的 if-else-if 就可以。但是组件 2 还需要在组件内的 Props 给 `iconText`多定义一个'danger'来进行判断。组件 1 的扩展性明显是更加的好的。

所以，我们应该如何更好的把组件给设计好呢？

# 确定需求

在软件开发中，编写业务代码通常会增加系统的复杂性（熵增）。但通过创建可复用、易维护且灵活的组件，可以减少这种复杂性。

所以为了进一步降低系统复杂度，**优化需求**至关重要。这需要开发者深入理解业务逻辑，并与产品经理紧密合作，确保需求既满足用户体验又遵循良好的编程规范。  
例如，当遇到一个新功能请求时，如果其界面设计仅在细节上略有不同，并且这些差异对用户体验或实际问题解决无明显帮助，技术人员应建议尽量利用现有组件来实现，避免不必要的代码增加。

有一句话说得好：“**<u>最好的代码是没有必要写的代码。</u>**”

这也解释了，为什么我们前端也需要关注需求的背后，有什么背景，是什么人提升的，是为了解决什么问题而存在的。不需要多么多大的理由，就是为了我写代码的时候能够更加方便，为了减少返工的可能性。

# 组件封装基本原则

封装以组件的道依旧是软件工程中对于可维护性代码的三条原则：

1. 单一职责
2. 高内聚低耦合
3. 开放封闭

我们平时使用的所有所谓的技巧都是围绕这三条原则展开的。

组件设计核心的问题是,**缺乏抽象能力。具体体现为下面这 4 点：**

1. **组件滥用与目录混乱**

初学者常把“组件化”理解为“UI 重复就抽组件”，导致组件数量爆炸、复用性差，维护困难。

2. **抽象失控，通用组件没人敢用**  
   为了复用而过度封装，结果组件变得复杂、难以定制，团队成员宁愿复制粘贴也不愿用“通用组件”。久而久之就变成了如下： - `TextInput.vue` - `IconTextInput.vue` - `ValidateableInput.vue` - `LoadingInput.vue` - `FormInput.vue`

一旦最初的 TextInput 的组件需要修改，你要做多少重复的工作，这个工期又如何评估呢？而且再有下 一个需求你又当如何？这么多相似的组件 ，每一个都可以凑合使用，每一个又无法共用。

3. **数据流混乱，props/emit 滥用**  
   数据和事件传递层级过深，props 传七层、事件回调嵌套，甚至用 inject/provide、eventBus 等方式“打通”，导致逻辑难以追踪和维护。
4. **技术债堆积，组件不敢删不敢动**  
   组件参数多、用途混乱，改动容易引发连锁反应，开发者只能不断复制新组件，留下大量“V2”后缀的冗余代码。

## 例子 1: 二次封装最佳实践

> 以下例子来自于【远方 OS】的 B 站/抖音账户, 这里不方便贴地址，自行搜索，偶然发现，说话声音平稳，内容总有一些小技巧感觉很有意思，故推荐。

封装一个 el-input 组件面对的三个问题：

### props.如何穿透过去

**方法一：**`**$attrs**`

```vue
<template>
  <div>el-input 二次封装</div>
  <el-input v-bind="$attrs"/>
</tempalte>
```

这样有如下问题：

1. ts 提示没有
2. 多于了很多不想要的参数

**方法二: props + Partial + InputProps**

```vue
<template>
  <el-input v-bind="{ ...$attrs, ...props }"></el-input>
</template>
<script lang="ts" setup>
import { type InputProps } from "element-plus";
const props = defineProps < Partial<InputProps>();
</script>
```

- Partial 为 TS 原生属性，用于将接口都改为非必填。
- `InputProps`为 element 默认导出的接口。
- `{ ...$attrs, ...props }`为了弥补 props 没有事件的问题。

### 插槽如何穿透过去

**方法一：循环 template + slot**

```vue
<template>
  <el-input v-bind="{ ...$attrs, ...props }">
    <template v-for="(_, slot) in $slots" #name="porps">
      <slot :name="slot" v-bind="props" />
    </template>
  </el-input>
</template>
```

这个是我不理解的，作者为了卖课非说麻烦，我不理解，这个哪里麻烦了？

**方法二：component**

```vue
<template>
  <component :is="h(ElInput, { ...$attrs, ...props }, $slots)" />
</template>
<script lang="ts" setup>
import { ElInput, type InputProps } from "element-plus";
import { h } from "vue";
const props = defineProps < Partial<InputProps>();
</script>
```

### 组件方法如何暴露出去

**方法一：传统方法 ref**

```vue
<template>
  <component
    :is="h(ElInput, { ...$attrs, ...props, ref: 'inputRef' }, $slots)"
  />
</template>
<script lang="ts" setup>
import { ElInput, type InputProps } from "element-plus";
import { h } from "vue";
const props = defineProps < Partial<InputProps>();
const inputRef = ref<InstanceType<typeof ElInput> | null>(null);

// 仅暴露必要方法，避免全量暴露
defineExpose({
  focus: () => inputRef.value?.focus(),
  select: () => inputRef.value?.select(),
});
</script>
```

这样写有一个问题，如果 component 有 v-if 属性的时候，且初始值为 false 的话，这个 InputRef 就拿不到了。

> 拿不到就拿不到，本来就不应该能用。这个有什么关系呢？

**方法二：ref 使用函数返回**

```vue
<template>
  <component
    :is="h(ElInput, { ...$attrs, ...props, ref: getInputRef }, $slots)"
  />
</template>
<script lang="ts" setup>
import { ElInput, type InputProps } from "element-plus";
import { h } from "vue";
const props = defineProps < Partial<InputProps>();

const vm = getCurrentInstance();
const getInputRef = (inputInstance) => {
  vm.exposed = inputInstance || {}; // 如果组件没有渲染处理,inputInstance 为 Null
  vm.exposeProxy = inputInstance || {};
};
</script>
```

`vm.exposeProxy = inputInstance || {}`我们在外面直接使用其实是 exposeProxy，也就是 exposed 的这个代理。

## 例子 2：封装一个弹窗

> 以下例子来源 gas-design, 模仿 element-plus 中 el-dialog 的写法

1. 如何全局注册一个弹窗的组件
2. 如何让全局样式来影响的组件的内部样式
3. 插槽的基本设计

原型如下：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753373527222-87cc7621-de59-4c82-917f-e9b69b9c85fd.png)

交互如下：

1. 点击标题可以拖拽整个 弹窗
2. content 部分可以放入任何内容
3. footer 部分有取消和确定两个按钮

```vue
<template>
  <Teleport to="body">
    <Transition name="modal-fade">
      <div v-if="modelValue" @click="handleOverlayClick">
        <modal-trap :draggable="draggable">
          <div :style="modalStyle">
            <modal-content :content="content">
              <template #header>
                <slot v-if="!$slots.title" name="header" :close="handleClose" />
                <slot v-else name="title" />
              </template>
              <template v-if="$slots.default" #default>
                <slot />
              </template>
              <template #footer>
                <div class="flex justify-end">
                  <button v-if="showCancel" @click="cancel">取消</button>
                  <button @click="confirm">确定</button>
                </div>
              </template>
            </modal-content>
          </div>
        </modal-trap>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, provide } from "vue";
import ModalContent from "./ModalContent.vue";
import ModalTrap from "./ModalTrap.vue";
import { modalInjectionKey } from "./constants";

const props = defineProps({
  modelValue: Boolean, // v-model绑定值
  title: {
    type: String,
    default: "提示",
  },
  content: String,
  width: {
    type: [String, Number],
    default: "500px",
  },
  height: {
    type: [String, Number],
    default: "auto",
  },
  showCancel: {
    type: Boolean,
    default: true,
  },
  closeOnClickOverlay: {
    type: Boolean,
    default: true,
  },
  draggable: {
    type: Boolean,
    default: true,
  },
});

const headerRefs = ref(null);
provide(modalInjectionKey, {
  headerRefs,
});

const emit = defineEmits(["update:modelValue", "confirm", "cancel"]);

const modalStyle = computed(() => {
  return {
    width: typeof props.width === "number" ? `${props.width}px` : props.width,
    height:
      typeof props.height === "number" ? `${props.height}px` : props.height,
  };
});

function handleClose() {
  emit("update:modelValue", false);
}

function confirm() {
  emit("confirm");
  handleClose();
}

function cancel() {
  emit("cancel");
  handleClose();
}

function handleOverlayClick(event) {
  // 只有点击遮罩层而不是弹窗本身才关闭
  if (props.closeOnClickOverlay && event.target.classList.contains("fixed")) {
    handleClose();
  }
}

// 按ESC键关闭弹窗
function handleKeyDown(event) {
  if (event.key === "Escape" && props.modelValue) {
    handleClose();
  }
}

onMounted(() => {
  window.addEventListener("keydown", handleKeyDown);
});

onUnmounted(() => {
  window.removeEventListener("keydown", handleKeyDown);
});
</script>
```

`modal-content`的相关逻辑

```vue
<template>
  <div class="p-4 overflow-auto flex-1">
    <!-- 标题栏 -->
    <div
      ref="headerRefs"
      class="modal-header flex justify-between items-center cursor-move"
    >
      <slot name="header">
        <h3>{{ title }}</h3>
      </slot>
      <button class="cursor-pointer" @click="close">X</button>
    </div>

    <!-- 内容区 -->
    <slot name="default" v-if="hasDefaultSlot"></slot>
    <h3 v-else>{{ content }}</h3>

    <!-- 按钮区 -->
    <div class="text-left">
      <slot name="footer" />
    </div>
  </div>
</template>
<script setup lang="ts">
import { defineProps, useSlots, inject } from "vue";
import { modalInjectionKey } from "./constants";

defineProps({
  title: {
    type: String,
    default: "提示",
  },
  content: String,
});

const emit = defineEmits(["close"]);
const { headerRefs } = inject(modalInjectionKey)!;

const slots = useSlots();
const hasDefaultSlot = !!slots.default;

const close = () => {
  emit("close");
};
</script>
```

`modal-trap`的相关逻辑：

```vue
<template>
  <div
    :style="modalStyle"
    v-bind="$attrs"
    @mousedown="startDrag"
    @mousemove="onDrag"
    @mouseup="stopDrag"
    @mouseleave="stopDrag"
  >
    <slot />
  </div>
</template>
<script setup lang="jsx">
import { ref, defineProps, computed, inject } from "vue";
import { modalInjectionKey } from "./constants";

const props = defineProps({
  draggable: {
    type: Boolean,
    default: true,
  },
});

const { headerRefs } = inject(modalInjectionKey);

const isDragging = ref(false);
const dragOffset = ref({ x: 0, y: 0 });
const position = ref({ x: 0, y: 0 });

const modalStyle = computed(() => {
  return {
    transform: `translate(${position.value.x}px, ${position.value.y}px)`,
  };
});

function startDrag(event) {
  if (!props.draggable) return;

  if (!headerRefs.value) return;

  // 点击的是 headerRef 时才能拖动
  if (event.target === headerRefs.value) {
    isDragging.value = true;
    dragOffset.value = {
      x: event.clientX - position.value.x,
      y: event.clientY - position.value.y,
    };
  }
}

function onDrag(event) {
  if (isDragging.value) {
    position.value = {
      x: event.clientX - dragOffset.value.x,
      y: event.clientY - dragOffset.value.y,
    };
  }
}

function stopDrag() {
  isDragging.value = false;
}
</script>
```

在业务组件中使用如下：

```vue
<Modal v-model="{isModalVisible.value}" title="测试通知2">
  <p>slot: 这是一条测试通知2</p>
</Modal>
```

## 总结其他封装组件小技巧

1. 良好的注释有锦上添花的效果
2. 业务组件应该提供最小变量原则，开发者只需要几个参数就可以实现效果。
3. 对于业务组件的 props 不应该超过 3 个，UI 组件的 props 多是因为它们面对的项目数不胜数。如果业务组件真的需要这么的 props 的话，那么可以考虑使用插槽来实现。
4. state 状态应该尽量的简洁而全面，已经有一个 state 是数组的了，那么你当前你需要他的长度的时候，就不需要再定义一个 state 来存储它的长度了，直接 state.length 就可以了。《重构》这本书中亦有提到。
5. 封装组件封装到什么程度？
   1. 以业务为主，如果没有其他业务需要，那么对于一个复杂组件而言直接抛出组件都没有任务问题。
   2. **<u>业务层面的组件和代码层面的组件是两个概念</u>**
      1. 代码层面的组件还是要根据受控组件和非受控组件来进行切割，高内聚低耦合
6. 不要通过 props 参数来座位控制组件的显示隐藏。把显示隐藏的变量放到里面，然后 defineExpord（open()和 close()）这两个方法除了可能更加的合适，符合单一指责原则。或者干脆不要这个参数，直接在父组件对这个进行控制。
7. **组件设计建议**
   - 明确组件职责（UI、交互、逻辑分离）
   - 精简 props 和事件，只暴露必要接口
   - <u>用 slots 替代高度定制的 props</u>
     - 当 props 过多的时候就可以考虑是否改为使用 slot 了？但是这里有一个问题了，时间从哪里来呢？

# 开发中面临其他困境

## 不是我的组件抽象能力不行，实在是产品太奇葩，公司不给时间

这句话其实是在说：

1. **需求未冻结，技术可行性评审流于形式；**
2. **工期赶，人力资源分配不合理。**
3. **我有一颗想要把组件设计好的心也迫于这些原因而做不到，非战之罪！**

是的，这些问题完全能够理解，一个经验老道的开发或许可以在赶工和代码质量之间做到很好的权衡，但是大多数人不是这样的，包括我，一直在路上。整个氛围都紧张的情况下，每当坐上工位都感觉工位有脏东西，会附身的，让你忍不住骂娘。

所以这样的情况确实是客观存在的，我们能做什么？有的，集美集帅们。我们来上班不是为了长结节的，如果现状无法改变的话，我们还可以调整自己的心态，一般来说，我们可有两种心态：

1. 在工位生闷气，然后回家焦虑，骂天骂地，骂 TM 的。
2. 如果我可以在短时间内很好的完成任务，这会成为我将来跳槽的基石。

**<u>核心逻辑</u>**：当我们面对无法改变的客观事实的时候，将自我的成长和要面对的显示绑定。事情是要做的，但是我将被动接受负面情绪转换为自己主动去控制。这个在行为心理学当中，是将我们做事情的动力转化为**<u>对理想状态的向往。</u>**

那么我们如何能够很好的完成任务呢？**<u>把代码写清楚。</u>**

我们先来看下面这张图，复用机会和功能数，以及颗粒度的关系，总结来说颗粒度越高复用机会越低，功能数越高复用机会越高，所以如何平衡功能数和颗粒度就成了我们做好这件事情的关键。

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753358582392-cb017ecb-2014-445b-a5e4-a7683ab12dc5.png)

现实很理想，ui 突发奇想，产品突发奇想，领导突发奇想，客户突发奇想... 所谓的“通用组件”像... 好多 ui 和产品水得没边，做个草图/设计图就是硬生生一版，然后实际开发可能还没他们改动得快理想很丰满，现实有点难蚌。

上图的功能数和颗粒度似乎有一个交叉点，但是这个点没有一个明确的标准的，意味着它的标准可以很灵活。

所以我在开发一个组件的时候，有一条底线，那就是**而是如何把代码给写清楚，让其他人一开就懂**。这个是我们在团队协作中应该有的态度。

## 什么时候需要对组件进行封装

有这么一种说法相同的代码代码大于 2 次考虑封装，大于 3 次就必须封装？

我不同意这样的观点，组件的封装是一个设计思维而不是一个补救措施。前期一个良好的组件封装随着经验的提升，是不会占据更多的时间的。

在软件开发中，理想的实现路径应该是：

**设计时遵守三大原则 -> 开发时模块化 -> 重复的时候快速抽离适配**

实在无法办到的时候，在遇到重复的代码的时候，最好的办法一定是先复制粘贴原本的代码，然后按照设计三大原则以及模块化来重新写的，等到下一次有需求涉及到这部分的时候，才进行组件的替换。这样做的好处有哪一些呢？

1. 降低风险，不管你重写了和非本次需求的任何代码，对于开发都会导致自己的任务时长超出预期，对于测试也是会增加新的工作量。
2. 合理人人力资源的使用。
3. 在之后遇到这个模块的时候再进行适配，也更加的好统计工时。

> 这里有一个小技巧，为了之后不被忘记，在需要替换的组件部分添加一个 TODO，或者使用文档来作为一个技术债。

在我们业务开发当中，写代码在我们工作的占比不是百分之百，它很重要，但是更重要的是团队的协作，更重要的是业务价值。

最后，_**<u>缺少一个统筹全局，将不同声音统一成一个声音的人</u>**_。开发缺少时间，要形成可复用的公共组件，不是说普通的业务开发顺手写一下就好了，公共组件是需要设计，需要重构，需要精炼的。是需要专人长期的不间断的投入时间和精力的。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[如何阅读源码]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/如何阅读源码</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/如何阅读源码</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[如何阅读源码？  一、为什么有这一篇阅读源码的文章？ 想要提升自己的编码水平，阅读优秀的开源项目是一个重要的手段。掘金网站上面有很多解析各种框架源码的文章，还有更多教你如何组织好代码的文章。 比如说，红皮书、绿皮书、黄皮书告诉了我们 JS 是什么？而《重构》、《代码整洁之道》告诉了我们如何组织好 JS。 唯独阅读源码的文章却很少。这就让我在一开始阅读源码的时候无所适从。打开 github，搜索 vue3 的源码，看到如下的界面： !image.png !image.png 和我们平时做的业务项目结构基本不对应。不知道从哪里看起，应该看什么？想来是一些技巧和方法是我没有掌握的。 所以我开始认为，...]]></description>
            <content:encoded><![CDATA[# 如何阅读源码？

## 一、为什么有这一篇阅读源码的文章？

想要提升自己的编码水平，阅读优秀的开源项目是一个重要的手段。掘金网站上面有很多解析各种框架源码的文章，还有更多教你如何组织好代码的文章。

比如说，红皮书、绿皮书、黄皮书告诉了我们 JS 是什么？而《重构》、《代码整洁之道》告诉了我们如何组织好 JS。

唯独阅读源码的文章却很少。这就让我在一开始阅读源码的时候无所适从。打开 github，搜索 vue3 的源码，看到如下的界面：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85d4ac6842324ee3ac358845a2375655~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec68fb0515c04dc784e13507df67167c~tplv-k3u1fbpfcp-watermark.image?)

和我们平时做的业务项目结构基本不对应。不知道从哪里看起，应该看什么？想来是一些技巧和方法是我没有掌握的。

所以我开始认为，**阅读源码也是一种技能。**

这是一项重要技能，决定你是否从初中级程序员步向高级程序员，甚至可能是最重要的。

## 二、为什么需要阅读源码？

1. 扩充知识面,提升编程能力
2. 面试会考
   - 源码不是教程，它背后没有习题，你无法保证你看完之后就真的会了。
   - 所以最直接的就是面向面试学习，了解 Vue 与 Node.js 的面试考点，针对面经中提到的问题去看源码。也是为了更好的树立一个目标去阅读源码，可以直观的验证自己所学的是否到位。这样做除了可以带来更直观的反馈之外，也能够更好的应对面试。
3. 提升设计思维和架构能力
   - “前端娱乐圈”这句戏言不是一句戏言。
   - 框架是一直在变，一直都在更新的，然而 JavaScript 基础是永恒不变的，无论是学习 Vue 源码还是 Nodejs 再或者是学习 React ，都是提升自己使用 JS 这门语言组织能力。这个组织能力就是设计思维和架构能力
4. 提升代码审美能力
   - 要写一手优雅的代码，首先分清楚什么是好的代码，什么坏的代码。而这个审美能力，除了需要大量的实践，还需要阅读很多优秀的代码才能够提高。

## 三、我是如何去阅读源码的？

### 3.1 一定的基础知识

- 看 Vue3 之前，如果你对于` proxy` 和` reflect` ，你是看不懂它响应式是如何实现的

- 在看 Npm 源码之前，如果不会` commonJs` 模块化，` fs` 、` process` 这些基本 API，你从一行代码就会满头雾水

- 想要学习` diff` 算法，不管是 Vue 还是 react 的，如果没有一定的数据结构和算法的基础，更是寸步难行。

- 所以在自己的基础还不够之前，就直接去阅读这些框架源码，收益比太低，还不如多切几张图，而且看不明白，耽误时间之外，还会让自己变得焦虑。

### 3.2 正确的心态

1. **要有信心：** 这些优秀的开源框架本身还是使用 JS 或者 TS 写的，我们没有工作都在使用的东西，他们或许写得很精妙，封装得很高级。既然是开源的，就是要有多人协作。所以，当我们将它们拆成一下块一小块，总是会转化成为我们能够理解的东西。看不懂，也只是因为我们对于框架的整体结构的不了解。
2. **敢于质疑：** 既然是人写的，就可能会出错，所以我们要敢于质疑
3. **拉长反馈周期：** 在阅读这些框架源码的时候，不能着急，贡献者编程能力在那摆着呢，更不用说都是一个团队经过长时间的维护。所以，不要想着一上来就能够看懂别人写的是什么，这样子也太看不起人家了。我们阅读源码的过程要降低预期，拉长反馈的周期。

## 四、阅读源码的流程

### 4.1 全盘了解

- 这个框架是为了解决什么问题诞生，或者说产生的背景是什么？
- 有什么功能
- 有什么 API

### 4.2 列出疑问清单

- 和我们当年 在学习语文课的时候一样，语文老师都要求我们在预习中带着疑问

### 4.3 理清项目结构

- 找到入口文件
- 通过项目根目录的文档，或者百度谷歌都可以

### 4.4 阅读的策略

- **为什么：**
  - 很多框架的源码行数非常的多，宛如枝繁叶茂的树，我们要做的就是从根部开始往上爬，可是时间又是有限的，所以 有一个好的阅读策略是很有必要的。
- **把项目跑起来：**

  - 毕竟不是真正在阅读文章，我们是应用学科，是一定要上手边调试边阅读才能够搞清楚的，所以我们的标题更加贴切的叫法应该叫做“如何调试源码”

- **聚集问题：**
  - 我们一般来说是不需要参与开发的，所以不要求一次性就把源码如何实现都弄明白。这就是需要第二点的原因，带着我们的疑问去看代码，在理清主干流程之后，再来针对性的弄明白细节是如何实现的。
  - 这就是要求我们确定**_阅读路径_** , 比如在我们熟悉的 Vue 的源码当中，有一个目录是解析模板的主逻辑，将虚拟 DOM 转化生成语法树 AST，最后生成" Render Function" , 这个目录关键的流程是在 "Render Function" ，至于如何解析模板，如何生成语法树，可以先放一放，这一块阅读起来还是很有难度的，陷进去的话，很容易卡死出不来，进而导致阅读源码的正反馈少，距离放弃阅读也就不远了。
  - 记得阅读英语文章的时候，老师说过，不要看到不认识的单词就慌，我们可以继续往下读，通过上下文，自然能够猜测到那个单词是什么意思。
    - 有人问，如果这一串上下文你大部分单词都不认识的话，怎么结合上下文。这个时候那肯定是要先去背背单词吧。
    - 所以说，在阅读源码之前是要有一定的基础的。
- **不要对自己太狠了：**
  - 和上一点相似，不要对自己太狠了，非要一下子弄懂源码每一个细节。
  - 别人都更新迭代多少代了，网上才有一种阅读策略是从他们的第一个版本开始看起，但是这种策略实在是太费时间了。当然每一个细节都搞懂的话当然是最好的，转眼就会忘记了，收益比很低。毕竟自己写的代码，两个月后再来看，你自己都搞不明白是啥意思。

### 4.5 其他关注点

- 争取成为这个项目的" contributors"
- 有一种说法是，当你看不懂某个模块是做什么的时候，可以通过**测试用例**来看，它直白的入参出参就能够很直白的表述这个模块的作用。
  - 个人玩不了这种策略，前端的测试用例实在是太乱太杂了，还涉及到了界面的渲染的测试，看得时候效率比直接看源代码更低。

## 五、辅助手段

### 5.1 直接 github 上面进行调试

1. 将` .com` 改为` .dev` , 比如[github.com/npm/cli](https://github.com/npm/cli) ⇒ [github.dev/npm/cli](https://github.dev/npm/cli)
2. 点击` .` 和第一点同样的效果
3. 如果不想调试，可以将` github` ⇒ ` github1s` , 进入编辑器只读模式
   ![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b170b96420a42109ef7f6886edd842f~tplv-k3u1fbpfcp-watermark.image?)
   _ 登录自己的 VSCode 账号，这样它就会自动把我们本地 VSCode 的配置、主题、快捷键、插件等统统同步过来. 还会保存我们最后一次操作的快照.
   _ 我本身是一个 idea 党派,但是也因为这个方便的功能,配置上了 VsCode

### 5.2 插件

- ` Code translate` 哪里不会点哪里，在线翻译英语单词
- ` Bookmarks` 书签，可以给当前行做一个标记，方便下一次直接进来

### 5.3 画图工具

- [Excalidraw | Hand-drawn look & feel • Collaborative • Secure](https://excalidraw.com/) 手绘风格的画图工具,操作简单,风格富有灵性,个人最喜欢的画图工具.

### 5.4 笔记软件

- 框架源码的量是很多的,不是一天两天就能够看完的. 所以为了每次阅读代码之前,能够快速回顾,进入状态.我们需要把重点的记录道笔记当中. 画图工具中画的流程图也是同样的道理.

- 而如果是想要使用笔记来记录的话,我这里推荐` logseq` 这款免费的大纲笔记软件, 操作简单,可以放入代码块,通过插件还能够一键生成思维导图.

- 如果条件允许的,我也很推荐我正在使用的`remNote`

推荐的这两款都是大纲类型笔记, 大纲类型笔记作为自己的笔记的时候会很舒服.但是要迁移的时候就很麻烦. 比如说迁移到绝金上面发布,格式基本不可用.

## 六、npm 的源码试试水

### 6.1 背景

解决的问题:
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/509af396dd0c4f2088b3ae273dd26a72~tplv-k3u1fbpfcp-watermark.image?)

- npm 的出现弥补了 node 没有包管理工具的缺陷,早就是 node 内置工具了
- 运行的环境:
- NODE. 相比浏览器,多处来下载、删除、读写本地文件的功能

### 6.2 有什么功能?

- `npm init`
- `npm install`
- `npm run`

### 6.3 其他的 API

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e010962639b44eb1b39eb4aee2b0c4b9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="70%" />
    
### 6.4 疑问清单
- `npm run` 如何跑的
- 为什么它安装的依赖版本和我们`package.jons` 不一样
- 为什么执行了npm install 但是安装的包版本和我package.json不一样呢?
- npm install安装到一半卡住? 
- `npm`是如何对第三方包进行安装的 ? 又是如何对这些包的依赖关系进行处理的?
- `npm install <foo>`的运行机制
- ...
### 6.5 找到入口文件
- **操作环境:** Mac
    - Window的用户可以研究一下` wsl2`,就现阶段的` wsl2`而言,你的下一台电脑何必是Mac.
- **终端:** Warp
- **操作步骤:**

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42e4fb491c8e4e2a92b6e76ba57752ec~tplv-k3u1fbpfcp-watermark.image?)

- ` which npm` : 查找软连接路径
- ` ll <path>` : 查看软链接实际执行运行源码
  - 此时我们键入` node /opt/homebrew/lib/node_modules/npm/bin/npm-cli.js` 就等于直接在 command 中输入` npm` . 这就是我们要找的入口文件.
  - 当然找到了入口文件,我们可以直接在 github 上面到 npm/cli 仓库进行 dev. 或者直接把源码拷贝到本地

### 6.6 配置断点

配置 launch.json

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "npm run dev",
      "skipFiles": ["/**"],
      "program": "${workspaceFolder}/index.js",
      "args": ["run", "dev"],
      "stopOnEntry": true
    },
    {
      "type": "node",
      "request": "launch",
      "name": "npm install lodash",
      "skipFiles": ["/**"],
      "program": "${workspaceFolder}/index.js",
      "args": ["i", "lodash", "--no-package-lock"],
      "stopOnEntry": true
    }
  ]
}
```

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bef5f57adac4059b04465d478d093e5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="50%" />

### 6.7 进入主干流程源码

#### 6.71 cli.js

- 进入" cli.js" 文件,可以看到分为两部分,一部分是在验证版本信息,以及监听异常. 另外一部分就是该文件的主函数来.

```js
// 1. 校验版本信息, 监听异常
const createEnginesValidation = () => { ... }
// ...
// ...
let cmd;
// 2. 初始化npm信息
await npm.load();

cmd = npm.argv.shift();

// !executive 执行 , 核心程序
await npm.exec(cmd, npm.argv);
return exitHandler();
```

- 直接从" exec" 的命名就可以知道,当我拿到 command 输入的命令和参数之后,初始化 npm 的数据之后, 就调用" npm.exec" 来执行对应的逻辑.

- 接下来可以进行查看" npm.exec" 中的逻辑

#### 6.72 npm.js

**阅读指导:**

- 当我们进入到这个文件的时候,就会发现里面有很多很多的文件.这个时候我们一定要谨记之前说的阅读策略.

  - 确定我们的**阅读路径:** 我们这次的目标是为了搞懂 npm 运行的主流程是什么
  - 不需要搞懂每一个细节的实现是什么, 每一个参数什么.

- 基于阅读策略指导,我们不需要把这个文件从头看到尾. 跟着上一个文件" npm.exec" 走到这个文件暴露出去的" exec" 函数.

`exec:void`:

```js
// 1. 拿到对应分支程序返回的实例
const command = await this.cmd(cmd);
const timeEnd = this.time(`command:${cmd}`); // 用于超时判断

execPromise = command.exec(args); // 返回的执行实例

return execPromise.finally(timeEnd); // 返回执行实例的promise
```

- 排除掉" timeEnd" ,这个函数做的事情,就是拿到" this.cmd" 返回的什么东西,然后 return 它的 promise 出去.
- 此时我们的目标就到了" this.cmd" 上.

`cmd: void`:

```js
await this.load();
const command = this.deref(cmd); // 对当前命名进行校验
const Impl = require(`./commands/${command}.js`);
const impl = new Impl(this);
return impl;
```

- "this.load()" 一时间看不懂不要紧,直接跳过去. 直接去看第二个用的函数" this.deref()" , 它就很简单,是对于传入的" cmd" 进行校验.我们通过打断点可以知道, "command" 是我们配置运行时候的参数,比如 install、run、init....
- 所以我们是拿到目录" ./commands/xxx.js" 中返回的类, 然后将当前环境的" this" 传入中,最后直接返回对应文件的实例.

#### 6.73 总结一下

上面就是 NPM 源代码的主流程

- 文件跨越: "cli.js" ⇒ "npm.js"

- 函数调用栈: "npm.load()" ⇒ "cmd()" ⇒ "exec()" ⇒ "npm.exec()"

- 想不如写,写不如画

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1979e21b825141f8b03738e89f71bd2e~tplv-k3u1fbpfcp-watermark.image?)

#### 6.73 小技巧提示

- 声明部分不用看
- 借助单步调试
- if 直接“删除”,不用看
- if/else 二选一 需要看

### 6.8 ` npm install` 运行机制

#### 6.81 前置操作

分析来主流程, 我们就可以直接指定到" commands" 目录下面找到对应的" install.js"

即便是没有都在使用 install 的命令,但是不见得能够了解它的所有功能, 所以建议先阅读官方文档来了解一下
[npm-install | npm Docs](https://docs.npmjs.com/cli/v8/commands/npm-install)

#### 6.82 断点配置

```javascript
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "runtimeExecutable": "/usr/local/bin/node",
      "request": "launch",
      "name": "Launch Program",
      "skipFiles": [
        "<node_internals>/**"
      ],
      "program": "index.js",
      "args": ["i", "lodash", "--no-package-lock"]
    }
  ]
}
```

#### 6.83 执行过程

##### ` exec()`=>

把` if` 都删除掉之后就不剩下什么了

```javascript
const install = async (args) => {
  const opts = {
    ...this.npm.flatOptions,
    auditLevel: null,
    path: where,
    add: args,
    workspaces: this.workspaceNames,
  };
  const arb = new Arborist(opts);
  await arb.reify(opts);
};
```

- 其中` args` 打印一下就可以知道,这个是我们要安装的所有包名的列表, 这里就是` ['lodash']`
- 其他参数很容易可以通过命名来知道它大概的意思.
  - ` where` 当前运行 install 命名的目录
  - ` this.workspaceNames` 工作空间的相关信息
  - ` this.npm.flatOptions` 一个对象,放了一些初始化的配置
- 所以我们主要研究对象就变成了` Arborist` 实例.

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f38c8b367ccb490683be8fcceaa2a2e5~tplv-k3u1fbpfcp-watermark.image?)

很有意思的一个命名,就很贴切.我们在把文件从远程下载到本地之一,还需要处理如何构建` node_modules` 这个依赖文件树

##### ` Arborist` =>

- 路径: ` '/nodel_module/arborist/index.js'`
- 主代码:

```js
const mixins = [
  require("../tracker.js"), // 追踪? 或许是日志
  require("./pruner.js"), // 修建?优化
  require("./deduper.js"), // 去重
  require("./audit.js"), // 审核?校验?
  require("./build-ideal-tree.js"), // 构建文件目录树
  require("./load-workspaces.js"), // 加载工作区
  require("./load-actual.js"), // 加载真实节点树
  require("./load-virtual.js"), // 加载虚拟节点树
  require("./rebuild.js"), // 重构
  require("./reify.js"), // 整理包
];
const Base = mixins.reduce((a, b) => b(a), require("events"));

class Arborist extends Base {
  // ...
}
```

- 不用挨个点进去就知道各个模块大概是什么作用的. 注释已经标出.

- 可以大胆猜测一下它的执行顺序:

  - "reify" ⇒ "loadVirual" ⇒ "loadActual" ⇒ "loadWorkspaces" ⇒ "builddealTree" ⇒ "audit" ⇒ "deduper" ⇒ "pruner" ⇒ "rebuild"

- 通过断点调试, 观察调用栈可知, "reify" 这是我们想象的执行入口.当然直接看官方文档,上面啥都有.

##### ` reify()` =>

- 路径: `'/nodel_module/arborist/reify.js'`
- 主代码:

```javascript
async reify (options = {}) {
    // ...
	await this[_validatePath]()
	await this[_loadTrees](options)
	await this[_diffTrees]()
	await this[_reifyPackages]()
	await this[_saveIdealTree](options)
	await this[_copyIdealToActual]()
	// ...
}
```

- 代码的执行顺序很明了, 函数名也很直白的表达出了它要做的事情. 剩下的就是我们一个一个点下去看每一个环境是怎么执行.
- 校验路径: ` this[_validatePath]()`
- [validatePath] ⇒ mkdirp ⇒ mkdirpNative ⇒ findNode
- 校验当前路径是否有效 ⇒ 判断当前目录路径是否已经创建, 如果没有就创建
- 加载依赖树: ` this[_lodaTrees]()`
- 简介:
  - 这部分就会涉及到我们平时经常遇到的问题, 它是如何根据` package.json` 来生成依赖关系的, 如果多个包都有一样的依赖如何出来, 如果这些依赖版本不一样,但是包名一样又是如何处理的? 是整个**依赖整理的核心**
- 核心代码:

```javascript
if (!this[_global]) {
  return Promise.all([
    this.loadActual(actualOpt),
    this.buildIdealTree(bitOpt),
  ]).then(() => process.emit("timeEnd", "reify:loadTrees"));
}
return this.buildIdealTree(bitOpt)
  .then(() => this.loadActual(actualOpt))
  .then(() => process.emit("timeEnd", "reify:loadTrees"));
```

- 解析:
  - 就是一个 if else, 这里使用了**卫语句** . 不是安装到全局的话,就同时运行` this.loadActual` 和` this.buildIdealTree` 这两个方法. 而非全局的话,就有执行的顺序.
  - 我们这次的目的是为了搞懂 install 的运行机制, 所以碰到这种分岔路,我们只要选择其一就可以了.这就是之前为什么说 if 可以不用看, if/else 需要看的

## 七、总结

- 我们在阅读源码中做一个一切准备都只是尽量的拉平你和项目作者之间的信息差.
- NPM 的源码内容很多,没有办法通过一篇文件就解析完全, 这里只是作为一个引子. 希望大家都能够早日进入源码的源码当中.
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[富文本无法渲染多个空格]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/富文本无法渲染多个空格</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/富文本无法渲染多个空格</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[富文本无法渲染多个空格  事情的起因 添加空格之后，上传给后台之后，回显的时候，没有正确的处理空格，不管多少个空格都只显示一个空格。 输入空格之前： ![](https://cdn.nlark.com/yuque/0/2023/png/654315/1688789869845-b90b3a51-ce8b-457e-b3fc-8008b433e33f.png) 输入之后： ![](https://cdn.nlark.com/yuque/0/2023/png/654315/1688789944441-cb02c067-63eb-49da-bf5f-89769486ab16.png)  问题盘查 将...]]></description>
            <content:encoded><![CDATA[# 富文本无法渲染多个空格

## 事情的起因

添加空格之后，上传给后台之后，回显的时候，没有正确的处理空格，不管多少个空格都只显示一个空格。

输入空格之前：

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1688789869845-b90b3a51-ce8b-457e-b3fc-8008b433e33f.png)

输入之后：

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1688789944441-cb02c067-63eb-49da-bf5f-89769486ab16.png)

## 问题盘查

将显现和问题输入 chatGPT，它给了答案。辅以谷歌百度。得到下面的解释：

<font style="color:rgb(42, 49, 53);">浏览器会识别标签之间的空格，但会将连续的空格合并为一个空格。</font>**<font style="color:rgb(42, 49, 53);">这是因为 HTML 规范规定</font>**<font style="color:rgb(42, 49, 53);">，连续的空白字符（包括空格、制表符和换行符）在渲染时会被合并为一个空格，这样可以保证页面的呈现一致性。所以在 HTML 标签内部的连续空格会被视为一个空格，而不会影响页面的布局。但需要注意的是，标签开始和结束之间的空格不会被合并，它们会被保留。</font>

<font style="color:rgb(42, 49, 53);">也就是说，当我们在 html 中输入下面的代码：</font>

```html
<p>This is a paragraph with multiple lines of text.</p>
```

它在页面上面最终渲染的还是一行。只是在 with 和 multiple 之间有一个空格。

## 解决过程

<font style="color:rgb(42, 49, 53);">让浏览器能够识别出空格就好了。所以浏览器识别什么空格呢？实体'&nbsp;'。所以说只要将空格都替换成实体的'&nbsp;'就可以让浏览器正确的渲染。</font>

<font style="color:rgb(42, 49, 53);">代码实现：</font>

```javascript
const saveEditorValue = () => {
  const value = editorValue?.replace(/\s\s/g, " &nbsp;") || "";
  localStorage.setItem("gasEditorValue", value);
  console.log("The data storage server succeeds. Procedure");
};
```

但是这样有一个明显的问题。**<font style="color:rgb(42, 49, 53);">对字符串进行处理不是浏览器的长处</font>**<font style="color:rgb(42, 49, 53);">。当要处理的文本超过 100KB 的时候，浏览器会有明显的卡顿。所以我们最后能够让浏览器可以对标签内的空格进行识别。</font>

<font style="color:rgb(42, 49, 53);">所以说最好是能够直接渲染出标签内的空格。经过一分钟的搜索，得到出了结论，可以使用 css 的属性 white-space。翻阅 mdn 文档之后知道了它的四个属性：</font>

```css
.my-element {
  white-space: normal; /* 默认值 */
}
.preformatted {
  white-space: pre; /* 保留所有空白字符的可见性 */
}
.nowrap-text {
  white-space: nowrap; /* 不换行，文本在一行上显示 */
}
.wrap-text {
  white-space: pre-wrap; /* 保留所有空白字符的可见性，并且超出容器宽度换行 */
}
```

<font style="color:rgb(42, 49, 53);">所以我们使用使用</font>`<font style="color:rgb(42, 49, 53);">pre</font>`<font style="color:rgb(42, 49, 53);">或者 </font>`<font style="color:rgb(42, 49, 53);">pre-wrap</font>`<font style="color:rgb(42, 49, 53);">即可。</font>

<font style="color:rgb(42, 49, 53);">问题来了，我们使用该 css 属性是可以让 v-html 渲染的节点可以实现多空格的渲染的。但是想要拿到富文本的 class 来直接穿透属性进行的方式却行不通。如下图：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1688791556738-d5a33495-26c0-44ce-93c2-2ef398f34f1f.png)

看来是富文本对输入进去的内容进行了处理。所以打开 tiptap 的文档，果然找到了对应配置的属性。

```javascript
new Editor({
  parseOptions: {
    preserveWhitespace: "full",
  },
});
```

代码中有该属性的注释，如下：

```javascript
    /**
    By default, whitespace is collapsed as per HTML's rules. Pass
    `true` to preserve whitespace, but normalize newlines to
    spaces, and `"full"` to preserve whitespace entirely.
    */
    preserveWhitespace?: boolean | "full";
```

翻译的结果就是效果和`white-space`是一样的。

配置上去之后，数据初始话的时候，果然渲染出了多个空格，但是当我们使用`editor.value?.commands.setContent('xx   xxx', false)`给富文本赋值的时候，空格又全部只有一个。官网站不到问题。

属性已经给了，但是配置上去了依旧不行，那是不是 tiptap 自身的 BUG 呢？所以只能去 tiptap 的 github 代码仓库的 issue 上面找寻答案。

换了多个关键字搜索：'space'、'**<font style="color:rgb(42, 43, 46);">entity</font>**'、'content' 垃圾英语表述能力只能通过这样的方式来搜索了，看 Open 的，看 closed。 **这是一个漫长的过程！**

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1688792328037-58f910c6-8f97-4210-9e0d-baf67fb8d37d.png)

还好最终在 closed 中找到了答案，链接如下[https://github.com/ueberdosis/tiptap/issues/3754](https://github.com/ueberdosis/tiptap/issues/3754)

原来配置好初始之后还不够，还需要我们在 setContent 方法里面也添加上`preserveWhitespace`属性。

```javascript
editor.commands.setContent(xxxxx, false, {
  preserveWhitespace: "full",
});
```

问题得到解决。

## 总结

**ChatGTP + 官方文档 + 代码仓库的 issue = 解决**

## 扩展

- <font style="color:rgb(42, 49, 53);">标签内的空格在 ASCII 码中用 32 来表示。</font>
- <font style="color:rgb(42, 49, 53);">一些常用的实体如下：</font>
  - <font style="color:rgb(51, 51, 51);">&lt;：小于号 <</font>
  - <font style="color:rgb(51, 51, 51);">&gt;：大于号 ></font>
  - <font style="color:rgb(51, 51, 51);">&amp;：和号 &</font>
  - <font style="color:rgb(51, 51, 51);">&quot;：引号 "</font>
  - <font style="color:rgb(51, 51, 51);">&apos;：单引号 '</font>
  - <font style="color:rgb(51, 51, 51);">&nbsp;：空格</font>
  - <font style="color:rgb(51, 51, 51);">&copy;：版权符号 </font><font style="color:rgb(51, 51, 51);">©</font>
  - <font style="color:rgb(51, 51, 51);">&reg;：注册商标符号 </font><font style="color:rgb(51, 51, 51);">®</font>
  - <font style="color:rgb(51, 51, 51);">&trade;：商标符号 </font><font style="color:rgb(51, 51, 51);">™</font>
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[webpack 基础]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/构架工具/webpack 基础</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/构架工具/webpack 基础</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[webpack 基础  一、功能总览 - 能够节写 CommonJs 和 ES module 的语法. 自动合并这些模块的代码. - 默认是只能识别 js 和 json,所以为了适应 web 前端开发的工程.需要额外配置一些解析器.这些解析器放在 loader 配置属性当中 - css 使用 style-loader 和 cs-loader, 图片在 4.0 版本可以使用 file-loader 或者 url-loader 来解析. - 为了自动把把生成好的 js 文件自动引入到 html 当中.需要使用 htmlWebpackPlugins 的插件进行配置.还能使用默认的模版 - 如果要使用...]]></description>
            <content:encoded><![CDATA[# webpack 基础

## 一、功能总览

- 能够节写 CommonJs 和 ES module 的语法. 自动合并这些模块的代码.
- 默认是只能识别 js 和 json,所以为了适应 web 前端开发的工程.需要额外配置一些解析器.这些解析器放在 loader 配置属性当中
- css 使用 style-loader 和 cs-loader, 图片在 4.0 版本可以使用 file-loader 或者 url-loader 来解析.
- 为了自动把把生成好的 js 文件自动引入到 html 当中.需要使用 htmlWebpackPlugins 的插件进行配置.还能使用默认的模版
- 如果要使用其他预编译 scss、sass、styleUi,同样是需要对应的 loader
- 生成的 js 文件浏览器不识别,就需要 babel 来对你的 es6 翻译成 es5 语法.

  由此, 一个基本的自动化打包工具就可以构成了 .

  如果还要在开发环境中进行更好的开放的.

- 需要修改了 js 代码,网页就能够自动刷新,并自动打包好. 最常用的就是 webpack-dev-serve 插件.
- 更进一步的就是使用热更新功能,英文缩写是 HMR. 差量更新的功能.
- 差量更新的功能,也叫 HMR,css 的 style-loader 自带有,所以不用配置.而 js 没有,所以需要手动配置 module.asset 一套逻辑
- vue 同理,react 是通过 babel-press 内置功能来实现的

  上面两部分就构成了基本的项目工程化.

  其他部分就到了性能优化和方便项目调试的部分了.

  **性能优化**这些手段: **代码压缩、代码分割、tree-shaking 等**

  **项目调试**有些手段: **`sourceMap`\*\***的配置, webpack-dev-serve、HMR\*\*

  学习 webpack,第一层是学习 webpack 的配置方式.第二层是学习它的配置思路,为什么要这样配置,第三层是学习 loader 的原理、手动写自己的 plugins.

  前两层已经能够保证你能够很好的灵活使用 webpack 来搭配自己的项目脚手架了 .后者是让自己可以站在造轮子的角度去学习,提升自己对于前端工程化的实现原理的理解.

## 二、webpack 安装方式

### 2.1 初始化项目

    -

```js
npm init -y
```

      `-y`中的代表`yes`, 如果不用话,会弹出很多默认配置,需要手动 yes.

      初始化成功之后,会在当前目录目录下生成`package.json`文件.

      > 由于我们前端的工程化是基于 node,所以在使用任何工具之前,都需要配置好 node 开发环境.

### 2.2 安装 webpack 和 webpack-cli

> webpack-cli 用于在命令行中运行 webpack，cli 即命令行接口（Command Line Interface）

安装成功之后,可以在`node_modules`中的`.bin`文件夹中可以看到这两个库的执行命令.

我们平时在终端中执行`npx xxx`就是执行这里面的脚本文件.

```js
npm install --save-dev webpack webpack-cli
```

### 2.5 配置快捷使用命令

```js
// package.json
{
"scripts": {
  "build": "webpack"
}
}
```

    之后我们就可以使用`npm run build`来执行`node_modules`中`.bin`文件夹中`webpack`脚本.

    npm 自定为我们加上了`node_modules/.bin`的前缀.

    > npx 是 npm 的高级使用形象.如果这个包在当前环境不存在,会自动下载一个临时的包来运行,而不会影响到当前的环境.运行完毕之后,就把这个包给删除.

### 2.5 初始化`webpack.config.js`

```js
const path = require("path");

module.exports = {
  entry: "./index.js",
  output: {
    filename: "main.js",
    path: path.resolve(__dirname, "dist"),
  },
};
```

    - `_dirname`代表当前目录

        上面就是 webpack 打包最基本的配置.一个输入文件,一个输出文件.

        > webpack4 之后可以什么都不用配置,能够直接打包.默认的目录和我们配置的目录是一致的

### 2.6 解析 css 文件

```js
npm install style-loader css-loader --save-dev
```

随后进行文件的配置

```js
{
module: {
  rules: [
    {
      test: /\.css$/i,
      use: ["style-loader", "css-loader"],
    },
  ],
},
}
```

test 中是一个正则,就是为了匹配以 css 为后缀的文件.使用的是两种库来进行解析.`loader`类型的库是对于 webpack 来时相当于翻译官,把它在之前不认识的翻译成认识的.

- ### 2.7 自动生成 html 文件,并把打包好的 js 给自动引入

  - 在没有这一步之前,打包成功的话,是把上面的 css 文件以`style`内联样放入到 JS 当中的.并默认对 js 代码进行的压缩.生成了名为 main.js 的文件.

    这个时候就需要我们手动生成 html 文件来手动引入 js.这显然是违背我们自动化的目标的.

    所以这个时候就需要借助`plugins`来进行配置了.

    先试安装`html-webpack-plugin`插件

```js
npm install --save-dev html-webpack-plugin
```

          随后在`webpack.config.js`继续配置

```js
{
plugins: [
  new HtmlWebpackPlugin({
    title: "webpack配置感觉也不是那么复杂的",
    template: "./index.html",
  }),
],
}
```

      - title: 自动生成的 html 的标题名字
      - template: 以这个 html 为模版来生成

          > 默认可以不进行任何的配置,但是这个时候你的 html 的 title 默认会是 Document, 如果要引入第三方库的话,每次打包都需要手动引入,所以 title 和 template 可以说是缺一不可的.

## 四. 不同的打包方式

- 我们不同的环境需要不同的配置,这个就不能单单使用`webpack.config.js`这么一个文件了.当然了,在 vue-cli3.0 中,就是只有一个配置文件的,里面需要的可能配置,都是通过传进去的参数来进行判断.

### 4.1 安装配置合并的插件

```js
npm install webpack-merge -D
```

### 4.2 具体的配置内容

    - 开发环境来做例子,并把生产环境配置的交集部分给删除掉. 包括用到的引入文件

```js
const { merge } = require("webpack-merge");

const baseConfig = require("./webpack.base");
const devConfig = {
  mode: "development",
  devtool: "eval-cheap-module-source-map",
  devServer: {
    static: "./dist",
    port: 3300,
    proxy: {
      "/api": {
        target: "http://study.jsplusplus.com/",
        changeOrigin: true,
        pathRewrite: {
          "^/api": "",
        },
      },
    },
  },
};

module.exports = merge(baseConfig, devConfig);
```

        `webpack.base.js`中的配置和普通的没有什么差别,就是把开发和生产环境的配置内容给集合在一起

```js
const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  entry: "./index.js",
  output: {
    filename: "[name].js",
    path: path.resolve(__dirname, "dist"),
    clean: true,
  },
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ["style-loader", "css-loader"],
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      title: "webpack配置感觉也不是那么复杂的",
      template: "./index.html",
    }),
  ],
};
```

### 4.3 搭配 package.json 快捷使用对应配置

```js
{
"scripts": {
  "build": "webpack --config webpack.pro.js",
  "dev" "webpack --config webpack.dev.js"
}
}
```

## 五、tress Shaking

### 5.1 作用

    - 去除没有使用过的代码

        比如说有如下的文件和代码

```js
// math.js
export const add = (x, y) => {
  return x + y;
};

export const reduce = (x, y) => {
  return x - y;
};
```

        然后在入口文件用引入

```js
const {add} from './math.js'

function init() {
const a = add(1, 2)
console.log(a)
}
```

        上面代码只使用到了 add 这个方法,而 reduce 并没有使用到. 如果这个方法内容很多,但是你由没有使用到,不就白白占用了这么多空间么,所以做好打包之后把它给删除掉.

        而`trees shaking`就是干这件事情.

### 5.2 注意事项

    - 只支持 ES module, 不支持 CommonJs, 因为前者引入是必须要在 top 位置的. 而后者是能够判断的

```js
const flag = true;
if (flag) {
  const test = require("test");
}
```

        而 ES modules 就不能这样操作,不能在{}里面.
    - /_ unused harmony export reduce _/

        出现这个代表你的 tress Shaking 已经生效了.
    - 注意如果是开发环境 development tree shaking 会不生效，因为调试的话 sourceMap 行数会不准，生产环境 production 就会生效

### 5.3 配置方法

    -

```js
{
  mode: 'development',
  optimization: {
    usedExports: true,
  },
}
```

```js
// package.json
{
  "sideEffects": false,
}
```

      > 当 MODE 为 production 的时候,不需要配置 usedExports. 默认生效

      如果配置成 false 的话,会带来问题,就是一些 import 到全局的库也会被干掉.比如 css 文件,lodash 这种库.他们提供 import 到全局的 api,但是没有提供 export 的操作.所以我们为了保住它们,需要让能够实现`tree Shaking`的同时.

```js
{
  "sideEffects": ["@babel/polly-fill", "*.css"]
}
```

### 5.4 实现基本原理

    - 1. ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
        1. 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码

## 六、代码切割

![](https://secure2.wostatic.cn/static/swWDivAk6CEtLR276vvxe5/截屏2022-03-17 12.31.58.png?auth_key=1755594805-kk9oD9JKFzyceKGxPXVwwH-0-dfb35e3b809d114074d47a9fb2639cd2)

### 6.1 webpack.config.js 配置

```js
{
"optimization": {
  "splitChunks": {
    "chunks": "all"
  }
}
}
```

### 6.2 其他两种配置方法

    更加推荐第一种,方便快捷,无脑

#### 6.21 手动同步方法

    -

```js
{
entry: {
  lodash: './src/lodash',
  index: './index.js'
},
output: {
  filename: '[name].bundle.js',
  path: path.resolve(__dirname, 'dist'),
},
}
```

      手动配置输入文件, 不够自动.

#### 6.22 手动异步方法

    - 其中的”（/_ webpackChunkName: "lodash" _/）“表示对该文件引入后的命名

```js
function getComponent() {
  const element = document.createElement("div");

  // Lodash, now imported by this script
  element.innerHTML = _.join(["Hello", "webpack"], " ");
  return import(/* webpackChunkName: "lodash" */ "lodash")
    .then(({ default: _ }) => {
      const element = document.createElement("div");

      element.innerHTML = _.join(["Hello", "webpack"], " ");

      return element;
    })
    .catch((error) => "An error occurred while loading the component");
}

document.body.appendChild(component());
getComponent().then((component) => {
  document.body.appendChild(component);
});
```

### 6.3 详细配置

    -

```JavaScript
{
optimization: {
  splitChunks: {
    chunks: 'all', // async 表示只对异步代码分割，initial 表示只对同步代码分割，all的话是所有同时会走到cacheGroups.vendors
    minSize: 30000, // 表示最小模块大于30000个字节才会做代码分割
    // maxSize: 50000, // 如果拆分的代码大小超过50000,会进行二次拆分，一般配置的比较少
    minChunks: 1,//引入几次才分割打包，如果只引入1次就分割，如果是2表示必须大于等于2次才做代码分割
    maxAsyncRequests: 5,// 表示不能超过5个模块分割，超过后面的模块就不分割了
    maxInitialRequests: 3,// 表示整个网站首页或入口文件 如果做代码分割不超过3个
    automaticNameDelimiter: '~', //组和文件名链接符号 vendors~main.js
    name: true,// 表示要更新名字，一般是不需要改变的
    cacheGroups: {
      vendors: {
        test: /[\\/]node_modules[\\/]/, // 如果在node_modules里，那么会打包到vendors.js
        priority: -10, // 比如jquery 符合vendors 也符合default，值越大，说明优先级更大
        filename:'vendors.js' // 表示所有的第三方打包到一个叫vendors.js文件
      },
      default: { // 如果是引入自己在项目里写的模块引入走这里，非node_modules
        // minChunks: 2,
        priority: -20,// 值越大，说明优先级更大
        reuseExistingChunk: true, // 如果代码已经打包过，重复引用时就不会再分割打包，而是复用之前的。
        filename: 'common.js'
      }
    }
  }
},
}
```

## 七、懒加载

- 其实和上面的代码分割逻辑是一样的.vue 中也存在路由懒加载.都是一个意思. **需要使用到的时候才进行加载**.

## 八、css 代码分割

- 需要安装两个插件来进行搭配使用,配置的文件可以直接看对应插件的文档.

```js
npm install --save-dev css-minimizer-webpack-plugin mini-css-extract-plugin
```

- mini-css-extract-plugin: css 代码分割出来
- css-minimizer-webpack-plugin: 压缩 css 代码

## 九、浏览器缓存问题

- 配置起来很简单,目的也很直接,就是直接修改文件名字

```js
{
output: {
  filename: "[name].[contenthash:8].js",
}
}
```

      contenthash 代表根据内容生成的 hash 值,一共 8 位. 8 是可以自己替换的,不写也行.默认 16 位

      至于为何能够解决浏览器缓存的问题,这就需要知道浏览器缓存的逻辑,[[HTTP基础]]

## 十、webpack 性能优化

### 10.1 优化构建速度

    - babel
    - js 缓存, cacheDirectory
        - 指定要编译文件和不需要编译的文件: include: srcPath 和 exclude: path.resolve(__dirname, 'node_modules)
        - IgnorePlugin: 不引入指定的代码,最终产出的代码没有相应的代码
        - noParse: 不做任何操作,打包中存在
        - happypack:

            > IgnorePlugin 也可以优化产出体积
    - 从三个方法入手: **优化搜索时间、缩小文件搜索范围、减少不必要的编译**

### 10.2 优化产出代码体积

    - IgnorePlugin: 不引入指定的代码,最终产出的代码没有相应的代码
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[使用composition api实践经验]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/使用composition api实践经验</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/使用composition api实践经验</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[使用 Composition API 实战经验 ![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006140571-694fd4fa-87b2-45b6-90d8-7b70304141c8.png) <font style="color:rgb(0, 0, 0);">Composition api 出来之后，我们除了要学习它的 API 之后，更加要学习他为什么要这样设计。</font>  <font style="color:rgb(0, 0, 0);">一、为什么组件越开发越难维护</font> <font style="color...]]></description>
            <content:encoded><![CDATA[# 使用 Composition API 实战经验

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006140571-694fd4fa-87b2-45b6-90d8-7b70304141c8.png)

<font style="color:rgb(0, 0, 0);">Composition api 出来之后，我们除了要学习它的 API 之后，更加要学习他为什么要这样设计。</font>

## <font style="color:rgb(0, 0, 0);">一、为什么组件越开发越难维护</font>

<font style="color:rgb(0, 0, 0);">在讨论组件为什么越来越难以维护，本质是在讨论，</font><font style="color:rgb(0, 0, 0);">compostion-api</font><font style="color:rgb(0, 0, 0);">的抛出是为什么解决什么问题？我们学习一个框架，除了要学习它的 API 之外，更重要的是学习它的 API 为什么要这么设计。</font>

### <font style="color:rgb(0, 0, 0);">1.1 vue2 的项目现状</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006140467-87e7fea2-1339-40a2-ab38-8e5207134749.png)

<font style="color:rgb(0, 0, 0);">以该图为例, A B C 分别是父子孙组件.</font>

<font style="color:rgb(0, 0, 0);">当我们要控制其中一个组件的状态的是, 可以通过很多方式来进行控制. 这些方式的来源有可能是</font>**<font style="color:rgb(0, 0, 0);">全局变量</font>**<font style="color:rgb(0, 0, 0);">、</font>**<font style="color:rgb(0, 0, 0);">vuex</font>**<font style="color:rgb(0, 0, 0);">、事件</font>**<font style="color:rgb(0, 0, 0);">总线</font>**<font style="color:rgb(0, 0, 0);">、以及</font>**<font style="color:rgb(0, 0, 0);">自己父组件或子组件的改变</font>**<font style="color:rgb(0, 0, 0);">等等。</font>

<font style="color:rgb(0, 0, 0);">可以看出, 改变它组件内部状态的来源非常的多, 维护或者修改的时候,需要翻阅的文件目录和范围就很广。更不用说当你发现同样的逻辑在别的地方可以共用的时候，抽离的心智成本自然是很高的。 自然就很难维护。这就是典型的</font>**<font style="color:rgb(0, 0, 0);">意大利面现象</font>**<font style="color:rgb(0, 0, 0);">。</font>

<font style="color:rgb(0, 0, 0);">当你想要进行逻辑复用的话，不要就是 mixins，要不就是 HOC。下面举一个 mixins 的例子：</font>

```plain
export default {
  mixins: [ a, b, c, d, e, f, g],
  mounted() {
    console.log(this.whoAreYou)
  }
}
```

<font style="color:rgb(0, 0, 0);">这个</font><font style="color:rgb(0, 0, 0);">this.whoAreYou</font><font style="color:rgb(0, 0, 0);">你能够知道来源于哪一个么？如果这个组件还使用了 HOC 高阶组件的话，会更加的混乱的。</font>

### <font style="color:rgb(0, 0, 0);">1.2 composition api 带来什么改进呢？</font>

<font style="color:rgb(0, 0, 0);">下面是</font><font style="color:rgb(0, 0, 0);">script setup</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">官方给出它其中的两个优点：</font>

- <font style="color:rgb(0, 0, 0);">更好的逻辑服用</font>
- <font style="color:rgb(0, 0, 0);">更灵活的代码组织</font>![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006140527-5fa27bcf-548f-4bd9-a46e-d32992682b09.png)
- ~~<font style="color:rgb(0, 0, 0);">更好的 ts 支持</font>~~
- ~~<font style="color:rgb(0, 0, 0);">更小的打包体积</font>~~

<font style="color:rgb(0, 0, 0);">下面我来给大家看看实际项目中都是怎么体现出来的。</font>

#### **<font style="color:rgb(0, 0, 0);">更好的逻辑服用</font>**

<font style="color:rgb(0, 0, 0);">这个</font><font style="color:rgb(0, 0, 0);">this.whoAreYou</font><font style="color:rgb(0, 0, 0);">你能够知道来源于哪一个么？如果使用了</font><font style="color:rgb(0, 0, 0);">composition api</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">的话，是下面这样：</font>

```javascript
export default {
  mixins: [a, b, c, d, e, f, g],
  mounted() {
    console.log(this.whoAreYou);
  },
};
```

```tsx
import { myHome } from '@/homwHook'
import { useWho } from '@/whoHook'
const { Iam1 } = useHome()

const { Iam2 as me } = useWho()
```

- <font style="color:rgb(0, 0, 0);">一切都变得很明朗，我可以非常清楚的知道这个方法的来源。维护和可读性都极大的提高了</font>
- <font style="color:rgb(0, 0, 0);">还可以取别名</font>
- <font style="color:rgb(0, 0, 0);">没有创建仅用于逻辑重用的不必要的组件实例。</font>

<font style="color:rgb(0, 0, 0);">composition-api 的书写流程大概就是把可以复用的状态和行为抽成函数，然后在 set up 标签里面引入并执行。如果我们把每个组件也看做一个函数的话，大概就是下面这个意思：</font>

```javascript
import useSth from './Sth'
function Component() {
  useSth()
    ....
}
```

<font style="color:rgb(0, 0, 0);">因为我们的业务中，对每个组件都要进行一些通用的操作，比如打印日志，设置 document.title，配置权限等等，在 composition-api 的背景下，差不多应该这么做：</font>

```javascript
function Component() {
  _logger()
  _setTitle()
  useSth()
    ....
}
```

<font style="color:rgb(0, 0, 0);">如果这些是每一个组件的通用组件，我们又可以怎么使用呢？在 option api 的时代，我使用</font><font style="color:rgb(0, 0, 0);">extend</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">来实现：</font>

```javascript
class BaseComponent extends Vue {
  created() {
    _logger();
    _setTitle();
  }
}
```

<font style="color:rgb(0, 0, 0);">那么每次我只需要 extends 这个 BaseComponent 即可，并不要每次都写执行它们的流程。</font>

<font style="color:rgb(0, 0, 0);">而 hook 的写法更加直接。</font>

```javascript
function abstract(Componet) {
  _logger();
  _setTitle();
  return Component();
}
```

```javascript
<script setup>
  import {abstract} from './abstract' import useSth from './Sth' abstract(() =>
  useSth()) ...
</script>
```

<font style="color:rgb(0, 0, 0);">写法就是将函数作为函数的参数，毕竟在 JS 中函数是一等公民，这是 JS 能够实现函数式范式的基础。展开代码如下：</font>

```javascript
function WithAttr(WrapperComponent) {
  return defineComponent({
    setup() {
      const number = ref(666);
      onMounted(() => {
        console.log("with attr mounted");
      });
      const attr: AttrType = useAttrs(); // 替代v-bind="$attrs"
      // import { h } from 'vue', 可以使用unplugin-auto-import插件省略掉
      return () =>
        h(WrapperComponent, {
          ...attr,
          a: number.value,
        });
    },
  });
}
```

#### **<font style="color:rgb(0, 0, 0);">更灵活的代码组织</font>**

```vue
<template>
  <div v-if="error">failed to load</div>
  <div v-else-if="loading">loading...</div>
  <div v-else>hello {{ fullName }}!</div>
</template>

<script>
import { createComponent, computed } from 'vue'

export default {
  data() {
    // 集中式的data定义 如果有其他逻辑相关的数据就很容易混乱
    return {
      data: {
        firstName: '',
        lastName: ''
      },
      loading: false,
      error: false,
    },
      },
  async created() {
    try {
      // 管理loading
      this.loading = true
      // 取数据
      const data = await this.$axios('/api/user')
      this.data = data
    } catch (e) {
      // 管理error
      this.error = true
    } finally {
      // 管理loading
      this.loading = false
    }
  },
  computed() {
    // 没人知道这个fullName和哪一部分的异步请求有关 和哪一部分的data有关 除非仔细阅读
    // 在组件大了以后更是如此
    fullName() {
      return this.data.firstName + this.data.lastName
    }
  }
}
</script>
```

```vue
<template>
  <div v-if="error">failed to load</div>
  <div v-else-if="loading">loading...</div>
  <div v-else>hello {{ fullName }}!</div>
</template>

<script>
import { createComponent, computed } from "vue";
import useSWR from "vue-swr";

export default createComponent({
  setup() {
    // useSWR帮你管理好了取数、缓存、甚至标签页聚焦重新请求、甚至Suspense...
    const { data, loading, error } = useSWR("/api/user", fetcher);
    // 轻松的定义计算属性
    const fullName = computed(() => data.firstName + data.lastName);
    return { data, fullName, loading, error };
  },
});
</script>
```

<font style="color:rgb(0, 0, 0);">代码更加的干净。而这个干净的感觉就是体现在将三个变量的定义都给藏进了</font><font style="color:rgb(0, 0, 0);">useSWR</font><font style="color:rgb(0, 0, 0);">之中。</font>

<font style="color:rgb(0, 0, 0);">那这个和抽离出去一个函数有什么不同呢？</font>

<font style="color:rgb(0, 0, 0);">这就是它一个关键的地方。</font>

**<font style="color:rgb(0, 0, 0);">composition-api 本质上它带来的组件逻辑的抽离和复用。根本上来说，就是我们可以让响应式变量单独抽离出去了，</font>\*\***<font style="color:rgb(0, 0, 0);">ref</font>\***\*<font style="color:rgb(0, 0, 0);">和</font>\*\***<font style="color:rgb(0, 0, 0);">reactive</font>\***\*<font style="color:rgb(0, 0, 0);">。</font>**

<font style="color:rgb(0, 0, 0);">data、fullName, loading</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">是可以直接作用于视图的。</font>

<font style="color:rgb(0, 0, 0);">在</font><font style="color:rgb(0, 0, 0);">composition-api</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">之前，只能通过</font><font style="color:rgb(0, 0, 0);">mixins</font><font style="color:rgb(0, 0, 0);">和</font><font style="color:rgb(0, 0, 0);">vuex</font><font style="color:rgb(0, 0, 0);">来实现。</font>

<font style="color:rgb(0, 0, 0);">文档中提出了一个尖锐的灵魂之问，你作为一个新接手的开发人员，能够在茫茫的</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">method</font><font style="color:rgb(0, 0, 0);">、</font><font style="color:rgb(0, 0, 0);">data</font><font style="color:rgb(0, 0, 0);">、</font><font style="color:rgb(0, 0, 0);">computed</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">等选项中一目了然的发现这个变量是属于哪个功能吗？比如「创建新文件夹」功能使用了两个数据属性，一个计算属性和一个方法，其中该方法在距数据属性「一百行以上」的位置定义。</font>

<font style="color:rgb(0, 0, 0);">当一个组价中，维护同一个逻辑需要跨越上百行的「空间距离」的时候，即使是让我去维护 Vue 官方团队的代码，我也会暗搓搓的吐槽一句，「这写的什么玩意，这变量干嘛用的！」</font>

<font style="color:rgb(0, 0, 0);">vue 是一个只负责视图的库。MVVC，我们负责 M 和写好 V，至于为什么我们改变了 M，V 就会有相应的变化，那就是 VC 干的事情了，即 Vue 库的工作了。</font>

<font style="color:rgb(0, 0, 0);">基于「逻辑功能」去组织代码，而不是</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">state</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">放在一块，</font><font style="color:rgb(0, 0, 0);">method</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">放在一块，这样和用 Vue2 没什么本质上的区别。</font>

```vue
setup() { // state const a = ref(1) const b = ref('') const c = ref(null) const
d = ref('') // method function handleA() {} function handleB() {} }
```

```vue
setup() { // handle a const a = ref(1) function getA() {} // handle b const b =
ref('') function handleB() {} const c = ref(null) const d = ref('') }
```

#### <font style="color:rgb(0, 0, 0);">额外的作用</font>

<font style="color:rgb(0, 0, 0);">代码行数减少。</font>

<font style="color:rgb(0, 0, 0);">这些就是 composition-api 带来的变化。除此之外呢？让我组件变成混乱的还有一点：</font>

- <font style="color:rgb(0, 0, 0);">业务变量和 UI 变量的混用</font>

### <font style="color:rgb(0, 0, 0);">1.3 业务变量和 UI 变量的混用</font>

<font style="color:rgb(0, 0, 0);">举一个例子, 在上面的目录中</font><font style="color:rgb(0, 0, 0);">dialog 组件</font><font style="color:rgb(0, 0, 0);">的显示或隐藏,是通过</font><font style="color:rgb(0, 0, 0);">model-value / v-model</font><font style="color:rgb(0, 0, 0);">来进行控制的,</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">true</font><font style="color:rgb(0, 0, 0);">就显示,</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">false</font><font style="color:rgb(0, 0, 0);">就隐藏起来. 下面是我们实际项目中的代码，这样的写法很多，很多。</font>

```vue
<span
  class="edit-icon cursor-pointer"
  v-show="
    isMobile &&
    item.editable &&
    group.key === 'user' &&
    visibleIconItemId === item.key
  "
>
  <i class="el-icon-edit" @click.stop="handleEdit(item)"></i>
</span>
```

<font style="color:rgb(0, 0, 0);">通过通过接口拿到的,或者自己组件的数据传进来之后,再进行对 v-model 的控制. data.id 这样的变量就是业务变量, 通过业务变量来直接控制 UI 的组件的显示和隐藏,就是业务变量和 UI 变量的混用. 或者说</font>_**<font style="color:rgb(0, 0, 0);">业务逻辑和交互逻辑的混用</font>**_**<font style="color:rgb(0, 0, 0);">。</font>**

<font style="color:rgb(0, 0, 0);">混用之后的后果,就是我们进行维护的时候, 需要查看的变量或者说字段就成倍的增加, 交互变量和业务变量交织在一起. 这部分的代码</font>**<font style="color:rgb(0, 0, 0);">同时承载了</font>**_**<font style="color:rgb(0, 0, 0);">业务逻辑和交互逻辑</font>**_<font style="color:rgb(0, 0, 0);"> 意大利面。</font>

<font style="color:rgb(0, 0, 0);">所以我们就需要将业务逻辑和交互逻辑给拆开. 如下:</font>

```vue
export default function Dialog() { props = { isShow: { type : Boolean, desc:
'是否显示弹窗' }, type: { type: String, desc: '弹窗的类型' } } render() { return
(
<el-dialog v-model="{ isShow }">
          <template slot="header">
            {{ dialogTitle }}
          </template>
          <template slot="content">
            // type === 创建表单
            // type === 移动文件夹目录
          </template>
        </el-dialog>
) } }
```

<font style="color:rgb(0, 0, 0);">其中 ishow 和 type 就可以视为 UI 变量, 它们不关心外界是通过了什么样的逻辑，什么样的判断, 只关系传进来的是 true 还是 false。这就是很简单的将业务逻辑和交互逻辑拆开。</font>

### <font style="color:rgb(0, 0, 0);">1.4 对于单个业务组件我们的理想模型</font>

<font style="color:rgb(0, 0, 0);">我们根据“角色”或“用途”分为通用型组件和业务型组件，通用型组件对于我们项目而言就是 element ui。所以我们主要面对的是业务型组件。</font>

<font style="color:rgb(0, 0, 0);">由此我们可以得到基于 composition api 可以得出业务型组件理想的模型如下：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006140505-9ec2d28e-7a8a-4218-8a55-71bb1d52656f.png)

<font style="color:rgb(0, 0, 0);">依旧是 A B C 三个组件.但是 A B C 三个组件外边飘的那些箭头不存在了. 所有能够控制它们的内部状态的方式都集中 在了</font><font style="color:rgb(0, 0, 0);">hooks</font><font style="color:rgb(0, 0, 0);">上面.</font>

<font style="color:rgb(0, 0, 0);">其中</font><font style="color:rgb(0, 0, 0);">hooks</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">部分的组织形式和 vue 的</font><font style="color:rgb(0, 0, 0);">composition api</font><font style="color:rgb(0, 0, 0);">宣传图表现一致，每一个颜色对应一个 Hook，就是图上面的 void。</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006140528-f6b8b4c2-1e0c-4dc5-b6fb-57e38071898b.png)

<font style="color:rgb(0, 0, 0);">也就是说,控制 C 组件内部状态的是通过引入到 A 组件中的</font><font style="color:rgb(0, 0, 0);">controller</font><font style="color:rgb(0, 0, 0);">来进行通过,中间的 B 组件不做任何的处理,仅仅作为一个中转站。</font>

<font style="color:rgb(0, 0, 0);">但是在维护起来的时候还是挺灾难的，比如淡蓝色的那个色块代表的功能。我想要完整的理清楚它的逻辑，需要「上下反复横跳」，类似的事情我已经经历过好多次了。</font>

<font style="color:rgb(0, 0, 0);">组件化好似“搭积木”；“分而治之”思想实际运用，所谓“大事化小，小事化了”或称为“抽象隔离”。就是，各个组件之间有自己需要解决的问题，有各自解决的方式方法，但互相 不需要知道，它们沟通只看“结果”即 props，events/emit。</font>

<font style="color:rgb(0, 0, 0);">下面我通过一个实际的业务场景来描述。</font>

## <font style="color:rgb(0, 0, 0);">二、实际的例子</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006144434-75ce3f68-9c73-4263-af64-dc98671d048f.png)

### <font style="color:rgb(0, 0, 0);">2.1 数据流向</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006306543-1518f8a4-b8c6-4cdc-bb27-79acfb902f85.png)

<font style="color:rgb(0, 0, 0);">它由两部分构成:</font>

- <font style="color:rgb(0, 0, 0);">组件的模块</font>
- <font style="color:rgb(0, 0, 0);">组件之间的控制关系</font>

### <font style="color:rgb(0, 0, 0);">2.2 目录结构</font>

```plain
.
├── aside
├── constants
├── content
├── index.tsx
├── hooks
├── modal
└── search
```

#### <font style="color:rgb(0, 0, 0);">index.tsx</font>

```tsx
import { usexxxx, usexxx } from '@/hooks'
import { useModalAdd } from '@/useModalAdd'
import { useModalEdit } from '@/useModalEdit'

const { networkState } = useNetworkState()

// 更新目录树
const { updateTree } = useTree()

// 初始化右边的文档
const { updateContent, addContent } = useRenderContent(networkState)

// 收藏
const { folders, currentFolderData } = useFavorite(networkState)

// 目录树托拽移动
const folderNavigation = useTreeDrop({ networkState, currentFolderData })

  / **
  * 弹窗操作
  * /
  const { ModalAdd, handleAdd } = useModalAdd({
    callbackAdd: updateTree
  })
const { ModalEdit, handleEdit } = useModalAdd()

// Utils
const { slicePath } = usePathUtils()
export default {
  setup () {
    return () => (
      <search />
      <aside />
      <content />
      <ModalAdd />
      <ModalEdit />
    )
  }
}
```

<font style="color:rgb(0, 0, 0);">很清晰的代码结构和逻辑。一个变量都没有，但是通过函数就可以把这一块业务有的功能都给描述清楚了。</font>

### <font style="color:rgb(0, 0, 0);">2.3 ModalEdit</font>

```tsx
import { defineComponent } from "vue";

const useElDialog = () => {};
export const DOC_NAME = "doc_name";
export const DOC_TIME = "doc_time";
export type xxx = typeof DOC_NAME | typeof DOC_TIME;

export function useModalEadit(type) {
  const { Dialog, show, hide } = useElDialog({
    appendToBody: true,
    width: "200px",
  });

  const addModal = () => {};

  const ModalEdit = defineComponent({
    setup() {
      return () => <Dialog>{/* {xxxxx} */}</Dialog>;
    },
  });
  return { ModalEdit, addModal };
}
```

### <font style="color:rgb(0, 0, 0);">2.4 权限控制例子</font>

<font style="color:rgb(0, 0, 0);">颗粒度最小的一个例子：</font>

<font style="color:rgb(0, 0, 0);">此处放流程图：</font>

![]()

<font style="color:rgb(0, 0, 0);">其中最重要的就是拆分好受控组件和非受控组件。</font>

```vue
<tempalte>
  <el-button v-if="$auto('modile_app.version_plan.test_plan.create')" />
  </template>
```

<font style="color:rgb(0, 0, 0);">以 UI 变量来拆分组件。</font><font style="color:rgb(0, 0, 0);">ButtonAuth</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">vue 还是 tsx 无所谓。</font>

```vue
import { defineComponent } from "vue" export function defineComponent({ props: {
type: { type: string, required: true, validator: val => { return
Object.value(AUTH_TYPE).include(val) }, desc: '当前按钮的类型' }, },
setup(props) { const { isShow } = useButtonAuth(props.type) return () => (
<el-button v-if="isShow">
    {/* {xxxxx} */}
    </el-button>
) } })
```

<font style="color:rgb(0, 0, 0);">用一个 useButtonAuth 来统一控制</font>

```tsx
import AUTH_TYPE from 'constant.ts'
export function useButtonAuth(type) {
  const _authList = {
    [AUTH_TYPE.edit]: root.$mobileAppAuthFunction('modile_app.version_plan.test_plan.create''),
    // ....
  }
  const isShow = ref(_authList[type])
  return { isShow }
}
```

<font style="color:rgb(0, 0, 0);">此外还需要一个常量文件</font><font style="color:rgb(0, 0, 0);">constant.ts</font>

```tsx
export AUTH_TYPE = {
  edit: 'edit'，
preview: 'preview',
  // ...
  }
```

<font style="color:rgb(0, 0, 0);">为什么不 vuex 直接控制到组件这里呢？就是为了让我的思维产生定式。后期需要维护的时候，我们第一时间联想到的就是找对应的 hooks，而不是翻阅好几个文件。这就是规范。规范有什么用，就是降低我维护代码的心智负担。</font>

<font style="color:rgb(0, 0, 0);">可能我说得还不够清晰，这个是我们的项目地址。技术栈是 vue3 + hook + ts + jsx</font>

## <font style="color:rgb(0, 0, 0);">三、持续的优化</font>

### <font style="color:rgb(0, 0, 0);">3.1 有了 setup 就足够了么？</font>

<font style="color:rgb(0, 0, 0);">代码终究是要人来写的，起码现在还是。而且一个项目，像我们这样的长期项目，经历过了多批开发人员的项目，不过你前期写得再怎么好，它随着时间的积累，还是会乱的。我们前期的架子只能延缓这个过程。</font>

<font style="color:rgb(0, 0, 0);">在我们实际开发中，某一个功能（业务）逻辑真的很复杂时，聚合度很高，可能一个 API 中有许多的状态，许多的 computed，用到了多个的生命周期钩子函数。如果真的因为某些无法明确的原因将其拆分，或许你真的该考虑下在代码中自行添加一些 Options API 式的注释，它们用于标出用途还是很立竿见影的（返祖 ）。</font>

<font style="color:rgb(0, 0, 0);">这一块是用于 created 的，这一块是用于 methods 的。</font>

<font style="color:rgb(0, 0, 0);">所以说，在我看来，composition api 的带来并没有真正的解决任何问题。代码的质量真正还是取决于使用它的这个人，这个人对于软件工程的理解深度。</font>

### <font style="color:rgb(0, 0, 0);">3.2 持续的优化和阶段性的重构才是根本</font>

<font style="color:rgb(0, 0, 0);">持续的优化和阶段性的重构才是保证代码质量的有力工具。</font>

- <font style="color:rgb(0, 0, 0);">当碰到这里用的代码别的地方也用到的时候</font>
- <font style="color:rgb(0, 0, 0);">这个变量出现在好几个地方,被好几个地方都 set 的时候, 而自己搞不懂它们 set 的顺序的时候</font>
- <font style="color:rgb(0, 0, 0);">函数复杂到自己看了半天都看不明白的时候</font>

<font style="color:rgb(0, 0, 0);">重构不等于重写，它依然有风险，有关于重构的使用策略是另外的一个话题，我们暂且略过。但是对于我们开发者而言，最重要的是知道什么样的代码需要重构。</font>

- <font style="color:rgb(0, 0, 0);">技术债是不可避免的。业务飞速发展时，遗留适当技术债可以帮忙业务强占市场。我们的产品一定是各方妥协的产物。客户端操作体验比 WEB 强了这么多，为什么还不将诺亚做成客户端。</font>
- <font style="color:rgb(0, 0, 0);">技术债的大小和影响，是个很难量化和说清楚的事情。不论哪种测量方式，都不能只看指标；需要不停地在技术和业务之间做出权衡。正如标题所说，如同“带着镣铐在冰山上跳舞”。</font>
- <font style="color:rgb(0, 0, 0);">最重要的一点。除了 TL 之外，团队需要培养“还债”的意识，不止开发团队，需要所有利益相关团队对技术债有正确的认识，并形成“还债”的一个氛围和文化。</font>

<font style="color:rgb(0, 0, 0);">技术债又是另外一个话题。</font>

<font style="color:rgb(0, 0, 0);">最重要的是在保障业务按时完成的情况下，就应该</font>_**<font style="color:rgb(0, 0, 0);">多尝试,多实践</font>**_<font style="color:rgb(0, 0, 0);">。</font>

<font style="color:rgb(0, 0, 0);">最后和大家分享一句话：</font>**<font style="color:rgb(0, 0, 0);">前端是一门手艺活，唯手熟尔。</font>**

<font style="color:rgb(0, 0, 0);">与君共勉。</font>

<font style="color:rgb(0, 0, 0);">谢谢大家。</font>
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[先做人后做事，先学规范后写代码]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/先做人后做事，先学规范后写代码</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/先做人后做事，先学规范后写代码</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[先做人后做事，先学规范后写代码  1. 前言 JS 的使用规范旨在统一团队的代码风格，容易被团队中的任意一人理解，提升被维护性。对于我们这种已经成型的软件而言，是一个提升工作效率瓶颈成本最低，收益最高的方式，没有之一了。 一个良好的代码规范对于应用程序的功能没有直接的影响，但是对于改善源代码的理解是有帮助的。养成一个良好的系统对于软件的开发和维护都是有益的，不仅自己维护起来更加方便，也会让其他读者觉得赏心悦目。 短期可能会比之前花多一点时间，但是长期来看效率肯定是提升的。节省自己的时间，节省沟通的成本，每一位新入职的新员工都应该先 > 本文档很多都是基于百度 WEB 前端开发文档，或者阿里前端...]]></description>
            <content:encoded><![CDATA[# 先做人后做事，先学规范后写代码

## 1. 前言

JS 的使用规范旨在统一团队的代码风格，容易被团队中的任意一人理解，提升被维护性。对于我们这种已经成型的软件而言，是一个提升工作效率瓶颈成本最低，收益最高的方式，没有之一了。

一个良好的代码规范对于应用程序的功能没有直接的影响，但是对于改善源代码的理解是有帮助的。养成一个良好的系统对于软件的开发和维护都是有益的，不仅自己维护起来更加方便，也会让其他读者觉得赏心悦目。

**短期可能会比之前花多一点时间，但是长期来看效率肯定是提升的。节省自己的时间，节省沟通的成本，每一位新入职的新员工都应该先**

> 本文档很多都是基于百度 WEB 前端开发文档，或者阿里前端开发文档

符号说明：

**💪：强制执行**

**💬：建议执行**

## 2. 代码风格

### 2.1 结构（完全基于 Eslint 默认规则）

#### 2.11 缩进

**💬 [建议] 使用 2 个空格作为一个缩进层级，不允许使用 4 个空格**

**说明：** 两个空格，这是谷歌对开源代码的推荐风格。刚开始看是觉得不够层次分明，但看习惯也就好了。用四个的话，删除时退格键地要按好几下，按多了，你就会觉得自己一直是在按空格和删空格，而不是输入代码和改代码。

**💬** **[建议] \*\***`switch`\***\* 下的 \*\***`case`\***\* 和 \*\***`default`\***\* 必须增加一个缩进层级。**

建议不管有没有 default 都需要加上，增加代码的完整性

```js
// good
switch (variable) {
  case "1":
    // do...
    break;
  case "2":
    // do...
    break;
  default:
  // do...
}
// bad
switch (variable) {
  case "1":
    // do...
    break;
  case "2":
    // do...
    break;
  default:
  // do...
}
```

#### 2.12 空格

完全基于 Eslint 的默认规则，希望每个人都能够遵循。而且现在编辑器默认安装的编辑器，右键格式化代码也能够达到同样的目的。

**💪** **[强制]** **二元运算符两侧必须有一个空格，一元运算符和操作对象之间不允许有空格**

```js
let a = !arr.length;
a++;
a = b + c;
```

**💪** **[强制]** **用作代码块起始的左花括号 { 前必须有一个空格。**

```js
// good
if (condition) {
}
while (condition) {}
function funcName() {}
// bad
if (condition) {
}
while (condition) {}
function funcName() {}
```

**💪 \*\***[强制]\*\* **`if / else / for / while / function / switch / do / try / catch / finally`\*\*** 关键字后，必须有一个空格。\*\*

**💪** **[强制]** **在对象创建时，属性中的** **`:`** **之后必须有空格，** **`:`** **之前不允许有空格。**

```js
// good
const obj = {
  a: 1,
  b: 2,
  c: 3,
};
// bad
const obj = {
  a: 1,
  b: 2,
  c: 3,
};
```

**💪 [强制] 函数声明、具名函数表达式、函数调用中，函数名和** **`(`** **之间不允许有空格**

```js
// good
function funcName() {}
var funcName = function funcName() {};
funcName();
// bad
function funcName() {}
var funcName = function funcName() {};
funcName();
```

💪 **[强制]** **在函数调用、函数声明、括号表达式、属性访问、** **`if / for / while / switch / catch`** **等语句中， \*`()`和 `[]`** **内紧贴括号部分不允许有空格。**

```js
// good
callFunc(param1, param2, param3);

save(this.list[this.indexes[i]]);

needIncream && (variable += increament);

if (num > list.length) {
}

while (len--) {}
// bad
callFunc(param1, param2, param3);

save(this.list[this.indexes[i]]);

needIncreament && (variable += increament);

if (num > list.length) {
}

while (len--) {}
```

**💪 [强制] 单行声明的数组与对象，如果包含元素， `{}` 和 `[]` 内紧贴括号部分不允许包含空格。**

```js
// good
var arr1 = [];
var arr2 = [1, 2, 3];
var obj1 = {};
var obj2 = { name: "obj" };
var obj3 = {
  name: "obj",
  age: 20,
  sex: 1,
};
// bad
var arr1 = [];
var arr2 = [1, 2, 3];
var obj1 = {};
var obj2 = { name: "obj" };
var obj3 = { name: "obj", age: 20, sex: 1 };
```

**💪 [强制 行尾不得有多余的空格**

> 这一点在使用 Eslint 插件的项目新手尤其容易犯的问题，好在 webstorn 编辑器会自动的去除行尾的空格，不用我们做过多的操作

**💪 [强制 行尾不得有多余的空格**

说明：不解释，webstorn 编辑器会自动去除，VsCode 需要安装额外插件

```js
// bad
const x = y + 5;
// good
const x = y + 5;
```

#### 2.13 换行

**💪 [强制] 每个独立语句结束后必须换行**

**💪 [强制] 在文件末尾插入一个空行**

**💪 [强制] 每行不得超过 \*\***`120`\***\* 个字符**

```js
// good
if (
  (user.isAuthenticated() &&
    user.isInRole("admin") &&
    user.hasAuthority("add-admin")) ||
  user.hasAuthority("delete-admin")
) {
  // Code
}

var result = number1 + number2 + number3 + number4 + number5;

// bad
if (
  (user.isAuthenticated() &&
    user.isInRole("admin") &&
    user.hasAuthority("add-admin")) ||
  user.hasAuthority("delete-admin")
) {
  // Code
}

var result = number1 + number2 + number3 + number4 + number5;
```

> 超长的不可分割的代码允许例外，比如复杂的正则表达式。长字符串不在例外之列。

**💬** **不同行为或逻辑的语句集，使用空行隔开，更易阅读。**

```js
// 仅为按逻辑换行的示例，不代表setStyle的最优实现
function setStyle(element, property, value) {
  if (element == null) {
    return;
  }

  element.style[property] = value;
}
```

**💬** **在语句的行长度超过 \*\***`120`\***\* 时，根据逻辑条件合理缩进。**

```js
// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。
// 建议最终将右括号 ) 与左大括号 { 放在独立一行，保证与 `if` 内语句块能容易视觉辨识。
if (
  (user.isAuthenticated() &&
    user.isInRole("admin") &&
    user.hasAuthority("add-admin")) ||
  user.hasAuthority("delete-admin")
) {
  // Code
}

// 按一定长度截断字符串，并使用 + 运算符进行连接。
// 分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。
// 特别的，对于 HTML 片段的拼接，通过缩进，保持和 HTML 相同的结构。
let html =
  "" + // 此处用一个空字符串，以便整个 HTML 片段都在新行严格对齐
  "<article>" +
  "<h1>Title here</h1>" +
  "<p>This is a paragraph</p>" +
  "<footer>Complete</footer>" +
  "</article>";

// 也可使用数组来进行拼接，相对 `+` 更容易调整缩进。
let html = [
  "<article>",
  "<h1>Title here</h1>",
  "<p>This is a paragraph</p>",
  "<footer>Complete</footer>",
  "</article>",
];
html = html.join("");

// 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。
// 所有参数必须增加一个缩进。
foo(aVeryVeryLongArgument, anotherVeryLongArgument, callback);

// 也可以按逻辑对参数进行组合。
// 最经典的是 baidu.format 函数，调用时将参数分为“模板”和“数据”两块
baidu.format(dateFormatTemplate, year, month, date, hour, minute, second);

// 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。
// 这通常出现在匿名函数或者对象初始化等作为参数时，如 `setTimeout` 函数等。
setTimeout(function () {
  alert("hello");
}, 200);

order.data.read(
  "id=" + me.model.id,
  function (data) {
    me.attchToModel(data.result);
    callback();
  },
  300
);

// 链式调用较长时采用缩进进行调整。
$("#items").find(".selected").highlight().end();

// 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。
let result = thisIsAVeryVeryLongCondition ? resultA : resultB;

let result = condition ? thisIsAVeryVeryLongResult : resultB;

// 数组和对象初始化的混用，严格按照每个对象的 `{` 和结束 `}` 在独立一行的风格书写。
let array = [
  {
    // ...
  },
  {
    // ...
  },
];
```

⬆️ 该例子出自百度开源的文档规范中

**💬** **关于是否应该添加分号**

个人比较同意**尤雨溪**说的。在 2021 年的今天还在加分号都是过于保守的想法且未经深入思考的草率结论。而且现在新出的语言的可加而不加的语言的有很多，Go, Scala, Ruby, Python, Swift, Groovy...等等。不加分号之后，整个页面会清爽感觉很多。而加了分号除了多打一次字符，没有意义。

而且对于 JS 而言会报错的的情况只有当这 5 种`token，括号，方括号，正则开头的斜杠，加号，减号`为行首。

1.  正则开头作为行首的情况从来没有见过
1.  括号为行首的只有在写原生 JS 的时候构建闭包的时候出现，即(function() {})()这种
1.  方括号作为行首？这又不是 Object-C

综上所述，我们有可能会遇到的情况就是在(function() {})()这种面前加上 **;** 号即可。其他时候都可以去掉分号。一旦习惯了去除了分号，会让整个界面干净整洁很多。百利而无害！

且是否校验分号在 Eslint 中也是一个重要的规范选项。

### 2.2 命名

#### 2.21 文件和文件夹命名

**文件夹** 基本遵循`Camel命名法`

**文件**由于 react 主要是 class 为主，所以必定是使用大驼峰命名法。

#### 2.22 基本类型数据命名

💪 **[强制]** **基本遵循** **`Camel命名法`**

|                 |                |                  |
| --------------- | -------------- | ---------------- |
|                 | Bad            | Good             |
| **常量**        | taskEvents     | TASK_EVENTS      |
| **类/构造函数** | task           | Task             |
| **类型**        | Task、Status   | ITask、EStatus   |
| **CSS**         | task-page-menu | task-page_menu   |
| **变量**        | task_list      | taskList         |
| **i18n**        | taskStatusStop | task_status_stop |

> BEM 命名规范

1.  确保命名语义标准
1.  严禁使用拼命命名
1.  严禁使用 flag/ok 等 😠
1.  长度尽可能不要超过 15 个字符
1.  类/对象内部命名无需再携带主体

```
class Task {
  // bad
  stopTask() {}
  // good
  stop() {}
}
```

#### 2.23 函数命名

- **can** 判断是否可执行某个动作，函数返回一个布尔值。true：可执行；false：不可执行
- **has** 判断是否含有某个值， 函数返回一个布尔值。- true：含有此值；false：不含有此值
- **is**： 判断是否为某个值，函数返回一个布尔值。true：为某个值；false：不为某个值
- **get**： 获取某个之，函数返回一个非布尔值
- **set**： 设置某个值，无返回值、返回是否设置成功或者返回链式对象 load 加载某些数据,无返回值或者返回是否加载完成的结果

```
// 是否可阅读
function canRead() {
 return true
}
// 获取名称
function getName() {
 return this.name
}
```

|              |        |
| ------------ | ------ |
| 新增         | create |
| 添加         | add    |
| 删除         | remove |
| 修改         | update |
| 查询（单个） | get    |
| 查询（多个） | list   |
| 分页查询     | page   |
| 统计         | count  |

**💪 [强制] 采用 handle + 'EventName' 的方式命名**

```
<Component onClick={this.handleClick} />
```

**💬** **[建议]** 语义化的命名

```
// good
int widthInPixels = ...

// bad
int width = ....; // 宽度以像素为单位
```

#### 2.24 当你实在不知道怎么命名的时候

**💬** **遇到一个实在不知道怎么起名字的时候，我们如果用有道翻译的话，有时候语义不一定会准确。毕竟不是母语。这个时候你可以点击以下网站进行搜索，这个网站出来的结果都是 github 开源项目别人的命名，相对而言可能会更加的规范和准确。**
[CODELF (unbug.github.io)](https://unbug.github.io/codelf/)

> 由于是国外服务器，所以一开始可能有点小慢，请耐心等待

## 3. 一目了然的目录结构（react 版本）

一个良好的目录结构是可以自解释的。VUE 框架在使用脚手架创建项目的是，已经自动生成了目录结构。而 React 基于了开发更高的自由度，能够随意让开发者自由的组合适合自己的项目的项目结构，本是好意，但是在一个团队中也需要统一起来。

这部分各部门的项目所使用的技术栈是不同的，细分之处可由各部门相关人士进行**合理的**修改

### 3.1 主体目录结构

💪 **[强制]** ** 基本思路是页面功能模块化，可以方便的迁移业务到新的框架中。但是确实现在的项目目录差别大，所以只能在修改需求的时候，进行目录的迁移。**

![截屏2021-12-17 10.27.33.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cefa906612a2462f91c71636c46f263e~tplv-k3u1fbpfcp-watermark.image?)

**说明：**

以功能模块为一个 page，每个 page 中又存在各自的功能模块。

比如 productManage 中，就包含两个相似的功能，货源管理和商品管理，所以在实际界面中不是在同一个页面，但是由于功能是一致的，所以也应该归位同一类。

**api 和 routers**都在由模块中各自定义，然后统一导出。

pages 下的 index.js 可以看情况来定义它的作用。如果是 productManage 的货源管理和商品管理没有统一的入口的话，就是一个导出页面的作用。如果类似 realRstate 房地产这种有一个共同的入口的话，可以放一个指导页。

**renders**是有状态的组件

**components**是无状态组件

**assets**可以包含 images、util.js 等静态的资源

### 3.2 目录结构的命名空间

命名空间脱胎于 CSS，具体可以查看大神 Harry Robert 对于命名空间的介绍

**💬** 目录结构尽量使用命名空间

```
比如说，我要做一个商品管理的功能，那么商品管理中包含了商品列表，商品的新增以及编辑
```

```js
// good
|__productManage
    |__ add
    |__ edite
    |__ list

// bad
|__productManage
    |__ productManageAdd
    |__ productManageEdite
    |__ productManageList
```

```
bad中，目录的命名就会很长且不够简洁。所以推荐使用第一种类型。同时，在我们使用对象的时候也可以这么干。
```

```
// good
const women = {
   age: 38,
   name: '大仙'
}

// bad
const women = {
  womenAge: 19,
  womenName: '黄大仙'
}
```

> 闭包和 ES6 的 export、import 都是有解决命名冲突的作用，此时不用命名空间何时用？祝同事们都能在完成功能的基础下，写出优雅的代码。

## 4. 类型安全

这个完全抛弃了 JS“灵活”的代码风格，但是确实是肉眼可见的减少很多基本的 BUG，且让接手的人更加好的进行部分的重构。TS 应运而生。

Vue 版本也是可以使用 typescript，早日使用强类型语言对于我们这种业务逻辑相当复杂的项目有一个质的提升。

## 5. 注释

很多书籍和开源的开发文档，甚至网上很多所谓的大神都说不需要注释，一个好的代码时候自带解释的。但是这群在天上的人可能都是生活在母语为英语的国家。

或者团队中的人英语都很牛逼。遗憾的是,国内团队绝大部分英语都很让人拙计的。所以注释是一定要的！

💪 **[强制]文件开头需要添加开发者基本信息**

```
/**
 * @activeName: 优化
 * @description: 针对有些接口返回的结构中没有count的情况
 * @author: 司令总请你吃棒棒糖
 * @time: 2020-09-22 11:04:52
 **/
```

> vsCode 搜索 koroFileHeader 插件可以直接达到这样的效果
> 如何添加自定注释，点击下面链接：

[VsCode 和 WebStorn 自定义修改注释](https://www.wolai.com/bfaoW8feG9iyY8BMNsZjKi)

**💬** **[建议]用代码逻辑去代替注释**

```js
// good
price = numItems * itemPrice;
discount = min(5, numItes) * itemPrice * 0.1;
finalPrice = price - discount;

// bad
// 从价格中减去折扣
finalPrice = numItems * itemPrice - min(5, numItems) * itemPrice * 0.1;
```

**💬** **[建议]** **有意义的注释**

- 不要解释你的代码干了什么，解释的是你代码为什么要这么写(**这个的前提是函数方法必须遵循唯一性，不然命名控制不了你函数的作用**)
- code review 的时候发现的问题或者看代码的人碰到的问题
- 不要出现下面这样的注释：

```js
// bad

// 获取所有用户
userService.getAllUsers()

// 如果name 为空时的检查
if (name.isEmpty()) {...}
```

**💪 [强制]** 双杠注释符号后面一定要加一个空格，在双杠前面加一个空格就可以了。除了它是单独一行

说明：ESlink 规范的标准用法

```js
// good
let userName = "吴叔叔"; // 是否是吴叔叔
let storeName = "狗不理哦"; // 狗都不理的包子

// bad
let userName = "吴叔叔"; //是否是吴叔叔
let storeName = "狗不理哦"; //狗都不理的包子
```

**💪** **[强制]** **函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识**

```js
/**
 * 函数描述
 *
 * @param {string} p1 参数1的说明
 * @param {string} p2 参数2的说明，比较长
 *     那就换行了.
 * @param {number=} p3 参数3的说明（可选）
 * @return {Object} 返回值描述
 */
function foo(p1, p2, p3) {
  var p3 = p3 || 10;
  return {
    p1: p1,
    p2: p2,
    p3: p3,
  };
}
```

> 有相关的插件,也可以使用 koroFileHeader 达到同样的效果

**💪** **[强制]** **对 Object 中各项的描述， 必须使用 \*\***`@param`\***\* 标识**

```js
/**
 * 函数描述
 *
 * @param {Object} option 参数描述
 * @param {string} option.url option项描述
 * @param {string=} option.method option项描述，可选参数
 */
function foo(option) {
  // TODO
}
```

**💪** **[强制]** **必须使用 \*\***`@event`\***\* 标识事件，事件参数的标识与方法描述的参数标识相同。**

```js
/**
 * 值变更时触发
 *
 * @event Select#change
 * @param {Object} e e描述
 * @param {string} e.before before描述
 * @param {string} e.after after描述
 */
this.fire("change", {
  before: "foo",
  after: "bar",
});
```

## 6. 语言特性

这部分基本是在于 ES6 于项目中的应用，咱们的项目绝大部分都是 ES6 语法，但是还有有一些小细节没有使用上，特此列出。

### 6.1 变量

**💪 [强制] var 全部使用 let 来进行定义，引用类型全部使用 const 来进行定义**

```js
let a = "";
const b = {};
const c = [];
```

> 使用 const 来定义的引用值类型改变它的元素是没有问题的，直接改变它的指向的话，一样会报错，感兴趣请自行查询脘一峰的《ES6 标准入门》第三版一书

**💪 [强制]每个 let 只能声明一个变量**

说明：不然多了之后很容易混淆

> 如果该页面你的初始化的变量实在是太多了，那么你应该考虑的是如何拆分页面了

```js
// bad
let a = 1,
  b = 2,
  c = 3;

// good
let a = 1;
let b = 2;
let c = 3;
```

**💪 [强制] 变量必须 \*\***`即用即声明`\***\*，不得在函数或其它形式的代码块起始位置统一声明所有变量**

说明：变量声明与使用的距离越远，出现的跨度越大，代码的阅读与维护成本越高。虽然 JavaScript 的变量是函数作用域，还是应该根据编程中的意图，缩小变量出现的距离空间。

**💪 [强制 将所有的 const 和 let 分组**

```
// bad
let i, len, dragonball,
items = getItems(),
goSportsTeam = true

// bad
let i;
const items = getItems()
let dragonball
const goSportsTeam = true
let len;

// good
const goSportsTeam = true
const items = getItems()
let dragonball
let i
let length
```

### 6.2 条件

**💪 [强制] 在 Equality Expression 中使用类型严格的 `===`。仅当判断 `null` 或 `undefined` 时，允许使用 `== null`**

说明：这个问题在很多项目中问题很严重。但是如果看过《Javascript 高级程序设计》《权威指南》中很明确的指出来这一点。在阿里和百度的 JS 开发文档中，这一点是尤其强调的。TS 的大行其道也是由于其带来的强类型。所以使用 === 可以避免等于判断中隐式的类型转换是一件很自然且应该的事情。

> 本质上还是需要类型安全防范

```js
// good
if (age === 30) {
}

// bad
if (age == 30) {
}
```

**💬 [建议] 尽可能使用简洁的表达式**

```js
// bad
if (name === "") {
}
if (a.length != 0) {
}
if (notTrue === false) {
}
if (noValue === null || typeof noValue === "undefined") {
}

// good
if (!name) {
}
if (a.length) {
}
if (!notTrue) {
}
if (noValue == null) {
}
```

**💬 [建议] 对于相同变量或表达式的多值条件，用** **`switch`** **代替** **`if`**

```js
// good
switch (typeof variable) {
  case "object":
    // ......
    break;
  case "number":
  case "boolean":
  case "string":
    // ......
    break;
}

// bad
let type = typeof variable;
if (type === "object") {
  // ......
} else if (type === "number" || type === "boolean" || type === "string") {
  // ......
}
```

**💬 [建议]** 对于相同变量或表达式的多值条件，用 对象 代替 **`switch`**

```js
// good
const obj = {
  object: ....,
  number: ....,
  boolean: ...,
  string: ...,
}
obj[typeof variable]
```

说明：JS 中一切基于对象的说明从这个角度来说是没有问题的，而且对象的查找也速度也是最快的。

**💬 [建议] if 的嵌套最好不要超过两个，最多两个，你一定有办法来让语句并行**的

**💬 [建议] 使用逻辑运算符代替三元、四元运算符号**

```js
// bad
let a = aa ? aa : null;
let b = b && b.name ? b.name : null;

// good
let a = aa || null;
let b = (b && b.name) || null;
```

说明：逻辑运算符干净整洁为何不用？|| 遇到一个为真就返回，如果没有真的就返回 null。&& 要一直走到头，如果没有真才返回 null

### 6.3 循环

**💬[建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。**

```js
// good
function clicker() {
  // ......
}

for (let i = 0, len = elements.length; i < len; i++) {
  let element = elements[i];
  addListener(element, "click", clicker);
}

// bad
for (let i = 0, len = elements.length; i < len; i++) {
  let element = elements[i];
  addListener(element, "click", function () {});
}
```

说明：循环体中的函数表达式，运行过程中会生成循环次数个函数对象。

**💬 [建议] 对循环内多次使用的不变值，在循环外用变量缓存。**

```js
// good
var width = wrap.offsetWidth + "px";
for (var i = 0, len = elements.length; i < len; i++) {
  var element = elements[i];
  element.style.width = width;
  // ......
}

// bad
for (var i = 0, len = elements.length; i < len; i++) {
  var element = elements[i];
  element.style.width = wrap.offsetWidth + "px";
  // ......
}
```

### 6.4 字符串

**💪 [强制] 使用``来完全代替有插入值的字符串，其他的一贯使用单引号**

说明：``的是 ES6 出来代替单引号和双引号的，除了功能更加强大之外，效率也更高。继续非要使用引号，那么也是要以单引号来代替双引号，因为在浏览器引擎中，双引号解析的时候会比单引号多一步，会造成的性能问题，虽然实际代理的性能提升微不足道，但是这个算是一个程序员的基本素养。

```js
const age = 18;
// good
let name = `吴叔叔今年${age}了`;
const body = "胸";

// bad
let name = "吴叔叔今年" + age + "了";
const body = "胸";
```

> 更多的用法自行查看《ES6 标准入门》

### 6.5 数组

**💪 [强制] 遍历数组不使用** **`for in`**

说明：数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果。

**💬 [建议] 使用展开操作符 … 代替 Array.from，来将一个类数组(array-like) 对象转换成数组**

```js
const foo = document.querySelectorAll(".foo");
// good
const nodes = Array.from(foo);
// best
const nodes = [...foo];
```

**💬 [建议]** **使用数组展开操作符 … 复制数组**

```js
// bad
const len = items.length;
const itemsCopy = [];
let i;
for (i = 0; i < len; i += 1) {
  itemsCopy[i] = items[i];
}
// good
const itemsCopy = [...items];
```

**💬 [建议]** **使用数组展开操作符 … 合并数组**

```js
let a = [1];
let b = [2];
// bad
let c = a.concat(b);

// good
let d = [...a, ...b];
```

### 6.6 函数

**💬 [建议] 一个函数的长度控制在 \*\***`50`\***\* 行以内**

**说明**：将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。

> 特定算法等不可分割的逻辑允许例外。

```js
function syncViewStateOnUserAction() {
  if (x.checked) {
    y.checked = true;
    z.value = "";
  } else {
    y.checked = false;
  }

  if (a.value) {
    warning.innerText = "";
    submitButton.disabled = false;
  } else {
    warning.innerText = "Please enter it";
    submitButton.disabled = true;
  }
}

// 直接阅读该函数会难以明确其主线逻辑，因此下方是一种更合理的表达方式：

function syncViewStateOnUserAction() {
  syncXStateToView();
  checkAAvailability();
}

function syncXStateToView() {
  y.checked = x.checked;

  if (x.checked) {
    z.value = "";
  }
}

function checkAAvailability() {
  if (a.value) {
    clearWarnignForA();
  } else {
    displayWarningForAMissing();
  }
}
```

- 其实就是遵循函数的唯一性，不管你用啥开发语言都需要这东西。

关于函数的唯一性，如何落地，具体请如下查看:

> 关于函数唯一性可以自己搜索学习,掘金不给提供外链

**💬 [建议] 一个函数的**参数在 6 个以内

**说明** 这一点其实有异议。在《代码整洁之道》中，作者建议我们实现函数的科里化，参数最多只能传一个，在阿里的规范中又是 3 个。

**💪 [强制] 使用默认参数语法，而不要使用一个变化的函数参数**

```js
// really bad
function handleThings(opts) {
  // 更加糟糕: 如果参数 opts 是 falsy(假值) 的话，它将被设置为一个对象，
  // 这可能是你想要的，但它可以引起一些小的错误。
  opts = opts || {};
  // ...
}
// still bad
function handleThings(opts) {
  if (opts === void 0) {
    opts = {};
  }
  // ...
}
// good
function handleThings(opts = {}) {
  // ...
}
```

尾调用优化的必须性

闭包引起的内存泄露的问题

### 6.7 对象

**💪 [强制]** **使用字面量语法创建对象**eslint: no-new-object

```js
// bad
const item = new Object();
// good
const item = {};
```

**💬 [建议] 当创建带有动态属性名称的对象时使用计算的属性名称**

说明：它们允许你在一个地方定义一个对象的所有属性

```js
function getKey(k) {
  return `a key named k`;
}

// bad
const obj = {
  id: 5,
  name: "San Francisco",
};
obj[getKey("enabled")] = true;

// good
const obj = {
  id: 5,
  name: "San Francisco",
  [getKey("enabled")]: true,
};
```

**💬 [建议]** **使用对象属性速记语法**，基于 ES6 对象解构

```js
const lukeSkywalker = "Luke Skywalker";
// bad
const obj = {
  lukeSkywalker: lukeSkywalker,
};
// good
const obj = {
  lukeSkywalker,
};
```

> 此处是 ES6 对象的结构

**💬 [建议]** 将速记属性分组写在对象声明的开始处

说明：更容易看出哪些属性在使用速记语法

```js
const anakinSkywalker = "Anakin Skywalker";
const lukeSkywalker = "Luke Skywalker";
// bad
const obj = {
  episodeOne: 1,
  twoJediWalkIntoACantina: 2,
  lukeSkywalker,
  episodeThree: 3,
  mayTheFourth: 4,
  anakinSkywalker,
};
// good
const obj = {
  lukeSkywalker,
  anakinSkywalker,
  episodeOne: 1,
  twoJediWalkIntoACantina: 2,
  episodeThree: 3,
  mayTheFourth: 4,
};
```

**💬 [建议] 用对象展开操作符浅复制对象，优先于 Object.assign 。使用对象剩余操作符来获得一个省略某些属性的新对象**

```js
// very bad
const original = { a: 1, b: 2 };
const copy = Object.assign(original, { c: 3 }); //  `original` 是可变的 ಠ_ಠ
delete copy.a; // so does this

// bad
const original = { a: 1, b: 2 };
const copy = Object.assign({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 }

// good
const original = { a: 1, b: 2 };
const copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 }
const { a, ...noA } = copy; // noA => { b: 2, c: 3 }
```

### 6.8 **解构 Destructuring**

**💪 [强制] 当访问和使用对象的多个属性时，请使用对象解构**

说明：eslint: prefer-destructuring jscs: requireObjectDestructuring

```js
// bad
function getFullName(user) {
  const firstName = user.firstName;
  const lastName = user.lastName;
  return `firstName lastName`;
}
// good
function getFullName(user) {
  const { firstName, lastName } = user;
  return `firstName lastName`;
}
// best
function getFullName({ firstName, lastName }) {
  return `firstName lastName`;
}
```

**💪 [强制] 使用数组解构**

说明：eslint: prefer-destructuring jscs: requireArrayDestructuring

```js
const arr = [1, 2, 3, 4];
// bad
const first = arr[0];
const second = arr[1];
// good
const [first, second] = arr;
```

**💪 [强制]** **使用对象解构来实现多个返回值，而不是数组解构**

说明：您可以随着时间的推移添加新的属性或更改排序，而不会改变调用时的位置

```js
// bad
function processInput(input) {
  return [left, right, top, bottom];
}
// 调用者需要考虑返回数据的顺序
const [left, __, top] = processInput(input);
// good
function processInput(input) {
  return { left, right, top, bottom };
}
// 调用者只选择他们需要的数据
const { left, top } = processInput(input);
```

## 7. Rreact Native 强相关编码规范

- **相关内容**

  ### 7.1 代码基本规范

  #### 7.11 命名

  **💬 [建议] 包名，文件夹名小写，使用下划线进行分割**

  > 查询了网上开源的项目，包名和文件夹名都是小写，且使用下划线进行分割。但是由于我们所有文件名都是小驼峰命名，所以只能写到哪里改那里，一下内容都是如此。

  **💬 [建议]** 模块使用当前文件名一样的名称，但不推荐使用 index.js 作为入口文件，突出 Page 承担的概念以及对开发 IDE 的适用

```
import DemoPage from './DemoPage/DemoPage'
```

```
该规范出自阿里开放文档中，**模块的入口文件不建议使用index.js**
```

**💬 [建议]** 组件中存在返回 view 的命名 1. 以 render 开头 ❌ 2. 以 view 结尾 ☑️

```jsx
render() {
  return ()
}
renderContent = () => {
  return (
    <View />
  )
}
itemView = () => {}
```

#### 7.12 对齐

**💪 [强制] 遵循以下的 JSX 语法缩进/格式。**

```jsx
// bad
<Demo props1=""
      props2=""/>

// good 有多行属性，新建一行关闭标签
<Demo
    props1=""
    props2=""
    />

// 若能直接一行显示的，直接写成一行
<Demo props1=""/>
```

#### 7.13 单引号还是双引号

**💪 [强制]** ** 对于 JSX 属性值总是使用双引号（""），其他都是用单引号**

```jsx
// bad
<Demo props=''/>

// good
<Demo props=""/>
```

#### 7.14 空格

**💪 [强制]** 总是在标签关闭前加一个空格

**💪 [强制]** 不要在 JSX {} 括号内两边都加空格

```jsx
// good
<Demo />

// good
<Demo style={baz}>
```

### 7.2 代码顺序

好的顺序，代码清晰，方便查找，提高效率

**💪 [强制]** ** import 顺序一般如下，并且分组**

```jsx
`1` React

`2` ReactNative

`3` 导入第三方组件库

`4` 导入自定义组件

`5` 导入相对路径文件（图片、公共样式）

`6`  const 常量

`7` let 变量
```

```jsx
import React, { Component } from "react";
import { StyleSheet } from "react-native";
import {} from "ajd-mobile";
import ReactWeb from "react-native-web";
import DemoPage from "./DemoPage";
const PAGE = 1;
let name = "value";
```

**💪 [强制] 方法的顺序如下**

```jsx
getDefaultProps;
getInitialState;
componentWillMount;
componentDidMount;
componentWillReceiveProps;
shouldComponentUpdate;
componentWillUpdate;
componentDidUpdate;
componentWillUnmount;

其他方法;

render;
```

### 7.3 使用对象替代 switch case

```
和6.2中的条件一致。

对象的查找速度在Javascript中是最快的，毋庸置疑。所以才有了new Map()做数据字典的运用。
```

```jsx
// bed
 renderStatusStamp(status) {
    switch (status) {
      case '-1':
        return <Image source={images.icons.orderStatusCancel} />
      case '0':
        return <Image source={images.icons.orderStatus0} />
      case '1':
        return <Image source={images.icons.orderStatusWillPay} />
      case '10':
        return <Image source={images.icons.orderStatus1} />
      case '20':
        return <Image source={images.icons.orderStatus2} />
      case '30':
        return <Image source={images.icons.orderStatus3} />
      case '40':
        return <Image source={images.icons.orderStatus4} />
      case '50':
        return <Image source={images.icons.orderStatus5} />
      case '60':
        return <Image source={images.icons.orderStatus6} />
      case '70':
        return <Image source={images.icons.orderStatus7} />
      default:
        return null
    }
  }

// good
renderStatusStamp(status) {
    const stampContainer = {
      '0': <Image source={images.icons.orderStatus0} />,
      '1': <Image source={images.icons.orderStatusWillPay} />,
      '10': <Image source={images.icons.orderStatus1} />,
      '20': <Image source={images.icons.orderStatus2} />,
      '30': <Image source={images.icons.orderStatus3} />,
      '40': <Image source={images.icons.orderStatus4} />,
      '50': <Image source={images.icons.orderStatus5} />,
      '60': <Image source={images.icons.orderStatus6} />,
      '70': <Image source={images.icons.orderStatus7} />,
      '-1': <Image source={images.icons.orderStatusCancel} />,
    }
    return stampContainer[status]
  }
```

### 7.4 PureComponent

当 props 或者 state 改变的时候，会执行 shouldComponentUpdate 方法来判断是否需要重新 render 组建，我们平时在做页面的性能优化的时候，往往也是通过这一步来判断的。Component 默认的 shouldComponentUpdate 返回的是 true，如下：

```jsx
shouldComponentUpdate(nextProps, nextState) {
  return true;
}
```

```jsx
而PureComponent的shouldComponentUpdate是这样的：
```

```jsx
if (this._compositeType === CompositeTypes.PureClass) {
  shouldUpdate =
    !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
}
```

相当于 PureComponent 帮我们判断如果 props 或者 state 没有改变的时候，就不重复 render，这对于纯展示组件，能节省不少比较的工作

### 7.5 React 组件设计原则

```
引用下面这位前端大佬的文章
```

https://juejin.cn/post/6844903609419694093

**💬 [建议]** 多使用 React.Fragment 对组件进行包裹

说明：React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点

```jsx
render() {
  return (
    <React.Fragment>
      <ChildA />
      <ChildB />
      <ChildC />
    </React.Fragment>
  )
}
```

### 7.6 封装与分离

**💪 [强制]** ** 每个组件不应该[SHOULD NOT] 超过 600 行**

```
> 如果时间足够，可以压缩到每个组件300左右的，这个是可行的，只要组件设计得合理
```

**💪 [强制] 每个方法不应该[SHOULD NOT] 超过 40 行**

### 7.7 样式

**💪 [强制]** 项目的通用样式写在项目通用样式类

**💪 [强制]** 模块通用样式写在模块通用样式类中

**💪 [强制]** 文件通用样式写在文件底部的 const styles 中

**💪 [强制]** 独有样式写在行 style 中

**样式和逻辑分离，是 web 前端第一原则**

**说明**：W3C 标准定义 WEB 包含三个层，

- 结构层（HTML）
- 表现层（CSS）
- 行为层（Javascript）

提倡“结构、表现、行为，三者分离，互不干涉”的 WEB 页面。即时是在 react 中，结构层已经和行为层放在一起，但是表现层依然不应该和行为层混在一起。

按照 W3C 标准，编写网页时应先考虑结构，之后再结构的基础上添加样式，最后在加上交互行为。

### 7.8 关于组件数组初始化

**💪 [强制]** 变量初始化都在 state 中，要使它立即变化再进行别的操作的话，使用 this.setState({}, () => {}) 的回调来进行操作

说明：来源于阿里 P7 小野森森的开源 RN 项目

```jsx
// bad
constructor(props) {
  this.state = {
  }
  this.content = '小冷请村叔叔吃麻辣烫'
}

// good
constructor(props) {
  this.state = {
    content: '小冷请村叔叔吃麻辣烫'
  }
}
```

虽然 this 用得很爽，但是在维护的时候，看代码很难找到它的初始值，对于代码的维护还是非常的不易的。

### 7.9 关于数据驱动

现在前端流行的三大框架中，vue 和 react 都是数据驱动型的框架，这个不仅仅是现在，也是未来的的发展方向。

在 MCV 架构中，react 负责额是 V 这部分，和数据驱动在其中的意思，就是界面的渲染是根据你数据的变化而变化的。如下：

```jsx
<React.Fragment>
  <Text>狗不理</Text>
  <Text>村叔叔请你吃棒棒糖</Text>
</React.Fragment>
```

可以变成如下：

```jsx
const array = ['狗不理', '村叔叔请你吃棒棒糖']
<React.Fragment>
  {
    array.map((item, idnex) => {
      return <Text key={index}>{item}</T
    })
  }

</React.Fragment>
```

下面的写法除了更加的切合 react 数据驱动的核心思想之外，view 只用写一遍，样式也只要写一遍，就能够让你专注于处理数据就行。

**💬 [建议]** 书写符合数据驱动思想的代码

## 8. Vue 强相关

**💪 [强制] 组件名应该使用多个单词，命名规范 kebabcase**

> 避免和 HTML 元素相冲突，其不区分大小写的哦

```
// bad
export default {
  name: 'Todo'
}

// good
export default {
  name: 'TodoItem'
}
```

**💪 [强制] 组件文件名的格式 Pascal-case 格式**

```
// bad
myComponenet.vue

// good
my-component.vue
```

**💪 [强制] 基础文件名以独特的命名开头，使用完整单词**

默认使用 base 开头，可以考虑使用 zs

```
// bad
MyButton.vue

// good
base-button.vue

zs-button.vue
```

**💪 [强制] 有父子关系的组件，子组件以父组件名为前缀名**

父组件： `todo-list.vue`

```
// bad
todoItem.vue

// good
todo-list-item.vue
todo-list-button.vue
```

**💪 [强制] Props 定义需要尽可能的详细**

- 使用小驼峰命名
- 必须制定类型
- 必须加上注释
- 必须选择`require` 或 `default`
- 根据页面加上 `validator` 验证

[HTML 和 CSS 相关规范](https://www.wolai.com/we7DgvRR2h7XUk2tdFuLKk)
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[前端已死]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/前端已死</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/前端已死</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[前端已死  <font style="color:rgb(0, 0, 0);">一、为什么要分享这么一个主题</font> <font style="color:rgb(0, 0, 0);">这个话题非常的重要，前端都死了，还学这些 vue3、hook、函数式有蛋用？岗位都没有了？你学得再好有什么用？更不用说，一群 985/211 的小孩要出来了，学历高，基础好，还年轻，最重要还便宜，我拿什么和他们拼？有什么优势和它们拼？</font> <font style="color:rgb(0, 0, 0);">所以我在准备 hook 材料的时候，一直不得劲，如果只是为了完成 KPI，毫无意义。</f...]]></description>
            <content:encoded><![CDATA[# 前端已死

## <font style="color:rgb(0, 0, 0);">一、为什么要分享这么一个主题</font>

<font style="color:rgb(0, 0, 0);">这个话题非常的重要，前端都死了，还学这些 vue3、hook、函数式有蛋用？岗位都没有了？你学得再好有什么用？更不用说，一群 985/211 的小孩要出来了，学历高，基础好，还年轻，最重要还便宜，我拿什么和他们拼？有什么优势和它们拼？</font>

<font style="color:rgb(0, 0, 0);">所以我在准备 hook 材料的时候，一直不得劲，如果只是为了完成 KPI，毫无意义。</font>

<font style="color:rgb(0, 0, 0);">而导致我想法这么消极，就是因为我标题的前四个字前端已死，它让我一直处于一个焦虑状态。所以不聊不行！</font>

<font style="color:rgb(0, 0, 0);">首先来看一下这个话题形成的过程。</font>

## <font style="color:rgb(0, 0, 0);">二、话题形成的过程</font>

### <font style="color:rgb(0, 0, 0);">2.1 话题起源</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006439085-9c9ffbe0-e4dc-4efd-9718-1872ccafd728.png)

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006439119-bbcd5aea-7316-4053-9cc1-4c43c9e8043c.png)

<font style="color:rgb(0, 0, 0);">这个话题最近一次是在今年春季形成。源自于脉脉，当时脉脉上面出现一些前端已死的言论。</font>

### <font style="color:rgb(0, 0, 0);">2.2 形成的过程</font>

<font style="color:rgb(0, 0, 0);">![](</font>[https://secure2.wostatic.cn/static/9ZsgAvTvjw7Y25DH5zUZwA/Screenshot](https://secure2.wostatic.cn/static/9ZsgAvTvjw7Y25DH5zUZwA/Screenshot)<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">2023-08-23 at 15.56.54.png?auth_key=1704006402-5n1SnuGMuWyUW6nhH9Mg5q-0-b55cebcae1c7402ce96d080e07168beb)</font>

<font style="color:rgb(0, 0, 0);">![](</font>[https://secure2.wostatic.cn/static/ofRhHEr7jB7th98zpAgXzf/Screenshot](https://secure2.wostatic.cn/static/ofRhHEr7jB7th98zpAgXzf/Screenshot)<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">2023-08-23 at 15.56.44.png?auth_key=1704006402-sDS6MB1jYcHMsc3NVgGGrq-0-8b8690487d96d17ebf9c51a7ed5e1f5b)</font>

<font style="color:rgb(0, 0, 0);">![](</font>[https://secure2.wostatic.cn/static/xi9J1y6Khn6wGwUmBWEDTf/Screenshot](https://secure2.wostatic.cn/static/xi9J1y6Khn6wGwUmBWEDTf/Screenshot)<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">2023-08-23 at 15.56.37.png?auth_key=1704006402-vdy5X4YnWHjkpVjivDSKxC-0-48fcf22d43e4b6ca78d04b0dee69da20)</font>

<font style="color:rgb(0, 0, 0);">![](</font>[https://secure2.wostatic.cn/static/nvkoq81dSHyBy9Zvbhao8e/Screenshot](https://secure2.wostatic.cn/static/nvkoq81dSHyBy9Zvbhao8e/Screenshot)<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">2023-08-23 at 15.56.26.png?auth_key=1704006402-t2gEG4BdFkzfZAGPf7wtoM-0-fc839a06024916b791a8db0052321119)</font>

- <font style="color:rgb(0, 0, 0);">恰逢大量企业</font>[裁员](https://www.zhihu.com/search?q=%E8%A3%81%E5%91%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2997393573%7D)<font style="color:rgb(0, 0, 0);">(各大公司的裁员信息)，阿里裁员、腾讯裁员、facebook 的元宇宙裁员 90%，微软全球裁员百分之 30。招聘需求放缓，大量的悲观情绪经过一个月的酝酿，从 2 月中旬开始，脉脉上开始出现较密集的**「前端已死」**相关话题。</font>
- <font style="color:rgb(0, 0, 0);">随后在掘金，在知乎，都要很多人讨论这个问题，常常上热榜，造成了更大范围的影响。</font>![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006439124-558534e3-f448-425a-8447-35449bb0fba6.png)

## <font style="color:rgb(0, 0, 0);">三、当前的现状</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006439093-a32d0749-25a2-4934-b96c-267ff6db4904.png)

<font style="color:rgb(0, 0, 0);">所以前端到底死没死！我这里有一些数据可以给大家分享。</font>

### <font style="color:rgb(0, 0, 0);">3.1 官方媒体数据</font>

<font style="color:rgb(0, 0, 0);">人民网，可能 web 前端是拖后腿的。</font>

<font style="color:rgb(0, 0, 0);">![](</font>[https://secure2.wostatic.cn/static/jNSDv8uCNnSDTs9BJATQtu/Screenshot](https://secure2.wostatic.cn/static/jNSDv8uCNnSDTs9BJATQtu/Screenshot)<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">2023-08-23 at 15.50.19.png?auth_key=1704006402-3HnC21xJtA2Q2hmfjVeGNB-0-4c9dbd7962f9ff39f7971974a13358be)</font>

### <font style="color:rgb(0, 0, 0);">3.2 B 站小野森森调查结果</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006439266-c1f12b99-81d8-489b-ab7b-5e5d06e10ad6.png)

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006440063-08349194-155e-47c0-9aae-1be5c7f3cf52.png)

<font style="color:rgb(0, 0, 0);">同比上一年，他结论是：</font>

    1. <font style="color:rgb(0, 0, 0);">招聘预期人数低于2022年同期约50%</font>
    2. <font style="color:rgb(0, 0, 0);">招聘达成率低于2022年同期约30%</font>

- <font style="color:rgb(0, 0, 0);">3.12-25k 薪资区间的薪资达成平均值低于 2022 年同期 15%</font>
  1. <font style="color:rgb(0, 0, 0);">招聘要求明显高于 2022 年同期水平</font>
  2. <font style="color:rgb(0, 0, 0);">简历放弃数量高达 30-40%</font>
  3. <font style="color:rgb(0, 0, 0);">应聘人数高于 2022 年同期 70%</font>
  4. <font style="color:rgb(0, 0, 0);">应聘本科率高于 2022 年同期 40%</font>
  5. <font style="color:rgb(0, 0, 0);">面试轮数多于 2022 年同期</font>
  6. <font style="color:rgb(0, 0, 0);">面试邀请率最大 4%</font>
- **<font style="color:rgb(0, 0, 0);">9.offer 发放率最大 1.6%</font>**

<font style="color:rgb(0, 0, 0);">这个数据简单来说，就是</font>**<font style="color:rgb(0, 0, 0);">招聘的岗位减少了，应聘的人数增多了，面试要求提高了</font>**<font style="color:rgb(0, 0, 0);">。</font>

<font style="color:rgb(0, 0, 0);">100 个人去面试，只发了 1.6 个 Offer。</font>

<font style="color:rgb(0, 0, 0);">不知道大家对这个百分之 1.6 有概念么？我弟今年高考，为了他选学校。我就对这种数据排名比较敏感。广西今年 46 万考生，百分之 1.6 就是 7600 名，这可是高本一线 110 多分的排名。这个分数只有我在初中的时候敢想，小学的时候选择的是清华。高考的时候就没有拿到这个排名，凭什么进了社会就可以办到呢？人不是一下子就能上进，人家在高考的时候把你赢了，找工作的时候你真的就能反超么？</font>

<font style="color:rgb(0, 0, 0);">我对自己是没有这么大的自信，不要拿个例当典普遍。</font>

### <font style="color:rgb(0, 0, 0);">3.3 国外的情况</font>

<font style="color:rgb(0, 0, 0);">来自 Indeed 的招聘指数数据：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006440076-bcbeb78f-15b1-4207-b874-285b271dff4d.png)

<font style="color:rgb(0, 0, 0);">国外的情况相比去年也是一个下降的趋势。尤其是 UK，和中国一样，岗位数量是拦腰折半的。这也符合我们对于现在全球性经济大衰退的一个整体认知。</font>

### <font style="color:rgb(0, 0, 0);">3.4 其他的有意思现象</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006440388-269f4713-9728-4ec2-b19f-aaa5fd117772.png)

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006440354-6504b968-3b4a-4d6d-93c5-86f11d9d517c.png)

<font style="color:rgb(0, 0, 0);">这张图可能有一些兄弟姐妹看过了，贴吧的一个老哥用一个公司去 Boss 上面发布招聘信息。</font>

<font style="color:rgb(0, 0, 0);">公司的背景是一个“一个 0 到 20 人小公司”。发布没几天没多久就收到 300 个前端，300 个 JAVA，200 个测试的简历。我们可能掂量一下这些数据的份量。所有有一些人是海投的，也可以中侧面说明，面试者已经饥不择食了。</font>

<font style="color:rgb(0, 0, 0);">供过于求，完全的买方市场。</font>

<font style="color:rgb(0, 0, 0);">需求减少得很明显，本来一个项目还是能够进账的，但是发现把你开了能够赚得更多。</font>

### <font style="color:rgb(0, 0, 0);">3.5 深圳具体的招聘数据</font>

<font style="color:rgb(0, 0, 0);">左边是 8 月 22 日的最新数据。前端岗位招聘人数有 3685 个人。右边是今年招聘人数的趋势。有人说市场在回暖？数据没有这个表现。</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006779437-a412f5e8-6cc8-422e-bedf-d87aaaf4a6b7.png)

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006785971-b46ff180-5f89-472a-99af-070306a4700f.png)

<font style="color:rgb(0, 0, 0);">深圳有多少个前端呢？ 网上搜索不到具体的数据，所以去问了文心一言，得出了这样的回答。</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006808638-5cba982e-49e7-4fa5-ac40-f129c1e5c9b4.png)

### <font style="color:rgb(0, 0, 0);">3.6 总结</font>

<font style="color:rgb(0, 0, 0);">不知道大家对于这么数据有什么感想。</font>

<font style="color:rgb(0, 0, 0);">‘前端已死’是一句带有情绪的话，用阮一峰的话来总结：</font>

**<font style="color:rgb(0, 0, 0);">技术发展缓慢（说一下，flutter），没有大的热点，业务重要性下降，就业机会减少</font>**<font style="color:rgb(0, 0, 0);">。</font>

<font style="color:rgb(0, 0, 0);">减少前面都应该加一个形容词，那就是“大大的减少”。</font>

## <font style="color:rgb(0, 0, 0);">四、我可以怎么做</font>

### <font style="color:rgb(0, 0, 0);">4.1 正确的心态</font>

<font style="color:rgb(0, 0, 0);">我收集这些数据并不是为了传播焦虑，这些是客观现实，我必须要面对的现状。毕竟不是你的对手也不全是 985 211。</font>

<font style="color:rgb(0, 0, 0);">既然情况已经这样了。一味地抱怨没有意义，问题还是解决的。赵本山的老图说得依旧很有道理。</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006440347-0411b4b1-6887-4bd3-9892-c93fdeffed8a.png)

_**<font style="color:rgb(0, 0, 0);">前端已死、后端已亡、测试被开、产品被裁、运维跑路、行业已黄！</font>**_

<font style="color:rgb(0, 0, 0);">![](</font>[https://secure2.wostatic.cn/static/9JgxpeEGBmCq4S2R6vGjot/Screenshot](https://secure2.wostatic.cn/static/9JgxpeEGBmCq4S2R6vGjot/Screenshot)<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">2023-08-23 at 15.25.49.png?auth_key=1704006403-nBdnxhboDWTxJvnCptxqTV-0-c99059e3ce138fa82e1d7357f2ad699e)</font>

<font style="color:rgb(0, 0, 0);">以及对于 AI 的开发，出自阮一峰的文章。</font>

<font style="color:rgb(0, 0, 0);">老三程序员，这个是他文章的链接</font>[https://github.com/ixaxaar/VardaGPT/blob/master/STORY.md](https://github.com/ixaxaar/VardaGPT/blob/master/STORY.md)

<font style="color:rgb(0, 0, 0);">简单的说，就是他让 ChatGPT 写一个他想要的程序，结果整整化了三个周末才跑起来。</font>

<font style="color:rgb(0, 0, 0);">下面就是他对 AI 的评价。</font>

<font style="color:rgb(0, 0, 0);">•有时我对 ChatGPT 的理解能力感到惊讶，但是更多时候，我不得不拼命推动它，朝着我想要的方向前进。它有时会产生意料之外的结果，让我感到非常沮丧。"</font>

<font style="color:rgb(0, 0, 0);">“它像一个吸收了所有人类知识、但需要别人帮忙才能把这些知识串起来的应届毕业生。</font>

<font style="color:rgb(0, 0, 0);">"看来我今年的工作是安全的。但是，我需要好好学习 ChatGPT，精通它的使用，让我明年也是安全的。"</font>

<font style="color:rgb(0, 0, 0);">还是阮一峰，他的话让我听得不那么的焦虑。</font>

**<font style="color:rgb(0, 0, 0);">AI 与人类不是竞争关系，它未必会减少机会，反而可能带来更多的机会。</font>**

<font style="color:rgb(0, 0, 0);">所以好好学习 ChatGTP，让它作为放大自己生产力的工具才是我们正确的态度。</font>

<font style="color:rgb(0, 0, 0);">总结一下，就是做好以下心里准备：</font>

- <font style="color:rgb(0, 0, 0);">直面现实</font>
- <font style="color:rgb(0, 0, 0);">保持学习</font>

### <font style="color:rgb(0, 0, 0);">4.2 我可以选择的路</font>

<font style="color:rgb(0, 0, 0);">如果“前端已死”不再是一句情绪的话，而成为我的现实呢？被裁了。应该怎么办？所以我把可以走的路都列了出来。</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006684481-3ccd671b-85a1-416d-87ce-4e38201b259d.png)

<font style="color:rgb(0, 0, 0);">国内情况不好，国外也不乐观，但是如果我们可以吧国内和国外都作为选择项呢？</font>

<font style="color:rgb(0, 0, 0);">所以，除了英语的能力之外，所有需要的技能都有一个公约数，那就是</font>**<font style="color:rgb(0, 0, 0);">学习能力</font>**<font style="color:rgb(0, 0, 0);">。</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006440944-b32164a4-9d12-4b44-99cf-d5934e78f9d2.png)

<font style="color:rgb(0, 0, 0);">如果对于在舒适圈中的前端这个方向，我都不能学下去，我还能从哪里锻炼自己的学习能力呢？</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704006440956-104e180d-7d11-4b93-b9c1-1aab3d94a1f0.png)

<font style="color:rgb(0, 0, 0);">如果在自己的舒适圈内，都没有把事情做好，真到了需要转行的时候，我凭什么就能干好其他事情。这是不现实的。</font>

<font style="color:rgb(0, 0, 0);">这就是为什么我都要失业了，还要和大家讨论函数式是什么？代码如何组织？这就是为什么我们依旧在组织分享，组织技术分享。你们都没有尽力的在自己的舒适圈里面把本职工作做得的很好。有什么资格抱怨大环境，有什么理由在担心未来。行业的起升又和你有什么关系？</font>

<font style="color:rgb(0, 0, 0);">有一段话我觉得很有道理：为什么我似乎懂得了很多道理，但是依旧过不好这一生。为什么呢？是因为我们自以为自己懂得了这些那些的道理，但是我过往的那些认知都是通过短视频，通过知乎，这些都是别人灌输给我的结论，这些是自己的东西么？一年看了几本书了？去过什么地方了？深入什么到行业了么？了解这些行业的底层逻辑吗？才 20 多岁，最多 30 岁出头，懂个屁。</font>

<font style="color:rgb(0, 0, 0);">这句话是骂我自己的，惊醒我自己的。我感觉我身边都是卷王。</font>

<font style="color:rgb(0, 0, 0);">另一方面，【前端已死】它其实是一个很大的问题，我们为什么活得这么累啊，就是因为我经常活在宏观述说当中。【前端已死】能够牵扯到的东西太大，中美对抗、俄乌冲突、全球经济周期性下滑，国际资本投资，没有一样是我能够影响的。如果每天都因为这些事情去网上和别人打嘴炮的话，对自己的生活没有任何意义。我能够影响到只有我写的代码。做好自己份内的工作，就是对这个社会最大的贡献！</font>

<font style="color:rgb(0, 0, 0);">这些话都是在骂我自己</font>
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[产品经理不靠谱怎么办]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/产品经理不靠谱怎么办</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/产品经理不靠谱怎么办</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[产品经理不靠谱怎么办 :::info 文章资料来源于极客时间上面<font style="color:rgb(136, 136, 136);">郑晔</font>的《10x 程序员》 ::: > 本文的问题都是出自于《10x 程序员》，这本书基本把我们平时工作中遇到的问题都涉及到了，给我带了很多的思考，也直接帮助到了我的工作。本篇文章，只是抽出他的几篇文章结合起来，加以自己的理解。推荐同学们自己去搜索来看看全书。 > > 图片的来源不明，多个地方看到，不知道水印的是不是真正的来源  一、产品和开发之争 ![](https://cdn.nlark.com/yuque/0/2022/png/654...]]></description>
            <content:encoded><![CDATA[# 产品经理不靠谱怎么办

:::info
文章资料来源于极客时间上面<font style="color:rgb(136, 136, 136);">郑晔</font>的《10x 程序员》

:::

> 本文的问题都是出自于《10x 程序员》，这本书基本把我们平时工作中遇到的问题都涉及到了，给我带了很多的思考，也直接帮助到了我的工作。本篇文章，只是抽出他的几篇文章结合起来，加以自己的理解。推荐同学们自己去搜索来看看全书。
>
> 图片的来源不明，多个地方看到，不知道水印的是不是真正的来源

## 一、产品和开发之争

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670605425982-16c09f9b-e5f5-4422-bd82-799d9e46c815.png)

开发和产品宿命的争斗由来已久，倏然就是一对天敌。

### 平安产品掐架事件

在刚毕业那会，还不知道产品具体是干啥的时候，就听到了不少产品和开发打架的事情。印象最深的，就是平安产品开发掐架事件了。起因是<font style="color:#262626;background-color:rgba(255, 255, 255, 0);">产品经理提了一个需求，要求 APP 开发人员可以做到根据用户的手机壳来改变手机软件主题，面对这样的需求，开发自然是要起义的。</font>

<font style="color:#262626;background-color:rgba(255, 255, 255, 0);">真假分辨不是重点，从争论的热点而言可知，就这件事情而言，争论的原因是需求不符合常理。开发做的事情只是对世界建模而不是无中生有。而我们作为开发，平时和产品决斗最多的情况，是对于时间资源之争。产品混乱的开发节奏，不符合逻辑的需求，不合理的时间安排，不重点的优先级安排。</font>

<font style="color:#262626;background-color:rgba(255, 255, 255, 0);">而且很多时候，产品的职位是要比开发的高的，话语权更加的高，会让他们更加的肆无忌惮，可恨！</font>

<font style="color:#262626;background-color:rgba(255, 255, 255, 0);">拿我之前公司的真实的例子来说，产品所谓的需求文档都是短短几句话；一个迭代周期内从来没有按照原订计划上线计划的功能，各种小需求，拍脑袋的需求随意插入。前者，总监对这种行为的解释是需要开发和产品共同去参与设计，相互残缺不漏，不说开发得不到第一手信息，但是你的时间可还是有限的，工资也不是不涨的。后者直接导致了开发的加班。</font>

### <font style="color:#262626;background-color:rgba(255, 255, 255, 0);">为什么会有这些不靠谱的产品经理呢？ </font>

<font style="color:#262626;background-color:rgba(255, 255, 255, 0);">根本还是我的问题，我没有能力轻易的选择自己工作环境</font><font style="color:#262626;background-color:rgba(255, 255, 255, 0);">🙃</font>

<font style="color:#262626;background-color:rgba(255, 255, 255, 0);">其次才是他们专业程度不够，被培训机构忽悠的，人人都是产品经理，门槛低工资还高，上可以直接对话老板，下可以指挥程序员，所以导致了什么阿猫阿狗都涌入。</font>

<font style="color:#262626;background-color:rgba(255, 255, 255, 0);">但是产品的门槛其实很高的。他们</font>需要很强逻辑能力, 整理出来的需求需要逻辑自洽, 需要思考用户的操作体验,需要思考人力资源的分配。面对老板、市场、业务方抛来的‘建议’，能够甄别出什么是功能，什么是需求，然后制定出合理的优先级。在敏捷项目中，还要制定迭代的计划，顶得住上面的压力，压得服下面的开发。

其中涉及到的专业技能有社会心理学、管理学、软件工程管理、用户画像学、以及一定的开发基础、一定的设计基础、一定的运营基础。

这些东西的难度不是程序员用计算机能够模拟的，不然为什么会有智障的小爱同学、小冰同学、siri。

### <font style="color:#262626;background-color:rgba(255, 255, 255, 0);">根本的目的是为了解决问题</font>

<font style="color:#262626;background-color:rgba(255, 255, 255, 0);">当然，本篇文章依旧《10x 程序员》目的并不是为了抨击产品多么多么的不靠谱。就像</font><font style="color:rgb(136, 136, 136);">郑晔</font>老师所说，如果从不靠谱的数量来说，程序员是比产品多得多得。第一是因为程序员基数就比产品的多，第二也是因为万物皆可转码导致的。培训班培养几个月就出来工作了，他能有多强的编程能力？

> 只是从整个市场来看，当然还是有很多转行的，培训出来的很强的人。

这篇文章的目的，是为了解决点那个我们碰到这些不靠谱的产品经理的时候，我们应该如何怎么办？

首先要知道产品和开发的战争是因何而战的。

## 二、争论的真相是什么

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670652342018-507d306e-7de9-4388-9e4a-9f2be8df90a1.png)

### 争论的原因

产品和开发相互攻击是解决不了任何问题的。为了解决争斗，我们首先需要知道到底是争什么？为何而争。方能对症下药。

我们常常会出现下面这样的一个场景：

> 产品：我们需要一个单点登录的界面。输入账号密码就可以进行我们的界面。
>
> 开发：好的
>
> 一天时间，界面和交互逻辑，接口哗哗做完。
>
> 开发：东西做完了，你来看看
>
> 产品：？？？ 验证码呢？
>
> 开发：你又没说
>
> 产品：这个不是常识么？
>
> 开发：。。。。
>
> 又是半天时间，验证码搞定
>
> 产品：这个项目是放在门户下面，登录的功能不是应该在门户上面做么？现在跳转到别的项目还需要重新登陆，你怎么想的？
>
> 开发：顶你个肺，一开始怎么不说是这个场景
>
> 产品：你又没问。。。
>
> 🔪 🙎‍♂️

这是由于双方信息不同步的导致的。如果一开始开发就问：

- 这个需求的用户是谁？
- 这个需求的使用场景在哪里？

我想问题就会拖到后面了。开发必须要有自己的独立思考，多问几个为什么，才能够减少掉进坑中的次数。

双方的知识储备不一样，双方掌握的信息不一样，得到的结论自然也不一样。

所以这就需要我们在一个信息平台上，才能够沟通得有效率。

而这就需要我们双方都能有一个很好的沟通能力。也需要我们开发多张十个心眼，默认产品都是不靠谱的。多问几个为什么，不要害怕问题幼稚。如果产品都能够一一回应，而且逻辑自洽的话，那么恭喜你，你碰到了一个不错的产品。

> 有一句话说得好，当你和一个人谈话谈得很开心的时候，很可能是因为对方的段位比你高，他在向下兼容。

当然，出现上面的那些问题，也由于现在解决的问题不再是明确的，常常范围模糊，别说产品自己，业务用户也不知道自己想要什么？这个无形中提高了产品的门槛，还提高了需要软件设计师的架构能力，需要提前布局。

<font style="color:rgb(51, 51, 51);">软件开发的主流由面向确定性问题，逐渐变成了面向不确定性问题。为了应付这个问题，敏捷开发这个最佳实践就应运而生。到了中国就变成了“田园敏捷”</font><font style="color:rgb(51, 51, 51);">🐶</font><font style="color:rgb(51, 51, 51);">，需求不明确，所有需求都是 P0 级。</font>

<font style="color:rgb(51, 51, 51);">为了解决这个问题，我们产品和开发能够在有效的资源中做些什么呢？这就不得不提到敏捷开发中两个很重要的阶段，需求澄清和需求反澄清，如果是开发负责人还需要参加需求准入。</font>

### 沟通的真正目的是什么

先简单的介绍一些敏捷开发流程：

两周一迭代，在进入开发之前，产品内部需要先过一遍需求，随后根据列的需求和开发负责人讨论**需求准入**，开发负责人会根据人力资源来和产品共同商量，这个迭代可以上的内容。到**需求澄清**，这个是全体人员都参加，产品一一说需求的逻辑，开发可以提问。之后就到了**需求反澄清**，这个阶段是开发在说自己对于需求的开发，以及开发的思路。随后进入开发阶段。开发完成，向产品 show case, 测试通过之后前后端**封版**。封完版提发布工单，然后才进行反版。在这个阶段还包括了每日的**站会**过需求，还有发版之后的**回顾会。**

如时间表下图：

![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/654315/1670658038324-6e8af812-30a5-4ba5-8c35-e4b61811753f.jpeg)

从图片可以看到对于开发两个重要的节点，一个是需求澄清，另外一个是需求反澄清。前者是产品在说，开发问。后者是开发在说，产品再问。这两个就是一个很好的拉平双方认知的机会。

这两个沟通的机会至关重要，是有效减少之后扯皮的关键节点。这就需要我们知道如何有效的进行沟通了 。

唯心主义不是贬义，而是一个客观的事实。具体表现就在于，这个客观世界和我们所想象的总是不一样的。同样的，由于每个人认知的世界是不一样的，所以信息的传递是会衰减的，你不可能把你理解的信息 100% 传递给另外一个人，而这中间，如何传递，也就是如何描述将直接决定衰减的比例。

可以根据书中信息论模型来进行解释：

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670436230807-aa8bee33-3c0e-46f7-8c8a-b68f0cc1de7f.png)

幻化为人的沟通的话。人的脑子就是信源，携带着信息到发送器，发送器通过自己的表达通过声带发送给对方，对方接受到信息还需要转译一遍进行自己的大脑。在传送的中间过程，还有噪声源，这个噪声源可以是物理环境认为的嘈杂，也可以认为是双方因为地位的不同，导致的思维方式的不同的噪声。

根据这个例子，可以用下面这张图来表示上面争论的原因：

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670436236912-3d327e37-c4ce-4c64-8207-46c7ffb1429b.png)

扮演不同角色的时候，我们的思考模式是不同的。上图是产品作为信源，而开发作为信宿，反之亦然。

**作为信源的话**，我们将自己脑中的信息通过嘴巴表达出去的过程，是受限于知识储备和表达能力的。也就是说如果我们的知识储备足够的多，表达能力足够的强的话，在发送信息到对方的闹钟的时候，偏差自然也会更加的小。

**作为信宿的话**，我们开发作为接受的一方，需要提高自己的知识边界，主要是了解业务的前因后果，尽可能的提升解码的能力。

综上所述，我们沟通的目的是为了同步信息，减少对于需求的理解的偏差。而沟通出来的结果，就是共同确立一个**验收的标准**。

只有验收的标准确定下来之后，才可以最到限度的减少后期扯皮的可能性。

那么我们作为开发需要怎么做呢？

### 开发需要做什么

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670436265442-646ba3d3-6fc0-4d0e-bd5c-3c324a062123.png)

开发在需求澄清的时候，其他问题都可以不问，但是这两个问题一定要搞清楚。

1. 需求的背景是什么
2. 需求能够给用户带来什么业务的价值

前者是为了理解业务的前因后果，当自己当成产品经理，让需求的逻辑能够自洽。后者是换位自己作为一个用户，以用户的视角来看问题。这也和我们公司以用户导向的价值观相符。

在需求反澄清的时候，作为一个前端工程师，我们最低限度的需要出两个东西，一个是 API 的设计文档，另外一个就是**数据走向图**。这个数据走向图我的前一篇文章《vue 的业务开发如何进行组件化》中进行过阐述，具体可以去那篇文章看看。

> 敏捷开发不代表文档的缺失。

我曾经把产品问懵逼之后，把需求都砍了一大半。也间接实现了**最好维护的代码。**

我的目的不是为了砍需求，而是为了写出全世界最好维护的代码，即不用的代码。

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670436316938-6458508d-6168-422f-90a3-71fcc5de4341.png)

## 三、抛弃固有印象

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670436318430-77b25f44-f048-4fe6-ad8d-a76c93b188ad.png)

在程序员眼里：

- 产品一般都没逻辑、缺乏交流基础（没常识）、没能力没主见；

在产品经理眼里：

- 程序员通常属于严重沟通障碍、缺乏用户和产品意识、只考虑技术、没有大局观。

抛弃这些固有的刻板印象，沟通和理解更为重要。作为开发不能因为一时的占了上风，就沾沾自喜，大快人心，觉得压了产品一头。爽归爽了，你的工资可还是没动的。班还是要加的。所以解决问题才是主要的目的，不管工作中，还是生活中。

而这就要求我们：

- 加强专业知识的学习，
- 增加对彼此工作领域的认知，
- 用逻辑而非借口来说服对方。

开发可以去考考 PMP 证书，虽然都说没有含金量，但是你得过了才有资格来说这句话。作为前端还可以去学学基础的美学设计。总的来说就是要扩展自己的知识边界。

而且，大家都是打工人，我们要知道矛盾的根源是什么？根本问题真的是产品的不靠谱和开发的沟通障碍么？或许不见得。

## 四、矛盾的根源

之前刷知乎看到过程墨大佬的一段话，记了下来：

在我国，产品经理和研发工程师的核心冲突，是“有限的开发资源”与“无限制的目标”之间的矛盾。

“有限的开发资源”在研发工程师这一边，人力是有限的，人的工作时间是有限的，人的耐心是有限的，人能够做的事情是有限的。

“无限制的目标”在产品经理这一边，无数量限制的需求变更，无规则限制的产品设计流程，无时间限制的工期规划……

怎么解决？

要么提供更多的开发资源，也就是招更多更合格的工程师；要么就让产品经理对自己的行为做更多限制，让产品设计和规划按照客观规律办事。

当然，说到底两者之间的矛盾的根源是我国特色资本主义的内部矛盾，一方面想让团队跑得快，一方面又没有本事进行合理管理，最后产品经理和程序员打架，世人在骂产品经理无能程序员暴躁，其实归根结底是上面人无能而已。

## 五、一个问题

我之前面试，被问我这么一个问题：

**一个需求你评估完成的时间需要两周,但是产品最多只能给你一周的时间,你怎么办?**

那场面试虽然过了，但是我没有收到对于我说的答案的评价。所以很好奇大家的答案是什么 😂
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[代码审查常见问题]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/代码审查常见问题</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/代码审查常见问题</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[格式错误 +  是否符合开发规范      - 详情请参考前文代码规范 +  eslint 规则是否正确  +  是否使用了 ignore   在 ESLint 中，可以使用 .eslintignore 文件来指定忽略文件的规则。该文件使用与 .gitignore 相同的语法，并支持通配符。通常，您应该将 .eslintignore 文件放在项目根目录下，并在其中指定要忽略的文件或目录。例如：  javascript  Ignore all files in the nodemodules directory nodemodules/  Ignore compiled output dist/...]]></description>
            <content:encoded><![CDATA[## 格式错误


+  **是否符合**[**开发规范**](https://odocs.myoas.com/folder/5bqnrvGOwEc1yVqy) 
    - 详情请参考前文代码规范
+  **eslint 规则是否正确** 
+  **是否使用了 ignore**  
在 ESLint 中，可以使用 `.eslintignore` 文件来指定忽略文件的规则。该文件使用与 `.gitignore` 相同的语法，并支持通配符。通常，您应该将 `.eslintignore` 文件放在项目根目录下，并在其中指定要忽略的文件或目录。例如： 



```javascript
# Ignore all files in the node_modules directory
node_modules/
# Ignore compiled output
dist/
build/
*.min.js
```



## 二、**功能性问题**


### 2.1 **内存泄露**


+ 定时器未清除：



```javascript
// 创建一个定时器
let timer = setInterval(() => {
  console.log('Hello World');
}, 1000);
// 未清除定时器
```



```plain
解决方法：在不需要定时器时，使用 clearInterval() 方法清除定时器。
```



+ 闭包



```javascript
// 创建一个闭包
function closure() {
  let count = 0;
  return function() {
    count++;
    console.log(count);
  }
}
// 调用闭包
let func = closure();
func();
func();
func();
// 未销毁闭包
```



```plain
解决方法：在不需要闭包时，将其引用的变量置为 null，或者避免创建闭包。
```



+ 循环引用



```javascript
// 创建两个对象之间的循环引用
let obj1 = {};
let obj2 = {};
obj1.obj2 = obj2;
obj2.obj1 = obj1;
// 未解除循环引用
```



```plain
解决方法：在不需要使用对象时，将其引用的对象置为 null，或者使用 WeakMap 等特殊数据结构来避免循环引用。
```



```javascript
// 解除循环引用
obj1.obj2 = null;
obj2.obj1 = null;
```



+ DOM泄露



```javascript
<!-- 创建一个DOM节点 -->
<div id="test"></div>
<script>
  // 给DOM节点添加事件监听器
  document.getElementById('test').addEventListener('click', () => {
    console.log('Click');
  });
  // 未删除DOM节点
</script>
```



```plain
解决方法：在不需要使用DOM节点时，使用 removeEventListener() 方法删除事件监听器，或者使用 removeChild() 方法删除DOM节点。
```



```javascript
// 删除DOM节点和事件监听器
let dom = document.getElementById('test');
dom.removeEventListener('click');
dom.parentNode.removeChild(dom);
```



+ 大量数据的存储



```javascript
// 存储大量数据
let data = [];
for (let i = 0; i < 1000000; i++) {
  data.push({ name: `User${i}`, age: i });
}
// 未清除数据
```



```plain
解决方法：在不需要存储数据时，将其置为 null，或者使用缓存池等技术来优化数据的存储和释放。(代码中从来没有看到过)
```



```javascript
// 清除数据
data = null;
```



### 2.2 **异步操作是否有异常处理**


在Vue开发中，异步操作通常会涉及到网络请求、组件生命周期等操作。以下是一个使用Vue.js进行网络请求的例子：



```javascript
<template>
  <div>
    <div v-if="loading">Loading...</div>
    <div v-else-if="error">Error: {{ error }}</div>
    <div v-else>Data: {{ data }}</div>
  </div>
</template>
<script>
export default {
  data() {
    return {
      loading: true,
      error: null,
      data: null
    };
  },
  created() {
    // 发起网络请求
    fetch(url)
      .then(response => {
        // 处理响应数据
        return response.json();
      })
      .then(data => {
        // 更新数据
        this.data = data;
        this.loading = false;
      })
      .catch(error => {
        // 处理异常
        this.error = error.message;
        this.loading = false;
      });
  }
};
</script>
```



在上述代码中，我们使用Vue.js中的data属性来进行状态管理，并在created生命周期函数中发起了一个网络请求。在Promise的then方法中，我们处理响应数据并更新组件的状态。在catch方法中，我们处理异常并更新组件的状态。在组件的渲染中，我们根据不同的状态来显示不同的内容，包括数据、错误信息和加载状态。  
除了网络请求之外，组件生命周期中也有可能出现异常。以下是一个使用errorCaptured方法进行异常处理的例子:



```javascript
<template>
  <div v-if="hasError">Something went wrong.</div>
  <div v-else>Hello World</div>
</template>
<script>
export default {
  data() {
    return {
      hasError: false
    };
  },
  errorCaptured(error, vm, info) {
    this.hasError = true;
    console.error(error, vm, info);
  }
};
</script>
```



在上述代码中，我们使用Vue.js中的errorCaptured方法来进行异常处理。当组件的子组件或其自身发生错误时，errorCaptured方法就会被调用。在该方法中，我们可以进行异常处理，并更新组件的状态，从而触发组件的重新渲染。



### 2.3 **取值空判断，类型判断**


+ 使用if else来对可能为空的值进行处理
+ 使用三元表达式



```javascript
{{ message ? message : 'Message is empty.' }}
```



+ 使用逻辑运算符



```javascript
{{ message || 'Message is empty.' }}
```



+ 如果是对象属性，逻辑运算符结合 `.?`



```javascript
obj?.message || 'Message is empty'
```



+ 类型判断：尽量不用any



### 2.4 **是否考虑边界情况**


+  工具逻辑代码中  
比如有如下代码： 



```javascript
function sum(arr) {
  let result = 0;
  for (let i = 0; i < arr.length; i++) {
    result += arr[i];
  }
  return result;
}
```



```plain
在上述代码片段中，我们可以想象以下几种情况：

- 输入一个空数组
- 输入一个包含一个数值的数组
- 输入一个包含多个数值的数组
- 输入一个包含非数值的数组

通过对这些情况进行测试，可以确定代码是否考虑了边界情况。
```



+  写静态界面中  
考虑用户的设备，屏幕大小，当前屏幕显示大小的不同会带来的什么影响。 



### 2.5 **无意义的 if else 代码块**


+  减少嵌套  
如下代码： 



```javascript
if (condition1) {
  // do something
} else {
  // do esle something
}
```



```plain
可以使用卫语句减少一层：
```



```javascript
if (condition1) {
  // do something
  return
}
// do else something
```



+  大量的if else if  
如下代码： 



```javascript
if (condition1) {
  // do something
} else if (condition2) {
  // do something
} else if (condition3) {
  // do something
} else if (condition4) {
  // do something
}
```



```plain
上述代码中，如果条件判断过多，将会导致代码的可读性和可维护性大大降低，因此需要尽可能地简化条件判断的逻辑，例如使用switch case语句或者对象字面量、工厂模式等。
```



+ 重复的if else



```javascript
if (condition1) {
  // do something
} else if (condition2) {
  // do something
} else if (condition3) {
  // do something
}
if (condition1) {
  // do something
} else if (condition2) {
  // do something
} else if (condition3) {
  // do something
}
```



```plain
可以看情况使用策略模式
```



### 2.6 **无意义的 catch**


+ 空的catch



```javascript
try {
  // do something
} catch (error) {
  // empty catch
}
```



```plain
上述代码中，catch代码块为空，没有对错误进行任何处理，这将导致程序在出现错误时无法正确地处理错误，也无法输出有用的错误提示信息。
```



+ 不记录错误信息的catch



```javascript
try {
  // do something
} catch (error) {
  console.log('Error occurred.');
}
```



```plain
上述代码中，catch代码块只是简单地记录了错误发生的事实，但没有记录具体的错误信息。这将使得问题的排查和修复变得更加困难，同时也无法对用户提供有用的反馈信息。
```



+ 不抛出错误的catch



```javascript
try {
  // do something
} catch (error) {
  console.log(error);
}
```



```plain
上述代码中，catch代码块只是简单地输出了错误信息，但没有将错误重新抛出，这将导致错误在被捕获后并没有得到处理，程序可能会继续运行，但是已经出现了错误。
```



总之，在编写catch代码块时，需要确保错误得到正确地处理，包括记录错误的具体信息、输出有用的错误提示信息、重新抛出错误等，以便程序能够正确地处理错误，给用户提供更好的反馈信息



```plain
> 滥用try catch是不负责任的，但是现实很无奈的让我们不得不使用try catch。
```



### 2.7 **安全风险代码**


+  eval()函数  
eval()函数可以将字符串作为JavaScript代码执行，因此可能会导致代码注入攻击。例如： 



```javascript
eval('console.log("Hello, World!")');
```



```plain
上述代码中，如果eval()函数的参数是由用户输入的，那么可能会导致代码注入攻击。
```



+  innerHTML属性 
    - innerHTML属性可以将HTML代码插入到文档中，因此也可能会导致代码注入攻击。例如：



```javascript
ocument.getElementById("myDiv").innerHTML = "<script>alert('Hello, World!');</script>";
```



```plain
上述代码中，如果innerHTML属性的值是由用户输入的，那么可能会导致代码注入攻击。
```



+  with语句  
with语句可以将一个对象的属性绑定到当前的作用域链中，因此可能会导致变量污染和代码注入攻击。例如： 



```javascript
with (document.forms[0]) {
  // do something with form elements
}
```



```plain
上述代码中，使用with语句可能会将不安全的对象属性添加到作用域链中，从而导致变量污染和代码注入攻击。
```



+  
    4. 不安全的跨域请求

在Web开发中，可能会涉及到跨域请求。如果跨域请求没有进行正确的处理，可能会导致安全漏洞。例如： 



```javascript
<script src="http://www.example.com/evil.js"></script>
```



```plain
上述代码中，如果evil.js中包含恶意代码，那么可能会导致跨站脚本攻击。
```



+ 不正确的输入



验证 在Web开发中，用户输入的数据可能会包含恶意代码或脚本，因此需要对输入数据进行正确的验证和过滤。如果没有进行正确的输入验证，可能会导致安全漏洞。例如：



```javascript
<input type="text" name="username">
```



上述代码中，如果没有对用户输入的用户名进行验证和过滤，可能会导致SQL注入攻击或跨站脚本攻击等安全漏洞。 总之，在编写代码时，需要注意安全性问题，并进行相应的处理和优化，以避免出现安全漏洞。



## 代码习惯


+ **重点代码是否写注释** 
    - 对于不直接的代码，注释不是要解释这段代码做了什么，而是说明该代码片段为什么有这么写。
    - 描述代码功能和用途：注释应该清楚地描述代码的功能和用途。这些注释应该简短明了，不要过度描述代码的细节。例如，“这段代码用于控制网页上的菜单栏”。
    - 描述HTML和CSS结构：如果代码涉及HTML和CSS结构，注释应该描述这些结构的组成和布局。这些注释应该包括标签的用途、样式的作用和层级关系等方面的内容。例如，“这个div包含了一个标题和三个按钮，用于控制页面的显示”。
    - 描述JavaScript逻辑：如果代码涉及JavaScript逻辑，注释应该描述这些逻辑的实现和原理。这些注释应该包括变量的用途、函数的作用和调用方式等方面的内容。例如，“这个函数用于验证用户输入的数据是否合法，并在页面上显示相应的提示信息”。
    - 解释框架和库的使用：如果代码使用了特定的框架或库，注释应该描述这些框架或库的使用方法和原理。这些注释应该包括框架或库的版本、引入方式和功能等方面的内容。例如，“这个页面使用了jQuery库来实现DOM操作和事件绑定”。
    - 提供上下文信息：注释应该提供代码的上下文信息，以便读者了解代码的作用和使用方式。这些注释应该包括代码的位置、依赖关系、调用方式、用途等方面的内容。例如，“这个模块包含了所有网页的通用样式和脚本”。 总之，在web前端中给代码写注释时需要注意清晰、简洁、准确、详细。注释应该包括代码的功能和用途、HTML和CSS结构、JavaScript逻辑、框架和库的使用、以及提供上下文信息等方面的内容，以帮助其他开发人员更好地理解和维护代码。
+ **命名是否规范** 
    - 首先要注意的是规范，大小写问题。其次注意命名是否符合业务。
    - 参考文献： [https://juejin.cn/post/7083141569804501023](https://juejin.cn/post/7083141569804501023)
    - 讲写代码的书通常都会从命名开始讲，《程序设计实践》如此，《代码整洁之道》亦然。所以，我们这个讲代码坏味道的专栏，也遵循传统，从命名开始讲。
    - 不过，也许你会说：“我知道，命名不就是不能用 abcxyz 命名，名字要有意义嘛，这有什么好讲的。”然而，即便懂得了名字要有意义这个道理，很多程序员依然无法从命名的泥潭中挣脱出来。
    - 不精准的命名 
        * 我们先来看一段代码：



```javascript
public void processChapter(long chapterId) {

  Chapter chapter = this.repository.findByChapterId(chapterId);

  if (chapter == null) {

    throw new IllegalArgumentException("Unknown chapter [" + chapterId + "]");  

  }

  chapter.setTranslationState(TranslationState.TRANSLATING);

  this.repository.save(chapter);

}
```



```plain
    - 这是一段看上去还挺正常的代码，甚至以很多团队的标准来看，这段代码写得还不错。但如果我问你，这段代码是做什么的。你就需要调动全部注意力，去认真阅读这段代码，找出其中的逻辑。经过阅读我们发现，这段代码做的就是把一个章节的翻译状态改成翻译中。
    - 问题来了，为什么你需要阅读这段代码的细节，才能知道这段代码是做什么的？
    - 问题就出在函数名上。这个函数的名字叫 processChapter（处理章节），这个函数确实是在处理章节，但是，这个名字太过宽泛。如果说“将章节的翻译状态改成翻译中”叫做处理章节，那么“将章节的翻译状态改成翻译完”是不是也叫处理章节呢？“修改章节内容”是不是也叫处理章节呢？换句话说，如果各种场景都能够叫处理章节，那么处理章节就是一个过于宽泛的名字，没有错，但不精准。
    - 这就是一类典型的命名问题，从表面上看，这个名字是有含义的，但实际上，它并不能有效地反映这段代码的含义。如果说我在做的是一个信息处理系统，你根本无法判断，我做是一个电商平台，还是一个图书管理系统，从沟通的角度看，这就不是一个有效的沟通。要想理解它，你需要消耗大量认知成本，无论是时间，还是精力。
    - **命名过于宽泛，不能精准描述，这是很多代码在命名上存在的严重问题，也是代码难以理解的根源所在**。
    - 或许这么说你的印象还是不深刻，我们看看下面这些词是不是经常出现在你的代码里：data、info、flag、process、handle、build、maintain、manage、modify 等等。这些名字都属于典型的过于宽泛的名字，当这些名字出现在你的代码里，多半是写代码的人当时没有想好用什么名字，就开始写代码了。我相信，只要稍微仔细想想，类似的名字你一定还能想出不少来。
    - 回到前面那段代码上，如果它不叫“处理章节”，那应该叫什么呢？首先，命名要能够描述出这段代码在做的事情。这段代码在做的事情就是“将章节修改为翻译中”。那是不是它就应该叫 changeChapterToTranslating 呢？
    - 不可否认，相比于“处理章节”，changeChapterToTranslating 这个名字已经进了一步，然而，它也不算是一个好名字，因为它更多的是在描述这段代码在做的细节。我们之所以要将一段代码封装起来，一个重要的原因就是，我们不想知道那么多的细节。如果把细节平铺开来，那本质上和直接阅读代码细节差别并不大。
    - 所以，**一个好的名字应该描述意图，而非细节。**  
    - 就这段代码而言， 我们为什么要把翻译状态修改成翻译中，这一定是有原因的，也就是意图。具体到这里的业务，我们把翻译状态修改成翻译中，是因为我们在这里开启了一个翻译的过程。所以，这段函数应该命名 startTranslation。
```



```javascript
public void startTranslation(long chapterId) {

  Chapter chapter = this.repository.findByChapterId(chapterId);

  if (chapter == null) {

    throw new IllegalArgumentException("Unknown chapter [" + chapterId + "]"); 

  }

  chapter.setTranslationState(TranslationState.TRANSLATING);

  this.repository.save(chapter);

}
```



```plain
- 用技术术语命名
    - 我们再来看一段代码：
```



```javascript
List<Book> bookList = service.getBooks();
```



```plain
    - 可以说这是一段常见得不能再常见的代码了，但这段代码却隐藏另外一个典型得不能再典型的问题：用技术术语命名。
    - 这个 bookList 变量之所以叫 bookList，原因就是它声明的类型是 List。这种命名在代码中几乎是随处可见的，比如 xxxMap、xxxSet。
    - 这是一种不费脑子的命名方式，但是，这种命名却会带来很多问题，因为它是一种基于实现细节的命名方式。
    - 我们都知道，编程有一个重要的原则是面向接口编程，这个原则从另外一个角度理解，就是不要面向实现编程，**因为接口是稳定的，而实现是易变的**。虽然在大多数人的理解里，这个原则是针对类型的，但在命名上，我们也应该遵循同样的原则。为什么？我举个例子你就知道了。
    - 比如，如果我发现，我现在需要的是一个不重复的作品集合，也就是说，我需要把这个变量的类型从 List 改成 Set。变量类型你一定会改，但变量名你会改吗？这还真不一定，一旦出现遗忘，就会出现一个奇特的现象，一个叫 bookList 的变量，它的类型是一个 Set。这样，一个新的混淆就此产生了。
    - 那有什么更好的名字吗？我们需要一个更面向意图的名字。其实，我们在这段代码里真正要表达的是拿到了一堆书，所以，这个名字可以命名成 books。
```



```javascript
List<Book> books = service.getBooks();
```



```plain
    - 也许你发现了，这个名字其实更简单，但从表意的程度上来说，它却是一个更有效的名字。
    - 虽然这里我们只是以变量为例说明了以技术术语命名存在的问题，**事实上，在实际的代码中，技术名词的出现，往往就代表着它缺少了一个应有的模型。**  
    - 比如，在业务代码里如果直接出现了 Redis：
```



```javascript
public Book getByIsbn(String isbn) {

  Book cachedBook = redisBookStore.get(isbn);

  if (cachedBook != null) {

    return cachedBook;

  }

  Book book = doGetByIsbn(isbn);

  redisBookStore.put(isbn, book);

  return book;

}
```



```plain
    - 通常来说，这里真正需要的是一个缓存。Redis 是缓存这个模型的一个实现：
```



```javascript
public Book getByIsbn(String isbn) {

  Book cachedBook = cache.get(isbn);

  if (cachedBook != null) {

    return cachedBook;

  }

  Book book = doGetByIsbn(isbn);

  cache.put(isbn, book);

  return book;

}
```



```plain
    - 再进一步，缓存这个概念其实也是一个技术术语，从某种意义上说，它也不应该出现在业务代码中。这方面做得比较好的是 Spring。使用 Spring 框架时，如果需要缓存，我们通常是加上一个 Annotation（注解）：
```



```javascript
@Cacheable("books")

public Book getByIsbn(String isbn) {

  ...

}
```



```plain
    - 程序员之所以喜欢用技术名词去命名，一方面是因为，这是大家习惯的语言，另一方面也是因为程序员学习写代码，很大程度上是参考别人的代码，而行业里面优秀的代码常常是一些开源项目，而这些开源项目往往是技术类的项目。**在一个技术类的项目中，这些技术术语其实就是它的业务语言。但对于业务项目，这个说法就必须重新审视了。**
- 用业务语言写代码
    - 无论是不精准的命名也好，技术名词也罢，归根结底，体现的是同一个问题：对业务理解不到位。
    - 我在《10x 程序员工作法》专栏中曾经说过，**编写可维护的代码要使用业务语言**。怎么才知道自己的命名是否用的是业务语言呢？一种简单的做法就是，把这个词讲给产品经理，看他知不知道是怎么回事。
    - 从团队的角度看，让每个人根据自己的理解来命名，确实就有可能出现千奇百怪的名字，所以，一个良好的团队实践是，**建立团队的词汇表**，让团队成员有信息可以参考。
    - 团队对于业务有了共同理解，我们也许就可以发现一些更高级的坏味道，比如说下面这个函数声明：
```



```javascript
public void approveChapter(long chapterId, long userId) {
  ...
}
```



```plain
    - 这个函数的意图是，确认章节内容审核通过。这里有一个问题，chapterId 是审核章节的 ID，这个没问题，但 userId 是什么呢？了解了一下背景，我们才知道，之所以这里要有一个 userId，是因为这里需要记录一下审核人的信息，这个 userId 就是审核人的 userId。
    - 你看，通过业务的分析，我们会发现，这个 userId 并不是一个好的命名，因为它还需要更多的解释，更好的命名是 reviewerUserId，之所以起这个名字，因为这个用户在这个场景下扮演的角色是审核人（Reviewer）。
```



```javascript
public void approveChapter(long chapterId, long reviewerUserId) {

  ...

}
```



```plain
    - 从某种意义上来说，这个坏味道也是一种不精准的命名，但它不是那种一眼可见的坏味道，**而是需要在业务层面上再进行讨论**，所以，它是一种更高级的坏味道。
    - 我初入职场的时候，有一次为一个名字陷入了沉思，一个工作经验丰富的同事对此的评价是：你开始进阶了。确实，能够意识到自己的命名有问题，是程序员进阶的第一步。
- 总结
    - 我们今天讲了两个典型的命名坏味道：
        - 不精准的命名；
        - 用技术术语命名。
    - 命名是软件开发中两件难事之一（另一个难事是缓存失效），不好的命名本质上是增加我们的认知成本，同样也增加了后来人（包括我们自己）维护代码的成本。
    - 好的命名要体现出这段代码在做的事情，而无需展开代码了解其中的细节，这是最低的要求。再进一步，好的命名要准确地体现意图，而不是实现细节。更高的要求是，用业务语言写代码。
    - 至此，我们已经对命名有了一个更深入的认识。下一讲，我们来说说国外那些经典的讲编码的书都不曾覆盖到的一个话题：英文命名。
    - 如果今天的内容你只能记住一件事，那请记住：好的命名，是体现业务含义的命名。
```



+ **函数 / 组件 是否处理过多逻辑** 
    - 对于Vue函数或组件是否处理过多逻辑，这是一个需要根据具体情况来判断的问题，不能一概而论。但是在开发过程中，我们应该尽可能遵循单一职责原则，让函数或组件的职责尽量单一，而不是处理过多的逻辑。  
如果一个函数或组件处理过多的逻辑，会导致代码难以维护和扩展。此时我们可以考虑将这些逻辑分离出来，封装成独立的函数或组件，以提高代码可读性、可维护性和可扩展性。  
另外，在处理逻辑时，我们还需要注意代码的可复用性。如果某个逻辑在多个地方都需要用到，我们应该将其封装成一个可复用的函数或组件，以避免代码重复。  
总之，对于Vue函数或组件是否处理过多逻辑，我们应该根据具体情况进行判断和处理，尽可能遵循单一职责原则，保持代码的可读性、可维护性和可扩展性。 
        * 下面举一个例子，假设我们有一个Vue组件，需要从后端获取数据并渲染到页面上：



```javascript
<template>
  <div>
    <h2>{{ title }}</h2>
    <ul>
      <li v-for="(item, index) in items" :key="index">{{ item }}</li>
    </ul>
  </div>
</template>
<script>
export default {
  data() {
    return {
      title: '',
      items: []
    }
  },
  created() {
    // 从后端获取数据
    fetch('/api/data')
      .then(response => response.json())
      .then(data => {
        // 处理数据
        this.title = data.title
        this.items = data.items
      })
  }
}
</script>
```



```plain
        上述代码虽然实现了从后端获取数据并渲染到页面上，但是将所有的逻辑都写在一个组件中，可读性和可维护性都比较差。因此，我们可以将这个组件拆分成多个子组件，例如：
```



```javascript
<template>
  <div>
    <data-fetcher @data-loaded="handleDataLoaded" />
    <data-processor :data="data" @data-processed="handleDataProcessed" />
    <data-renderer :title="title" :items="items" />
  </div>
</template>
<script>
import DataFetcher from './DataFetcher.vue'
import DataProcessor from './DataProcessor.vue'
import DataRenderer from './DataRenderer.vue'
export default {
  components: {
    DataFetcher,
    DataProcessor,
    DataRenderer
  },
  data() {
    return {
      data: null,
      title: '',
      items: []
    }
  },
  methods: {
    handleDataLoaded(data) {
      this.data = data
    },
    handleDataProcessed({ title, items }) {
      this.title = title
      this.items = items
    }
  }
}
</script>
```



```plain
        这里我们将原来的组件拆分成了三个子组件：`DataFetcher`组件负责从后端获取数据并将数据传递给`DataProcessor`组件；`DataProcessor`组件负责对数据进行处理，并将处理后的数据传递给`DataRenderer`组件；`DataRenderer`组件负责渲染处理后的数据。每个子组件只负责处理其中一部分逻辑，代码更加清晰、易于维护和扩展。同时，这些子组件也可以在其他地方复用，提高了代码的可复用性。
```



+  **if-else 嵌套 | 回调是否嵌套过深**  
如果if-else语句或回调嵌套过深，会导致代码难以理解和维护。因此，我们应该尽可能避免嵌套过深的if-else语句和回调。  
对于if-else语句，我们可以使用早返回或者条件语句简化代码。例如，我们可以将以下代码： 



```javascript
if (condition1) {
  if (condition2) {
    // do something
  } else {
    // do something else
  }
} else {
  // do something else
}
```



```plain
简化为：
```



```javascript
if (condition1 && condition2) {
  // do something
} else {
  // do something else
}
```



```plain
这样可以避免if-else语句嵌套过深，提高代码的可读性和可维护性。
```



对于回调，我们可以使用Promise或async/await来避免回调嵌套过深。例如，以下是使用Promise重构的代码：



```javascript
function fetchData() {
  return fetch('/api/data')
    .then(response => response.json())
    .then(data => {
      // do something with data
      return processedData
    })
}
fetchData().then(processedData => {
  // do something with processedData
}).catch(error => {
  // handle error
})
```



```plain
这样就避免了回调嵌套过深，提高了代码的可读性和可维护性。使用async/await也可以实现类似的效果：
```



```javascript
async function fetchData() {
  const response = await fetch('/api/data')
  const data = await response.json()
  // do something with data
  return processedData
}
try {
  const processedData = await fetchData()
  // do something with processedData
} catch (error) {
  // handle error
}
```



```plain
总之，避免if-else语句和回调嵌套过深可以提高代码的可读性和可维护性，使代码更加易于理解和扩展。
```



+ **接口类型是否不清**



```javascript
function fetchData(id) {
  return fetch(`/api/data/${id}`).then(response => response.json())
}
```



```plain
在这个例子中，接口的参数类型和返回值类型都不明确。函数名为fetchData，但是不清楚要获取什么数据，参数id也没有指明其类型和含义。返回值类型为一个JSON对象，但是没有说明JSON对象的属性类型和含义。

为了使接口类型更清晰，我们可以进行如下改进：
```



```javascript
function fetchUserData(userId) {
  return fetch(`/api/users/${userId}`).then(response => response.json())
}
// 使用示例
fetchUserData(123).then(userData => {
  // 处理用户数据
}).catch(error => {
  // 处理错误
})
```



```plain
在这个改进后的代码中，我们将函数名改为fetchUserData，并明确了参数类型为userId，表示要获取的用户ID。返回值类型为一个JSON对象，其中包含了用户数据，每个属性都有相应的类型和含义。这样可以使代码更加清晰和易于理解。同时，我们也提供了使用示例和错误处理，使代码更加健壮和可维护。
```



## 代码优化


### **是否有大量 dom 节点操作**


+ 以下是一个大量DOM节点操作的代码示例：



```javascript
function updateList() {
  const list = document.getElementById('list')
  const items = list.getElementsByTagName('li')
  for (let i = 0; i < items.length; i++) {
    items[i].innerText = 'Item ' + (i + 1)
  }
}
```



```plain
在这个例子中，我们使用了getElementById和getElementsByTagName方法，分别获取了列表元素和其中的所有li元素。然后，我们使用for循环遍历每个li元素，将其innerText设置为'Item ' + (i + 1)。由于这个操作是在每次列表更新时执行的，可能会导致性能问题和代码难以维护。

为了避免大量的DOM节点操作，我们可以进行如下改进：
```



```javascript
function updateList() {
  const list = document.getElementById('list')
  const items = list.children
  const text = []
  for (let i = 0; i < items.length; i++) {
    text.push('Item ' + (i + 1))
  }
  list.textContent = text.join('\n')
}
```



```plain
在这个改进后的代码中，我们使用children属性代替getElementsByTagName方法，获取了列表中的所有li元素。然后，我们使用一个数组text，将每个li元素的文本内容存储起来。最后，我们将整个列表的textContent设置为text数组的内容，使用join方法将其连接成一个字符串。这样可以避免大量的DOM节点操作，提高代码性能和可维护性。
```



+  **是否频繁触发事件**  
如果代码中频繁触发事件，会导致性能问题和代码难以维护。因此，在编写代码时，应该尽量避免频繁触发事件。 频繁触发事件可能会导致以下问题： 
    1. 性能问题：如果某个事件被频繁触发，可能会导致页面卡顿或者响应变慢。这会影响用户体验，使用户感觉网站速度很慢。
    2. 代码难以维护：如果代码中有大量的事件处理程序，会导致代码变得复杂和难以维护。这会使代码难以理解，增加调试和维护的成本。 为了避免频繁触发事件，我们可以采用以下方法：
    3. 防抖：防抖是指在一定时间内，如果事件被连续触发多次，则只执行最后一次触发的事件。这样可以避免事件的频繁触发，提高代码的性能和可维护性。
    4. 节流：节流是指在一定时间内，如果事件被连续触发多次，则只执行一次事件。这样可以避免事件的频繁触发，提高代码的性能和可维护性。 以下是一个频繁触发事件的示例代码：



```javascript
document.getElementById('button').addEventListener('click', () => {
  // 执行一些操作
})
```



```plain
    在这个例子中，我们给按钮添加了一个点击事件处理程序。如果用户频繁点击按钮，可能会导致事件被频繁触发，从而影响页面性能和用户体验。

    为了避免频繁触发事件，我们可以进行如下改进：
```



```javascript
// 使用防抖
function debounce(fn, delay) {
  let timer = null
  return function() {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, arguments)
    }, delay)
  }
}
document.getElementById('button').addEventListener('click', debounce(() => {
  // 执行一些操作
}, 1000))
```



```plain
    在这个改进后的代码中，我们使用了防抖技术，将事件处理程序包装在一个防抖函数中。当用户点击按钮时，防抖函数会等待一定时间，如果在这个时间内没有再次触发事件，才会执行事件处理程序。这样可以避免事件的频繁触发，提高代码的性能和可维护性。
```



+ **动画是否启用加速** 
    -  为什么  
动画启用加速可以提高动画的流畅度和体验，但也需要注意性能问题和兼容性问题。以下是一个使用CSS动画启用加速的代码示例： 



```javascript
// CSS代码
.animation {
  width: 100px;
  height: 100px;
  background-color: #f00;
  transition: transform 1s ease-in-out;
}
// JavaScript代码
document.getElementById('button').addEventListener('click', () => {
  const element = document.getElementById('animation')
  element.style.transform = 'translateX(100px)'
})
```



```plain
    在这个例子中，我们使用CSS动画的transition属性和JavaScript代码来实现动画效果。当用户点击按钮时，我们使用JavaScript代码将元素的transform属性设置为translateX(100px)，从而实现元素的平移动画。由于我们在CSS中使用了transition属性，并设置了ease-in-out的动画曲线，因此动画启用了加速效果，可以提高动画的流畅度和体验。

    需要注意的是，动画启用加速可能会导致性能问题和兼容性问题。如果动画过于复杂或者元素需要频繁地进行动画变换，可能会导致页面卡顿或者响应变慢。此外，不同的浏览器可能会对动画效果的加速方式有所不同，需要进行兼容性测试和处理。因此，在编写动画代码时，需要综合考虑性能、体验和兼容性等问题。
- 开启动画加速的方法有哪些?

    方法一：使用CSS transition属性
```



CSS transition属性可以让元素在状态改变时平滑过渡，从而形成动画效果。通过设置transition-timing-function属性，可以指定动画曲线，从而实现动画加速效果。  
以下是一个使用CSS transition属性开启动画加速的示例代码：  
CSS代码：



```css
.box {
  width: 100px;
  height: 100px;
  background-color: red;
  transition: all 1s ease-in-out;
}
```



```plain
    方法二：使用JavaScript requestAnimationFrame方法

    requestAnimationFrame方法是一种优化的动画效果的方法，它可以让动画效果更加流畅和自然。由于requestAnimationFrame方法会利用浏览器的刷新机制来实现动画效果，因此可以避免一些性能问题和兼容性问题。
```



```javascript
const box = document.querySelector('.box');
let position = 0;
function animate() {
  position += 1;
  box.style.transform = `translateX(${position}px)`;
  requestAnimationFrame(animate);
}
animate();
```



```plain
    在这个示例代码中，我们使用JavaScript代码实现了一个动画函数animate，该函数会不断地改变元素的transform属性，从而实现元素的平移动画。在每次动画更新时，我们通过requestAnimationFrame方法告诉浏览器需要执行下一次动画更新，从而实现动画加速效果。
```



### **组件是否重复渲染**


在Vue中，组件的重复渲染也是通过比较前后两个虚拟DOM树的差异来确定需要更新的部分，从而实现高效的渲染。如果组件的props或state没有发生变化，Vue也会避免重复渲染组件，从而提高性能。



下面是一个实际的代码例子，演示了Vue组件是否会重复渲染的情况：



```javascript
<template>
  <div>
    <button @click="handleClick">Click me</button>
    <Counter :count="count" />
  </div>
</template>
<script>
import Counter from './Counter.vue';
export default {
  components: {
    Counter
  },
  data() {
    return {
      count: 0
    }
  },
  methods: {
    handleClick() {
      this.count++;
    }
  }
}
</script>
```



在这个例子中，我们定义了一个Counter组件和一个App组件。Counter组件用于显示计数器的值，而App组件包含了一个按钮，点击按钮可以增加计数器的值。当计数器的值发生变化时，Counter组件需要重新渲染，从而显示新的计数器值。



我们可以通过在Counter组件中添加一个mounted钩子函数来记录组件被渲染的次数。当我们运行应用程序并点击按钮时，可以看到控制台输出了多次组件渲染的记录。这是因为每次计数器的值发生变化时，Vue都需要重新渲染Counter组件。



然而，如果我们在Counter组件中添加一个shouldComponentUpdate方法，该方法可以告诉Vue是否需要重新渲染组件。如果shouldComponentUpdate方法返回false，则Vue会避免重复渲染组件，从而提高性能。以下是一个示例代码：



```javascript
<template>
  <div>
    <button @click="handleClick">Click me</button>
    <Counter :count="count" />
  </div>
</template>
<script>
import Counter from './Counter.vue';
export default {
  components: {
    Counter
  },
  data() {
    return {
      count: 0
    }
  },
  methods: {
    handleClick() {
      this.count++;
    }
  }
}
</script>
```



在这个示例代码中，我们将Counter组件改为类组件，并添加了一个shouldComponentUpdate方法。该方法比较了当前props和下一个props的值，如果两者相等，则返回false，告诉Vue不需要重新渲染组件。这样，当我们点击按钮时，可以看到控制台输出了更少的组件渲染记录，因为Vue已经避免了重复渲染组件。需要注意的是，Vue中的shouldComponentUpdate方法被称为shouldUpdate，使用方式和React中类似，但是需要在组件实例中定义该方法而不是在组件的原型上定义。



### **是否考虑复用性**


Vu的复用性，可以通过组件的props和slots来实现。



props是用于从父组件向子组件传递数据的方式，而slots则是用于从父组件向子组件传递内容的方式。通过合理地使用props和slots，可以使组件更加通用和灵活，从而提高组件的复用性。



以下是一个示例代码，演示了如何使用props和slots来实现组件的复用性：



```vue
<template>
  <div>
    <MyButton :text="buttonText" @click="handleClick" />
    <MyMessage :title="messageTitle">
      <p>{{ messageText }}</p>
    </MyMessage>
  </div>
</template>
<script>
import MyButton from './MyButton.vue';
import MyMessage from './MyMessage.vue';
export default {
  components: {
    MyButton,
    MyMessage
  },
  data() {
    return {
      buttonText: 'Click me',
      messageTitle: 'Hello world!',
      messageText: 'This is a message.'
    }
  },
  methods: {
    handleClick() {
      this.messageText = 'You clicked the button!';
    }
  }
}
</script>
```



在这个示例代码中，我们定义了一个App组件，它包含了一个MyButton组件和一个MyMessage组件。MyButton组件用于显示按钮，而MyMessage组件用于显示一条消息。我们使用props向MyButton组件传递了按钮的文本，使用@click绑定了按钮的点击事件，并使用slots向MyMessage组件传递了消息的内容。这样，我们可以在不同的父组件中复用MyButton和MyMessage组件，并根据需要传递不同的props和slots，从而实现组件的复用性。



但是出现下面这些代码的时候，你查看的时候就小心了：



```vue
<template>
  <div>
    <h1>{{ title }}</h1>
    <div v-if="showMessageOne">
      <h2>Message one:</h2>
      <p>{{ messageOne }}</p>
    </div>
    <div v-if="showMessageTwo">
      <h2>Message two:</h2>
      <p>{{ messageTwo }}</p>
    </div>
    <div v-if="showMessageThree">
      <h2>Message three:</h2>
      <p>{{ messageThree }}</p>
    </div>
    <button @click="toggleMessageOne">Toggle message one</button>
    <button @click="toggleMessageTwo">Toggle message two</button>
    <button @click="toggleMessageThree">Toggle message three</button>
  </div>
</template>
<script>
export default {
  data() {
    return {
      title: 'Messages',
      showMessageOne: false,
      showMessageTwo: false,
      showMessageThree: false,
      messageOne: 'This is message one.',
      messageTwo: 'This is message two.',
      messageThree: 'This is message three.'
    }
  },
  methods: {
    toggleMessageOne() {
      this.showMessageOne = !this.showMessageOne;
    },
    toggleMessageTwo() {
      this.showMessageTwo = !this.showMessageTwo;
    },
    toggleMessageThree() {
      this.showMessageThree = !this.showMessageThree;
    }
  }
}
</script>
```



在这个代码片段中，我们定义了一个Messages组件，它包含了三个消息和三个按钮，每个按钮用于切换一个消息的可见性。这种实现方式使得组件的代码变得冗余且难以维护，因为每个按钮和消息都需要单独管理。如果我们需要在不同的父组件中使用该组件，我们需要复制整个组件的代码并针对每个副本进行修改，这会导致代码重复和维护困难。



相反，如果我们将每个消息和按钮抽象为一个独立的组件，并使用props和slots来传递数据和内容，我们可以更好地实现组件的复用性和可维护性。

]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[TS入门教程学习总结]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/TS入门教程学习总结</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/TS入门教程学习总结</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[TS 入门 ts 可以解决Top 10 JavaScript errors from 1000+ projects (and how to avoid them) 这样的问题。再加上对象提示 🔔  一、 TS 基础 typescript // 1.对象和函数 interface interface IPerson {   readonly name: string;   age: number;   callback: { (name: string): string }; } const obj: IPerson = {   name: "yoran",   age: 2,   callb...]]></description>
            <content:encoded><![CDATA[# TS 入门

ts 可以解决[Top 10 JavaScript errors from 1000+ projects (and how to avoid them)](https://rollbar.com/blog/top-10-javascript-errors-from-1000-projects-and-how-to-avoid-them/) 这样的问题。再加上对象提示 🔔

## 一、 TS 基础

```typescript
// 1.对象和函数 interface
interface IPerson {
  readonly name: string;
  age: number;
  callback: { (name: string): string };
}

const obj: IPerson = {
  name: "yoran",
  age: 2,
  callback: function (name: string): string {
    return name;
  },
};
// obj.name = "ma";

// 2.枚举
enum Transpiler {
  Babel = "Babel",
  Postcss = "Postcss",
  Terser = "Terser",
  Prettier = "Prettier",
}

const curVersion = "Babel";
console.log(curVersion === Transpiler.Babel);
const transpiler1: Transpiler = Transpiler.Babel;

// 3.extends
type isTow<T> = T extends 2 ? string : number;

type TString = isTow<2>;
type TNumber = isTow<1>;

// const a: TString = 22;

// 4.数组类型
const array: unknown[] = [1, ""];
console.log(array);

// 5.联合类型
// 下面的 | 变更为 & 之后，错误提示就是不可达.
// 因为这个不可能，没有什么变量能够既是字符串还是数字的
const array1: (string | number)[] = [1, 2, ""];

// 6.映射类型，这个是我一直搞不明白的东西
type student = {
  name: "yoran";
  age: 29;
  sex: "boy";
};

type ReadonlyTest<T> = {
  readonly [Key in keyof T]: T[Key];
};

type TStudent = ReadonlyTest<student>;

// 限制传进来的变量是这个几个对象
// 这个的用法困住了我好久好久，我就是一个傻逼
const stateType = {
  start: "开始",
  continue: "继续",
  stop: "停止",
};

enum EStateType {
  start = "开始",
  continue = "继续",
  stop = "停止",
}

function getStateType(type: EStateType): EStateType {
  return type;
}

console.log(getStateType(EStateType.start));

// 7.函数 , return显示undefined的话，使用undefined,否则是void
type TFnPerson = (name: string) => void;

const getPerson: TFnPerson = (name) => {
  console.error(name);
};

const getPersonUndefined = (name: string): undefined => {
  return;
};

// 8. any和unknown的关系
// any 和 unknown都是万能类型，但是前者放弃了类型检查
function fnAny(params: any) {
  console.log(params.name);
}
function fnUnknown(params: unknown) {
  console.log((params as { name: string }).name);
}
// 这个才是unknown的正确用法，绝大多数可以使用unknown来代替any
function fnUnknownArray(params: unknown) {
  (params as unknown[]).forEach((element) => {
    element = (element as number) + 1;
  });
}
// 反直觉现象
interface IUser {
  name1: string;
  job?: IJob;
}
interface IJob {
  title: string;
}
const user: IUser = {
  name1: "foo",
  job: {
    title: "bar",
  },
};
const { name1, job = {} as IJob } = user;
console.log(job.title);

/**
 * 9. 联合类型
 */
interface IPerson1 {
  name: string | number;
}
type IPerson2 = {
  name: string | number;
};

type IPerson3 = string | number;
let person3: IPerson3 = 2;
person3 = "3";
console.log(person3);

enum status_map {
  success = "success",
  failure = "failure ",
}
enum skill_map {
  computed = "computed",
  sport = "sport",
}
// type Status = 'success' | "failure";
// 如果都是一个map的话，这样子没有必要，如果是联合其他类型的话，还是有点作用的
type Status = status_map.success | "failure" | skill_map;
const status1: Status = status_map.success;
console.log(status1);
const status2: status_map = status_map.failure;
const status3: Status = skill_map.sport;
console.log(status3);

/**
 * 10. 字面量类型
 */
interface ILiteral {
  name: "yoran";
}
const literalObject: { name: "yoran" } = { name: "yoran" };
const literal1: ILiteral = { name: "yoran" };
// 上面这两种类型没有区别

type aa = {
  name: "sdf";
};
type bb = {
  age: number;
};

type aabb = aa | bb;

const aabb1: aabb = {
  name: "sdf",
};

/**
 * 11. 范型
 */
type TStatus<T, D> = "success" | "failure" | "pending" | T | D;

// 等价于 type TStatus = "success" | "failure" | "pending" | "start" | "end"
const status4: TStatus<"start", "end"> = "pending";

interface IStatus<T> {
  data: T;
  code: 200;
}
const status5: IStatus<number> = {
  data: 222,
  code: 200,
};

/**
 * 12. 工具类
 */
type User = {
  name: string;
  age: number;
  email: string;
};

type PartialUser = Partial<User>;

const user1: PartialUser = {
  name: "John Doe",
  age: 30,
  // email: "john.doe@example.com",
};

type TUser = {
  name: string;
  age: number;
  email: string;
  phone: string;
};

// 只提取其中的 name 与 age 信息
type UserBasicInfo = Pick<User, "name" | "age">;

const user2: UserBasicInfo = {
  name: "yoran",
  age: 18,
};

/**
 * 13. 模版字符串类型
 */
type Version = `${number}.${number}.${number}`;
const v1: Version = "1.2.0";

type SayHello<T extends string | number> = `Hello ${T}`;

type Greet1 = SayHello<"linbudu">; // "Hello linbudu"
type Greet2 = SayHello<599>; // "Hello 599"

const meName = "yoran";
type TMeName = typeof meName;
const meName1: TMeName = "yoran";
```

TS 解决的问题:[https://rollbar.com/blog/top-10-javascript-errors-from-1000-projects-and-how-to-avoid-them/](https://rollbar.com/blog/top-10-javascript-errors-from-1000-projects-and-how-to-avoid-them/)

## 二、 TS 相关疑问

- type 和 interface 的区别？

:::tips

1. type 可以指定基础类型，并且给基础类型编程，比如 type TPerson = string | number | boolean。
2. 在定义对象类型时，两者并没有什么不同。type 可以用来定义所有类型，interface 只能用来定义对象类型,type 和 interface 在使用场景上二者应该是包含与被包含的关系。

:::

- 字面量类型

:::tips

1. 更加细致的限制开发输入的类型

:::

- 范型是什么

:::tips

1. 类型编程中的参数。`type TPerson<T, D> = T | D | 'yoran' | '柳生'`

:::

- 范型的难点？

  - 主动赋值
  - 自动推导

- <font style="color:rgb(37, 41, 51);">类型声明的概念</font>

:::tips

1. 专门指 `xxxx.d.ts`这样的文件

:::

### 团队使用 TS 是否会增加人力成本？

## 三、 JS 迁移 TS

- 不要对逻辑进行重构，最多写一个 TODO。即便你看这一部分再不顺眼也是这样。
- <font style="color:rgb(37, 41, 51);">更加不要发生技术栈的替换，只做类型包的补充。</font>

> <font style="color:rgb(37, 41, 51);">在迁移过程中的一个大忌就是，你明明只应该补充下类型，却觉得原来的逻辑不顺眼直接顺手改掉了，或者感觉使用的 npm 包太老，顺手替换了个更潮流的包。千万不要这么做！否则如果迁移过程中哪里出现了问题，为了定位问题根源，大概率你又要将它们回退回去，甚至包括一些无辜的类型代码...，简直就是在给你自己增加工作量了。</font>

## 四、 TypeScript 是如何运作的？

为什么说 TS 是一个单独的语言？又为什么说 TS 可以最大限度的兼容 JS？

在深入学习之前，我有一个认知，TS 只是 JS 的一个辅助工具一样的东西，它依托于 webpack 之类的构建工具工作。这样的认知是错误的。TS 就是一个单独的语言，但是它为了能够最大限度地降低用户的使用门槛，在 JS 语言规范的基础上，扩展出了类型检查。这也是说 TS 是 JS 超集的由来。

![](https://cdn.nlark.com/yuque/0/2024/png/654315/1707976483587-c71a7066-83ef-4199-9fe1-c7708a74403a.png)

所以说，这就给了，那些不想要改老的项目也可以使用类型检查的条件，毕竟即便改成使用 TS 来写 JS，它也是回转化成 JS 和.d.ts 的文件。比如下面的 lodash 的依赖包。

![](https://cdn.nlark.com/yuque/0/2024/png/654315/1707976789675-abe84f57-2425-4147-8f46-8718338934b4.png)

但是在安装了，`@type/loadsh`之后，就不会报错了。

```bash
npm i @types/lodash
```

我可以去看一下 `node_module`中的 `@type`文件夹如下所示：

![](https://cdn.nlark.com/yuque/0/2024/png/654315/1707976915158-e5aebc7a-438c-41fc-87b1-6a72477e440e.png)

全部都是使用 `xxx.d.ts`的组成。有了这些文件，我们就可以消除 <font style="background-color:#FBDE28;">无法找到模块的相关报错。</font>

如果一开始就是使用 TS 写的项目，也只不过是把 `xx.d.ts`放到了依赖包之中。

## 五、类型断言如何正确的使用

### 5.1 为将来补全类型做好准备

unknown 和类型断言结合使用

```typescript
function myFunc(param: unknown) {
  (param as number[]).forEach((element) => {
    element = element + 1;
  });
}

function myFunc(param: unknown) {
  (param as unknown[]).forEach((element) => {
    element = (element as number) + 1;
  });
}
```

这样做的目的是什么呢？提醒开发，你使用的这个变量还是不知道的类型，要小心为好哦。

- 类型断言的意义存在
- unkown 结合类型断言可以强制开发明确它的类型，一步步的完善它最终的类型

而 any 结合类型断言也是可以到达同样的目的。但是他们还是有一个很大的差别的，如下

```typescript
let a: any = {};
console.log(a.b.foo()); // 不会报错

let b: unknow = {};
console.log(b.a.foo()); //  会找错，提示a为unknow
```

**any 在使用的时候不会报错，容易被忽略**

### 5.2 弥补 TS 的错误

```typescript
interface IName {
  boo: string;
}
interface IHuman {
  base: IName;
  height: number;
}

const yoran: IHuman = {
  height: 12,
  base: {
    boo: "吃饭咩",
  },
};
const { height, base = {} } = yoran;
console.log(height);
console.log(base.boo); // 类型"{}"上面不存在属性"boo"
```

类型明明都已经给了，但是在使用的时候，给他弄一个默认值，它的类型就改变了，读取不到 boo 这个属性了。

这个时候我们就需要使用到类型断言去解决这个问题。如下：

```typescript
const { height, base = {} as IHuman } = yoran;
console.log(base.boo); // 不报错。完美哦
```
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[VsCode中使用vim]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/VsCode中使用vim</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/VsCode中使用vim</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[VsCode 中使用 vim 插件  一、vim 是什么 它把我们平时操作的动作抽象拆分为三种类型，插入模式、可视化模式、普通模式。  二、使用 vim 的动机是什么 第一次听到的能够不使用鼠标，使用键盘就可以操作电脑，符合小时候对于电脑大佬的刻板印象。对不起，是我不成熟了。  三、在 vscode 中的配置 json "vim.easymotion": true, // 启用系统粘贴板作为vim寄存器 "vim.useSystemClipboard": true, // 由vim接管ctrl+any的按键，而不是vscode "vim.useCtrlKeys": true, // 突出显示与...]]></description>
            <content:encoded><![CDATA[# VsCode 中使用 vim 插件

## 一、vim 是什么

它把我们平时操作的动作抽象拆分为三种类型，插入模式、可视化模式、普通模式。

## 二、使用 vim 的动机是什么

第一次听到的能够不使用鼠标，使用键盘就可以操作电脑，符合小时候对于电脑大佬的刻板印象。对不起，是我不成熟了。

## 三、在 vscode 中的配置

```json
"vim.easymotion": true,
// 启用系统粘贴板作为vim寄存器
"vim.useSystemClipboard": true,
// 由vim接管ctrl+any的按键，而不是vscode
"vim.useCtrlKeys": true,
// 突出显示与当前搜索匹配的所有文本
"vim.hlsearch": true,
// 下面定义的按键将交由vscode进行处理，而不是vscode-vim插件
"vim.handleKeys": {
  "<C-a>": false,
  "<C-f>": false,
  "<C-n>": false
},
"vim.leader": "<space>",
"vim.normalModeKeyBindings": [
  {
    "before": ["<leader>", "f"],
    "commands": ["revealInExplorer"]
  },
  {
    "before": ["J"],
    "after": ["5", "j"]
  },
  {
    "before": ["K"],
    "after": ["5", "k"]
  },
  // rename 重命名
  {
    "before": ["<Leader>", "r", "n"],
    "commands": ["editor.action.rename"]
  },
  {
    "before": ["<Leader>", "f", "d"],
    "commands": ["editor.action.formatDocument"]
  }
],
"vim.insertModeKeyBindings": [
  {
    "before": ["j", "k"],
    "after": ["<Esc>"]
  }
],
"vim.sneak": true
```

## 四、关键快捷键

**移动可视窗(光标也可以跟着移动):**

| Ctrl + d（control + d） | 向下滚动半屏                                      |
| ----------------------- | ------------------------------------------------- |
| Ctrl + u（control + u)  | 向上滚动半屏                                      |
| zt                      | 将当前行置于屏幕顶部附近                          |
| zz                      | 将当前行置于屏幕中央                              |
| zb                      | 将当前行置于屏幕底部                              |
| H/M/L                   | 跳转到屏幕的顶部/中间/底部                        |
| （）{}                  | 跳转到上一个句子/下一个句子/上一个段落/下一个段落 |

一些使用 VSCode 开发中常用的操作：

**函数定义之类：**

| gd                    | 进入函数定义       |
| --------------------- | ------------------ |
| Ctrl+o（control + o） | 从函数定义中返回   |
| gd                    | 查看函数参数等信息 |

**切换标签页：**

| gt  | 切换到下一个标签页  |
| --- | ------------------- |
| gT  | 切换到上一个标签页  |
| 4gt | 切换到第 4 个标签页 |

**切换分栏：**

| Ctrl + 1 | 第一个分栏 |
| -------- | ---------- |
| Ctrl + 2 | 第二个分栏 |

> 其他： 可以使用 Ctrl + 0 来将光标从编辑器跳转到文件栏，在文件栏可以使用 j 和 k 进行移动，可以使用 Space 展开或者关闭文件夹，使用 l 可以将光标选中的文件在编辑器中打开。

### 4.3 vim-surround

|             |                                       |
| ----------- | ------------------------------------- |
| `ds "`      | `"Hello world!"` => `Hello world!`    |
| `cs "(`     | `"Hello world!"` => `(Hello world!)`  |
| cS          | 替换括号，括号内文本做新一行          |
| ys          | 添加括号(配合 vim 光标移动)           |
| `ys w [`    | `Hello world!` => `[Hello] world!`    |
| ys w Enter  | Hello world! => <em>Hello</em> world! |
| yS          | 添加括号，括号内文本做新一行          |
| `yS w [`    | `Hello world!` => `[ Hello ] world!`  |
| `yss (`     | `Hello world!` => `( Hello world! )`  |
| ySS         | 整行括起来，括号内文本做新一行        |
| `ySS {`     | `Hello world!` => `{ Hello world! }`  |
| `ySS Enter` | `Hello world!` => `Hello world!`      |
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[vue的业务开发如何进行组件的拆分]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/vue的业务开发如何进行组件的拆分</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/vue的业务开发如何进行组件的拆分</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[Vue2 业务开发组件拆分实战 组件化是一种思维的表现，这种技能映射到人的本质是，一个人是否有能力把一个复杂的问题拆解、简单化的能力。  一、组件化诞生的历史 我们在讨论如何拆分组件之前，是有必要简单的了解一下组件化诞生的一个历史。 前端娱乐圈有一个独有的生态：框架。每年出现的框架层出不穷，根本学不完。但是总的来说还是可以分成两个阶段。 第一阶段：JQ 和 PrototypeJS。 该阶段解决了浏览器的兼容性问题以及 API 的遍历程度 第二阶段:  Vue、React、Angular。解决了组件化、解耦、复用等问题 在大陆，主要讨论的是 Vue 和 React。 有些人说 Vue 是 fra...]]></description>
            <content:encoded><![CDATA[# Vue2 业务开发组件拆分实战

组件化是一种思维的表现，这种技能映射到人的本质是，**一个人是否有能力把一个复杂的问题拆解、简单化的能力。**

## 一、组件化诞生的历史

我们在讨论如何拆分组件之前，是有必要简单的了解一下组件化诞生的一个历史。

前端娱乐圈有一个独有的生态：框架。每年出现的框架层出不穷，根本学不完。但是总的来说还是可以分成两个阶段。

**第一阶段**：JQ 和 PrototypeJS。 该阶段解决了浏览器的兼容性问题以及 API 的遍历程度

**第二阶段: ** Vue、React、Angular。解决了组件化、解耦、复用等问题

在大陆，主要讨论的是 Vue 和 React。 有些人说 Vue 是 framework,而 React 是 library，前者有更多的约束和更加齐全的工具链。而后者更加的自由。但是真的要投入生产的话，依旧需求认为的给 React 添加很多的约束，而且 Vue 也是支持 jsx 的，所以我一直不太赞同 React 更加自由这样的说话。

在我看来，它们在实际生产开发过程中，在那一堆工具链中，**只是 API 的不同而已**。

它们都为前端提供了很好的组件化。而且近一年来两者都不约而同朝着函数式跟进。它们带来的各种 hook,给我们带来了不一致的组件化的写法。

## 二、为什么业务组件越开发越难维护

当然是人的问题. 或许产品的问题,或许整个工作流程的问题,或许上面的问题. 这些我们暂且不提,我作为开发, 首先是要管好自己的代码组织.

再次我们先排除其他外界的因素,比如产品经常改需求. 仅从编码阶段来说.

以我们团队为例，我们团队内部员工 2 个，8 个外包，外包兄弟们的招聘标准是远低于内部的。团队人员每个人的编码能力差距还是很大的。项目都是长期维护的，一个业务模块就会有很多人维护，在上面不断的填尿加屎。

> 在这里并不是说外包人员的编码能力差，我们组就有一个外包的兄弟编码能力、解决问题的能力相当厉害的，比很多内部的都好很多。这里只是从平局值上面来说。

团队成员的水平层次不齐, 估计到团队协作, 我们在写业务组件中弄过做的,就是设定一些源码.

### 2.1 项目现状

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1669737578936-58556351-edf6-4549-81d6-fb4cf2f02eef.png)以该图为例, A B C 分别是父子孙组件. 当我们要控制其中一个组件的状态的是, 可以通过很多方式来进行控制. 这些方式的来源有可能是**全局变量**、**vuex**、**时间总线**、**来自自己父组件或子组件的改变**等等.

可以看出, 改变它组件内部状态的来源非常的多, 维护或者修改的时候,需要翻阅的文件目录和范围就很广. 自然就很难维护.

举一个 mixins 的例子：

假设它混入了这么多功能。

```javascript
export default {
  mixins: [a, b, c, d, e, f, g],
  mounted() {
    console.log(this.whoAreYou);
  },
};
```

这个`this.whoAreYou`你能够知道来源于哪一个么？

而如果改成`hook`的写法来引入某个 JS 中的变量：

```javascript
const { IamI } = myHome()

const { IamI as me } = myHome()
```

这就很简洁干净。在你维护代码的时候，可以很好的进行溯源。

而上面的一切，导致难以维护的原因总结来说有两个：

- 混用业务变量和 UI 变量
- 不区分受控组件和非受控组件

下面我会实际例子分别介绍这个两个概念。而基于`hooks`的复用才是我们现在解决组件化复用的更好的选择。

### 2.2 理想目标

基于`hook`的理想模型

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1669738146798-78c6d796-233b-4281-8e50-835e67188cb5.png)

依旧是 A B C 三个组件.但是 A B C 三个组件外边飘的那些箭头不存在了. 所有能够控制它们的内部状态的方式都集中在了`controllers`上面.

其中`controllers`部分的组织形式和 vue 的`composition api`宣传图表现一致。

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1669776438338-feb8af6b-2b04-4c02-8f9a-cd8a07827a4c.png)

将相似的功能以及用到的变量都封装在一个函数当中。这一切也更加好的迎合了

实际代码如下:

```vue
<template>
  <div>
    <B setC={setC} />
  <div>
</template>
<script setup>
  import B from 'B.js'
  import cController from 'cController.js'

  const { setC } = cController(props)
</script>

// cController.js
export default c(props) {
  const c = ref('')
  const setC() {
    c.value = 'I an cController'
  }

  return {
    c,
    setC,
  }
}

```

`cController.js`就是`controllers`中的一个`void`. 引入到 A 组件当中,然后将里面的方法通过 props 传给 B 组件.

```vue
<template>
  <div>
    <C setC={setC} />
  <div>
</template>
<script setup>
	import C from 'C.js'

  props: {
  	setC: {
      type: Number,
    }
  }
</script>
```

也就是说,控制 C 组件内部状态的是通过引入到 A 组件中的`controller`来进行通过,中间的 B 组件不做任何的处理,仅仅作为一个中转站. 操作起来和理论都很简单。但是想要更好的拆分的话，还需要了解三个概念：

- 业务变脸和 UI 变量
- 受控组件和非受控组件
- 控制反转 ioc

下面我通过一个实际的业务场景来描述。

## 三、举一个实际的例子

### 3.1 需求背景

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1669799527274-fbdc2ba8-d0d8-481c-9ec8-83c8b14cbf1f.png)

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1669800209694-ecf04a1c-e290-47eb-889b-c05d20927c58.png)

简单的截两张图. 需求大致如下:

- 功能就是典型的笔记软件的功能,右边可以放各种类型的文件,点击就可以在右边渲染出对应的内容.
- 目录树有两个彩蛋,会根据当前文件类型出现不同的操作
- 目录树下面有一个固定的收藏夹,目录树可以在这其中滚动

### 3.2 开发之前: 前端设计文档

#### 数据流向图

功能还是很清楚的,但是功能其实很多.

我认为我们团队在开发之前是必须要有的. 作为一个前端, 可以没有流程图,但是一定要下面这样的图. 我在别的地方没有见过这样的图,所以自己给这样的图做了一个定义,叫**数据流向图**.

> 关于完整的工作流程,之后再写一篇文章进行描述

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1669912582986-3671f3d3-a7b4-42ca-854d-7797e7404738.png)

它是有两部分构成:

- 组件的模块
- 组件之间的控制关系

第一点, 还是比较清楚,就是这个需求可以拆成哪几个模块.

第二点, tree 组件和 content 组件是同级组件, tree 可以控制 content 组件内的状态, content 组件也可以改变 tree 内的状态. 再深入一点说,就是 tree 点击不同的文件类型, content 组件部分就会渲染不同的模块; 而当在 content 组件内对当前阅读的文件进行删除操作的时候,tree 作为目录树自然是要刷新最新的目录信息的.

#### 目录结构

通过上面的结构图,可以得到下面这样目录结构.

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1669940918346-49ab45fe-1811-48ee-9e72-2c789ef4c333.png)

#### 逻辑控制

数据流向图中的各个组件都放在根目录下`index.vue`中挂载. 如下入![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670061371190-782d65a7-2c51-444e-94d9-378c5a3eb2e4.png)

控制目录树的相关逻辑都放在`listTreeController`控制器里边, 和右边内容 content 相关逻辑都放入到`renderContentController`的方法当中.

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670061591951-06c51152-80b2-4355-bc3a-bfdbaf15b6d2.png)

随后将 controller 中公共方法都传进到组件当中. `doc-aside`是包括`search`和`tree`已经`other`三个模块的中转组件. 不在这个组件中做任何的逻辑处理. 如下图:

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670061777032-3f7e7fdc-25aa-41f7-8103-57052b5487bd.png)

举一个例子, **控制按钮的权限.**

**[背景]**

- 所有功能点都受控挂载在 vuex 的 store 上面的一个变量, 没有权限的话,就直接通过`v-if`来隐藏对应的入口

**[之前实现]**

- 直接找到对应的按钮在`v-if`上,通过`root.docAuth('createDoc')`来判断

**[修改之后]**

- 创建来一个`authoControllers.js`在`index.vue`引入, 需要用的地方是应用的是

**[具体实现]**

```javascript
export default function authController({ root }) {
  const menuAuth = {
    [MENTY_TYPE.rename]: root.docAuth("rename"),
    [MENTY_TYPE.delete]: root.docAuth("delete"),
    // ....
  };
}
```

虽然在 Index.vue 中引入,不管是通过 props,还是通过依赖注入来给子组件来使用,都不重要.重要的是,它统一管理, 并在 index.vue 中引入是唯一一个入口.

当我们维护的时候, 只需要通过子组件一路找到对应的`controller`就可以找到对应的逻辑了.

#### 拆分的原则

- 对于组件的拆分一开始不需要太细
- 拆分好受控组件和非受控组件

### 3.3 受控组件和非受控组件

我们使用的任何 UI 框架都是受控组件, 受控组件的概念就是它里面的状态都是受调用它的组件来控制的. 非受控组件反之.

### 3.4 开发进行: 逻辑变量和 UI 变量

UI 变量其实很好理解. 像 element-ui 的组件中所需要的属性就是 UI 变量. 但是对于我们实际业务当中, 会对这些进行一定扩展.

举一个例子, 在上面的目录中`dialog组件`的显示或隐藏,是通过`<font style="color:rgb(48, 49, 51);">model-value / v-model</font>`<font style="color:rgb(48, 49, 51);">来进行控制的, </font>`<font style="color:rgb(48, 49, 51);">true</font>`<font style="color:rgb(48, 49, 51);">就显示, </font>`<font style="color:rgb(48, 49, 51);">false</font>`<font style="color:rgb(48, 49, 51);">就隐藏起来. </font>

> <font style="color:rgb(48, 49, 51);">隐藏和显示的渐入渐出效果是 elementUI 框架内置的.</font>

平时工作中很多人是这样传的:

```vue
<el-dialog :v-model="data.id === XXXX">
  // code
</el-dialog>
props = { data: { type: Object } }
```

通过通过接口拿到的,或者自己组件的数据传进来之后,再进行对`v-model`的控制. `data.id`这样的变量就是业务变量, 通过业务变量来直接控制 UI 的组件的显示和隐藏,就是业务变量和 UI 变量的混用. 或者说**业务逻辑和交互逻辑的混用. **

混用之后的后果,就是我们进行维护的时候, 需要查看的变量或者说字段就成倍的增加, 交互变量和业务变量交织在一起. 这部分的代码**同时承载了业务逻辑和交互逻辑.**

> **DDD 领域模型也是可以解决这个问题, 之后我会再开篇幅聊一聊.**

所以我们就需要将业务逻辑和交互逻辑给拆开. 如下:

```vue
<template>
  <el-dialog :v-model="isShow">
    <template slot="header">
      {{ dialogTitle }}
    </template>
    <template slot="content">
      // type === 创建表单
      // type === 移动文件夹目录
    </template>
  </el-dialog>
</temaplte>
props = {
  isShow: {
    type : Boolean,
    desc: '是否显示弹窗'
  },
  type: {
    type: String,
    desc: '弹窗的类型'
  }
}
```

其中`ishow`和`type` 就可以视为 UI 变量, 它们不关心外界是通过了什么判断, 只关系传进来的是 true 还是 false.

## 四、持续的优化

不管一开始代码是如何规划的,如何组织的.最重要的还是要持续的去维护. 屎山到了之后, 前面的维护者没有一个人是无辜的. 但是也不需要过早的去维护.什么时候到了维护重构的时机呢?

- 当碰到这里用的代码别的地方也用到的时候
- 这个变量出现在好几个地方,被好几个地方都 set 的时候, 而自己搞不懂它们 set 的顺序的时候
- 函数复杂到自己看了半天都看不明白的时候

## 五、可能的问题

**问题一: **中转的组件没有挂载任何逻辑，为什么还存在?

1. 为了之后可能的拆分
2. 让结构更加的清晰

**问题二: **中转的组件要挂载这么多办法, 或许太难看?

1. 实在是太多可以使用 vue 的`$attr`和 `$listeners`
2. 为了维护对于数据的溯源

## 五、实践是学习前端的捷径

前端是一门手艺活,只有实践才能够提高技术. 前端的天花板确实相比其他方向的低,但是也不是我这样的普通人说能够触碰就能触碰到的. 就算很多高端大佬嗤之以鼻的业务代码, 写的时候如果不多思考如何写的简洁,怎么写优雅,写十年和写三年也是没有差别的.

业务才能创造价值, 有了价值才能有我们前端工程师生存的空间. 所以为了提升自己的价值, 提升自己的工资. 平时写业务代码的时候,想想这样写会有什么问题, 如何写才能够更加好. 在这个基础上, 才能看明白那些框架存在的意义. 业务是在轮子之上的,如果对业务的代码都不理解, 又怎么能够真正的写好轮子呢?

我们在保障业务按时完成的情况下,应该多尝试,多实践.
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[《重构》导读]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/《重构》导读</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/《重构》导读</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[《重构》导读  零、导读 > 这篇文章是对《重构》这本经典书籍的一个导读。或者说是对于这本书第一章的读书笔记。 有这么一句话，高质量代码是重构出来的。想要理解这句话，我们先来了解一下，开发工作期间，在摸鱼之外的时间分配。《奔跑吧，程序员》这个书正好有这样的饼状图： ![](https://cdn.nlark.com/yuque/mermaidv3/41220a262ddc314a2e1a6298cceb4b98.svg) 从这个表可以清楚的看到，开发直接面对代码的时间为百分之 50，而这百分之 50 中，却有百分之 45.5%的时间是在阅读代码，基本可以说，写代码的时候，程序员基本都是在看代码...]]></description>
            <content:encoded><![CDATA[# 《重构》导读

## 零、导读

> 这篇文章是对《重构》这本经典书籍的一个导读。或者说是对于这本书第一章的读书笔记。

有这么一句话，**高质量代码是重构出来的**。想要理解这句话，我们先来了解一下，开发工作期间，在摸鱼之外的时间分配。《奔跑吧，程序员》这个书正好有这样的饼状图：

![](https://cdn.nlark.com/yuque/__mermaid_v3/41220a262ddc314a2e1a6298cceb4b98.svg)

从这个表可以清楚的看到，开发直接面对代码的时间为百分之 50，而这百分之 50 中，却有百分之 45.5%的时间是在阅读代码，基本可以说，写代码的时候，程序员基本都是在看代码。

如果这时候一直在看的是低质量的代码，不仅仅会拉长阅读代码的时间，还会影响自己的心情，心情不好的好，活也干不好，晚上还有可能睡得晚，睡得晚就会影响自己的健康，这是一种折寿的事情。也就是说：

![image](https://cdn.nlark.com/yuque/__latex/153f1d3a23929cc2eca6aead7b82de1c.svg)

所以我们希望看到的是高质量的代码，而高质量的代码是由重构出来的。可想而知**重构**是多么的重要‼️

每次成功的重构一段代码，看着这出自自己手的优雅代码，成就感油然而生。工作也没有那么糟心了，晚上睡眠质量也高了。重构直接的提高了自己的生活质量。

下面有我总结一下《重构》这本书第一章的内容，希望能够让大家感受到重构的魅力。

## 一、重构目标

这串代码要实现的业务很简单。

"有一家按摩店，它提供的一些服务，会根据服务的类型和服务的时长来计算客户的消费情况。除此之外，还会根据用户的消费，给予用户的一定的积分。"

> 积分,一种营销手段，类似于办会员卡，积分达到一定分数可以打折等。

而下面的代码是一个刘姓开发对于这个需求的实现，目标是打印出某个用户的发票:

```javascript
// 按摩店当前的收费项目
const plays = {
  Thai: { name: "Thai", type: "massage back" },
  Chinese: { name: "Chinese", type: "pinch the foot" },
  American: { name: "American", type: "massage back" },
};

// 某个用户单词消费类目
const invoices = {
  customer: "刘冠荣",
  performances: [
    {
      playID: "Thai",
      time: 55,
    },
    {
      playID: "Chinese",
      time: 35,
    },
    {
      playID: "American",
      time: 40,
    },
  ],
};

function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `${invoice.customer}的账单:\n`;
  // 数字转化成RMB
  const format = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "RMB",
    minimumFractionDigits: 0,
  }).format;

  for (let perf of invoice.performances) {
    const play = plays[perf.playID];
    let thisAmount = 0;
    switch (play.type) {
      case "message back":
        thisAmount = 40000;
        if (perf.time > 30) {
          thisAmount += 1000 * (perf.time - 30);
        }
        break;
      case "pinch the foot":
        thisAmount = 30000;
        if (perf.time > 20) {
          thisAmount += 10000 + 500 * (perf.time - 20);
        }
        thisAmount += 300 * perf.time;
        break;
      default:
        throw new Error(`没有这个项目，去别的店吧: ${play.type}`);
    }
    volumeCredits += Math.max(perf.time - 30, 0);
    if ("comedy" === play.type) volumeCredits += Math.floor(perf.time / 5);
    result += ` ${play.name}: ${format(thisAmount / 100)} (${
      perf.time
    } 分钟)\n`;
    totalAmount += thisAmount;
  }

  result += `总共花费 ${format(totalAmount / 100)}\n`;
  result += `您获得 ${volumeCredits} 积分\n`;
  return result;
}

const statementLog = statement(invoices, plays);
console.log(statementLog);
```

打印的结果如下是：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1754332950402-1bd9f101-46ba-417d-be3c-8f0601df8047.png)![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8670452cf92489fb6837181a04a5634~tplv-k3u1fbpfcp-watermark.image?)

咋看一下，这段代码没啥问题，又不长，逻辑也不多。也没有什么嵌套的 if else。

但是，此时 **产品** 她不单单你打印出字符串直接渲染到界面了。她想要你拼接成`html`。那我们是不是要复制一份下来，然后在每一个`result`相关逻辑上修改，还需要修改标签拼接的逻辑。

当我们好不容易写完，产品这时候又要求修改积分计算的算法。我们是不是需要在两个地方修改两遍？

而且，我们每添加修改一个功能，都需要从头到尾再看一次这一片代码。自己写的代码尚且过了几个星期都不认识，更不用说在团队的合作当中了。

当然，如果只是一次性开发的东西，以后不用再维护了，怎么样都无所谓。但是如果是长期的项目,这样必然是有隐患的。所以我们就需要重构它!

> 为了更好的修改代码，我们遵守诸如函数单一原则，封闭原则等，这是解决问题的道，而重构就是术。重构详细的解释了每种情况应该怎么应对。

## 二、提炼函数 & switch

看到最显眼的就是 switch 那一串代码。那么我们就把它给先提出来单独构成一个函数。

拆分一个函数最大的问题，不是拆分这些逻辑，而是拆分那些变量。更准确的说，是要改变**作用域**。

它有这些变量 **thisAmout、play、perf**

thisAmout 是一个临时变量，先不用搭理它。

play 和 perf 都是可以外边传进来的，所以有了如下的拆分结果：

```javascript
function statement （....） {

    // 顶层作用域 的code

   function amountFor((perf, play) {
    let thisAmount = 0
    switch (play.type) {
      case 'message back':
        thisAmount = 40000
        if (perf.time > 30) {
          thisAmount += 1000 * (perf.time - 30)
        }
        break
      case 'pinch the foot':
        thisAmount = 30000
        if (perf.time > 20) {
          thisAmount += 10000 + 500 * (perf.time - 20)
        }
        thisAmount += 300 * perf.time
        break
      default:
        throw new Error(`没有这个项目，去别的店吧: ${play.type}`)
    }


    return thisAmount
  }
}
```

## 三、修改变量名 & 内联变量 & 消减变量

:::color1
**好代码应能清楚地表明它在做什么，而变量命名是更是代码清晰的关键**

:::

**thisAmout:** 是需要 return 回去，而且函数名也很直白的表述清楚这个函数要输出的东西是什么。所以它可以改为 result

**perf:** 由于是在循环中返回的，所以为了语义化更加的明确，可以加一个冠词在前面，变成 aPerf

**play:** 我们回到原本的语境当中，可以知道.play 由顶级作用域的变量以及 perf 构成临时变量. 我们要消灭它。

我们项目中经常出现这样的一个场景：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6346483598e54caaaa857ab284e9d93c~tplv-k3u1fbpfcp-watermark.image?)![](https://cdn.nlark.com/yuque/0/2025/png/654315/1754332987170-ca996b98-42bc-4ba6-a0fb-ddda5f935a7b.png)

图并没有截完。

作为一个经常使用 vue2.0 的开发者，截图应该是我们经常看到这样的。我不知道你们看到这样的场景是什么感受，反正我是头皮发麻的。更不要说要在这个上面进行修改了。

我们在修改命名之后, 还需要结合内敛变量手法以及消减变量手法，尽可能的**减少不必要的变量。**

**整理如下：**

```javascript
function statement(invoice, plays) {
  // .....
  function amountFor(aPerf) {
    let result = 0;
    switch (playFor(aPerf).type) {
      case "message back":
        result = 40000;
        if (aPerf.time > 30) {
          result += 1000 * (aPerf.time - 30);
        }
        break;
      case "pinch the foot":
        result = 30000;
        if (aPerf.time > 20) {
          result += 10000 + 500 * (aPerf.time - 20);
        }
        result += 300 * aPerf.time;
        break;
      default:
        throw new Error(`没有这个项目，去别的店吧: ${playFor(aPerf).type}`);
    }

    return result;
  }

  function playFor(perf) {
    return plays[perf.playID];
  }
}
```

回到循环当中，在顶级作用域中 thisAmout 既然也是临时变量，那么也可以使用内联变量手法去消除它

```javascript
for (let perf of invoice.performances) {
  volumeCredits += Math.max(perf.time - 30, 0);

  if ("comedy" === playFor(perf).type)
    volumeCredits += Math.floor(perf.time / 5);

  result += ` ${playFor(perf).name}: ${format(thisAmount / 100)} (${
    perf.time
  } 分钟)\n`;
  totalAmount += amountFor(perf);
}
```

此时再回到循环当中。可以明显看到，它既然做了两件事情，一个是计算 刘冠荣 消费的金额，另外一个是计算他所得的积分。所以我们自然要对循环进行进一步的处理。

## 四、拆分循环 & 提取积分计算

```javascript
for (let perf of invoice.performances) {
  volumeCredits = volumeCreditsFor(perf);

  result += ` ${playFor(perf).name}: ${format(thisAmount / 100)} (${
    perf.time
  } 分钟)\n`;

  totalAmount += amountFor(perf);
}

function volumeCreditsFor(aPerf) {
  let result = 0;
  result += Math.max(aPerf.time - 30, 0);
  if ("comedy" === playFor(aPerf).type) result += Math.floor(aPerf.time / 5);

  return result;
}
```

**即便如此，这个循环当中，依旧干了两件事情！！！！**

```javascript
for (let perf of invoice.performances) {
  result += ` ${playFor(perf).name}: ${format(thisAmount / 100)} (${
    perf.time
  } 分钟)\n`;
  totalAmount += amountFor(perf);
}

for (let perf of invoice.performances) {
  volumeCredits = volumeCreditsFor(perf);
}
```

循环了两遍。或许会引起对于性能的担忧。但是起码在这样的场景下面，对于性能的影响其实可以忽略不计的。而且很多我们以为的性能问题，其实对于现代的浏览器而言都不是问题，我们小看开发浏览器的那群人了。

不过，情况自然也是有例外。

就算真的有了性能问题，我们也应该在重构之后在考虑。重构之后，我们的代码结构更加的干净，整洁，对于性能的调优自然是更加的直观明确的，也更加的有助于你分析性能的瓶颈出在哪里.

在《重构》这本书就明确的表述了：

_**大多数情况下可以忽略它。如果重构引起了性能损耗，先完成重构，再做性能优化**_

> 很多我们以为的性能问题，其实对于现代的浏览器而言都不是问题

## 五、唯一性命名 & 提取 format

```javascript
function rmb(aNumber) {
  return new Intl.NumberFormat("en-US", {
    style: "currensy",
    currency: "RMB",
    minimumFractionDigits: 0,
  }).format(aNumber / 100);
}
```

- 进一步消减了临时变量

## 六、移动语句

- 把相关联的变量和语句结合在一起
- react 的代码规范

```javascript
function statement(invoice, plays) {
  let result = `${invoice.customer}的账单:\n`;

  let totalAmount = 0;
  for (let perf of invoice.performances) {
    result += ` ${playFor(perf).name}: ${rmb(amountFor(perf))} (${
      perf.time
    } 分钟)\n`;
    totalAmount += amountFor(perf);
  }

  let volumeCredits = 0;
  for (let perf of invoice.performances) {
    volumeCredits = volumeCreditsFor(perf);
  }

  result += `总共花费 ${rmb(totalAmount)}\n`;
  result += `您获得 ${volumeCredits} 积分\n`;
  return result;

  // ......
  // ......
}
```

**组合式 API**

这张图就很好的解释了 vue3 退出 COmpostionAPI 的一个动机，能够让相关代码集中起来，方便之后更好的复用和拆分。

> 我们重构的目的不是为了让函数可以复用，而是让函数更加的容易读

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a286890b20854ba0a41a2a442919858b~tplv-k3u1fbpfcp-watermark.image?)![](https://cdn.nlark.com/yuque/0/2025/png/654315/1754333010630-050fa575-7826-441b-8e9a-874e24694127.png)

- 为下一步 更进一步 提炼函数 提供直观的帮助

## 七、提炼函数 & 消除变量

上一步的移动语句，就是为了更好的提炼函数做准备的。我们把积分和费用的循环逻辑进一步封装。

```javascript
function totalVolumeCredits() {
  let volumeCredits = 0;
  for (let perf of invoice.performances) {
    volumeCredits = volumeCreditsFor(perf);
  }
  return volumeCredits;
}

function totalAmount() {
  let result = 0;
  for (let perf of invoice.performances) {
    totalAmount += amountFor(perf);
  }
  return result;
}
```

在结合我们的内联变量，消除临时变量。

此时看看现在代码的全貌，将函数都给折叠起来：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1754333027520-97080531-fc55-4c7b-97b3-c801a1aade9d.png)

有上图可以明显看出来。核心代码位于第一个红框之中。是不是比一开始的干净得太多?通过合理的命名和简洁的代码，可以更加的看出来这串代码是做什么用的。如果需要知道具体的变量是怎么来，只需要展开对应的函数即可。

当需要进行修改什么逻辑的时候，可以直接定位到对应的函数中。**焦点可以聚集在对应函数当中，不会受到其他代码的干扰。**

下面是完整的代码：

```javascript
function statement(invoice, plays, type) {
  let result = `${invoice.customer}的账单:\n`;
  for (let perf of invoice.performances) {
    result += ` ${playFor(perf).name}: ${rmb(amountFor(perf))} (${
      perf.time
    } 分钟)\n`;
  }

  result += `总共花费 ${rmb(totalAmount())}\n`;
  result += `您获得 ${totalVolumeCredits()} 积分\n`;
  return result;

  function amountFor(aPerf) {
    let thisAmount = 0;
    switch (playFor(aPerf).type) {
      case "message back":
        thisAmount = 40000;
        if (aPerf.time > 30) {
          thisAmount += 1000 * (aPerf.time - 30);
        }
        break;
      case "pinch the foot":
        thisAmount = 30000;
        if (aPerf.time > 20) {
          thisAmount += 10000 + 500 * (aPerf.time - 20);
        }
        thisAmount += 300 * aPerf.time;
        break;
      default:
        throw new Error(`没有这个项目，去别的店吧: ${playFor(aPerf).type}`);
    }
    return thisAmount;
  }

  function playFor(aPerf) {
    return plays[aPerf.playID];
  }

  function volumeCreditsFor(aPerf) {
    let result = 0;
    result += Math.max(aPerf.time - 30, 0);
    if ("comedy" === playFor(aPerf).type) result += Math.floor(aPerf.time / 5);

    return result;
  }

  function rmb(aNumber) {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "RMB",
      minimumFractionDigits: 0,
    }).format(aNumber / 100);
  }

  function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) {
      volumeCredits = volumeCreditsFor(perf);
    }
    return result;
  }

  function totalAmount() {
    let result = 0;
    for (let perf of invoice.performances) {
      totalAmount += amountFor(perf);
    }
    return result;
  }
}
```

## 八、测试

整本书都在强调**测试**的重要性，上面重构的每一步都需要进行测试才进行下一步操作。

书中有这么一句话：

:::warning
![image](https://cdn.nlark.com/yuque/__latex/ab9ea7a8ba5a456e6dc9fc2ba62d2849.svg)

:::

只要上线的代码就是有价值的代码，不管你现在的代码多么简洁, 只有经过充分的测试并上线才有价值，不然就是一文不值的。

重构一定是有风险的。重构不是重写，所以我们需要有计划，有计划的进行，这就是《重构》《代码整洁之道》这些书的伟大之处。

> 重构是需要测试资源的介入的，这就意味着，你的重构需要得到领导的同意。甚至涉及到了迭代开发流程。这就是另外一个话题了。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[CodeReview礼仪]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/CodeReview礼仪</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/CodeReview礼仪</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[CodeReview 礼仪  一、序言: 原来程序员是这么合作的 在我工作的前四年, 经常会在网上看到 Code Review 这个词. 但是却从来实践过. 看着他们对于 Code Review 习以为常的样子, 我宛如活在了平行世界. 不知道他们在说什么, 虽然每一个字都认识, 自然也没有什么感触. 直到第五年,加入了现在的公司,才真正的知道 Code Review 是什么一回事. 或者说只是知道一冰山一角,毕竟到现在只有不到一年的 Code Review 的经验. 但是给我带来的感触还是很深的. > 向开源项目提交 PR, 也有 Code Review? 不好意思, 在此之前,从来不看别的...]]></description>
            <content:encoded><![CDATA[# CodeReview 礼仪

## 一、序言: 原来程序员是这么合作的

在我工作的前四年, 经常会在网上看到 Code Review 这个词. 但是却从来实践过.

看着他们对于 Code Review 习以为常的样子, 我宛如活在了平行世界. 不知道他们在说什么, 虽然每一个字都认识, 自然也没有什么感触.

直到第五年,加入了现在的公司,才真正的知道 Code Review 是什么一回事. 或者说只是知道一冰山一角,毕竟到现在只有不到一年的 Code Review 的经验. 但是给我带来的感触还是很深的.

> 向开源项目提交 PR, 也有 Code Review? 不好意思, 在此之前,从来不看别的源码,面向百度编程罢了

这篇文章, 会首先介绍什么是 Code Review, 然后到我们组现在的 Code Review 流程, 接着到处理的好会打起来的 Code Review 礼仪。 最后加上一个问题， 小公司是否需要 Code Review。

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670130932656-379fd2f1-195d-446e-bdb3-965bbd90dbff.png)

最后一个问题,我想来还是有一定的发言权的. **在工作的前四年换了六家公司, 去一家倒闭一家**. 并不是我想要跳槽,只是普本的学历、菜狗的技术, 很多人看不起的外包我都面不过. 再加上运气着实有点问题。

所以在这些小公司协作的时候, 相当原始。 svn 代码管理, 本地项目打包出 dist 文件夹, 压缩之后通过 QQ 传给后台上传。 即便到了负责 APP 的时候, 也是本地手动打包出`.app`发送到测试手机上面.。

即便后来用了 git,也和 svn 的使用没有任何差别, 不存在什么代码审查, 仓库权限的配置. `PR`和 `MR`是啥意思都分不清楚. CI 和 CL 是啥？

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670130597950-fb28e693-8e4a-4944-9e85-02d802d0da96.png)

我的本科虽然是计算机科学与技术,但是除了学习,啥都干。

直到来到了现在的这家公司, 才知道,原来程序员是这么协作的. 这篇文章只说 Code Review, 其他方面之后再出一片文章详细谈谈。

## 二、什么是 Code Review

Code Review 就是将自己的代码公开的给其他程序员审查的过程。

Reviewer 和<font style="color:rgb(18, 18, 18);">Reviewee 之间主要是通过 comment 来进行沟通，comment 可以针对每一行来进行评论。</font>

- <font style="color:rgb(18, 18, 18);">熟悉同事在编程时的思考方式，这样其余同事以后如果有需要就可以更轻松、快速的修改代码。</font>
- <font style="color:rgb(18, 18, 18);">向同事介绍修改了哪些文件，增加了什么样的功能，这样在问题出现时，可以保证至少有两个人可以帮助诊断、解决问题。</font>

### <font style="color:rgb(18, 18, 18);">2.1 评论规范</font>

<font style="color:rgb(18, 18, 18);">comment 也有规范，如下</font>

:::info
[request] 我建议这里可以更改为函数 forEach 用户，这个更加的复合规范

[advise] 这里的判断为了应对之后的扩展，可以考虑使用策略模式

[question] 为什么需要多加一个变量来进行判断

:::

通过`[]`包住的标识含义还是很直接的。

- [request] 必须要修改才能够通过
- [advise] 不修改也可以通过
- [question] 需要 reviewee 解释一下

### 2.2 CM 实际是在 M 什么

<font style="color:rgb(18, 18, 18);">目的是提高代码质量</font>

<font style="color:rgb(18, 18, 18);">提前发现 bug 外，还包括统一团队的代码规范，比如经常会碰到有人说你这个变量命名不对</font>

代码风格通过配置 Eslint 来进行统一，命<font style="color:rgb(18, 18, 18);">名规则，</font>[语法检查](https://www.zhihu.com/search?q=%E8%AF%AD%E6%B3%95%E6%A3%80%E6%9F%A5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2293450972%22%7D)<font style="color:rgb(18, 18, 18);">，分支规范等</font>是需要提前团队规范来解决的。这些都不应该放在 Code Review 上面。

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670165488441-c670d235-e9c3-46ad-863a-c2de5eecad94.png)

所以实际上，在 CM 之前是有前置条件的：

![画板](https://cdn.nlark.com/yuque/0/2022/jpeg/654315/1670430205802-6b0e6221-ba38-4476-a7f1-e1dfceda3a76.jpeg)

在这里之后才开始 CM。CM 的内容基本包括下面：

- 业务 BUG
- 代码质量

业务 BUG 很直接，很多时候，写的东西不一定用在一个场合，而写的人不一定都熟悉。

代码质量包括这些内容：

- 人工检查代码格式化的漏网之鱼
- 是否存在重复
- 最佳实践，`if else`、参数过多、ES6、设计模式（怼人的理论基础是《重构-改善既有代码》）
- <font style="color:rgb(18, 18, 18);">命名可读性,能自我阐述的最好,英文用词尽量准确(命名是所有程序员的头痛之一)</font>
- <font style="color:rgb(18, 18, 18);">注释,恰到好处的注释,重要的地方及时备注,不需要的地方要删除一定的注释信息,代码既是给机器运行的,也同时是交接给人看的.</font>
- <font style="color:rgb(18, 18, 18);">代码是否健壮，是否可扩展</font>

<font style="color:rgb(18, 18, 18);">我们的目标是消灭下面这张图：</font>

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670428340001-0c55330d-9c2c-4e2b-a34b-1df6ab1c131c.png)

## 三、我们组的 Code Review 流程

<font style="color:rgb(18, 18, 18);">我们组是每一次 Merge Request 都进行 Code Review。</font>

> <font style="color:rgb(18, 18, 18);">还有一种是每隔一段时间集中大家一起来进行 CR。</font>

基本的流程图如下:

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670148225843-b74c85c7-7433-4244-91cc-1e0f476649e3.png)

简单来说，就是从 test 分支拉取最新的代码之后，开发完成之后需要合并到远程自己定义的分支，随后将这个分支申请合并到远程 test 分支上面，通过 CI 自动扫描之后，就出发代码审查阶段了

- name\_需求编码指的是, 远程的分支的名称 = 是以自己的名字的首字母 + 下划线 + 需求的 ID。
- test 分支在经过测试之后， 才会被允许合并到 releasel 分支， 这个过程是封版。将该分支发布部署之后，就可以合并到 master 分支。当然，这个涉及到了分支策略的问题，以后再谈

我们组最多的时候十个人, 评审的人员除了申请人, 其他人都是评审员. 每一个 PR 只需要两个评审的通过就可以入库。当有未必解决状态的评论的时候，其他评审人一般情况是不能审批通过的。

这样的评审的机制其实已经相当宽松了 ，也是希望所有人都能够参与到评审当中，相互都能够了解到对方模块的情况。

但是现实中情况还是不太一样，由于人员之间的水平是有差距的，我们的人员搭配是两个内部的搭配 7/8 个外包的伙伴。虽然平时开发已经再三说明可以给任何人审查代码，不过由于整个环境的问题，实际上敢点击通过代码的依旧只有内部的两个人。形成了事实上的两人评审。

## 四、Code Review 礼仪

<font style="color:rgb(18, 18, 18);">Code Review 的礼仪决定了你是否会被同事背后捅刀。主要是谨记一条原则：</font>

**<font style="color:rgb(18, 18, 18);">只针对代码不针对人</font>**

### <font style="color:rgb(18, 18, 18);">4.1 总结</font>

#### 对评审人员的建议：

- 看不明白的时候，可以适当的提醒对方添加注释
- 看不明白的时候，是请教对方而不是责问对方
- 不管是明确修改的方案还是指出问题，给出自己的理由，依据，而不是感觉
- 评论的内容不要过于广泛

作为 reviewer 提出 comment,<font style="color:rgb(18, 18, 18);">目的是提升项目代码质量，而不是抨击别人，质疑别人的能力，应该保持平等友善的语气。</font>

<font style="color:rgb(18, 18, 18);">评论的内容广泛的问题，比如说，评论 Reviewee 的耦合度太高。这么的言论就很操蛋，我们需要提出的是具体的建议，可以给出具体的改进的伪代码。不然最好闭嘴。</font>

#### 对提审人的建议：

- 每次提交的代码量都尽可能的小
- 反驳一定需要给出的依据
- 相比评审人要更加的谦虚

第一点，为了方便<font style="color:rgb(18, 18, 18);">审阅者可以轻松了解代码中有哪些更改以及做了什么。如果 code review 的内容足够少，则可以更频繁地进行，可能每天几次，而且更易于管理。</font>

对于第二点，评审的人花了这么多时间给你来看代码。如果提出的建议能够改善你写的代码，或者直接指出了问题，提审人都是最大的受益者。

### 4.2 话术的建议

| **bad**          | **good**                         |
| ---------------- | -------------------------------- |
| 你要这么做       | 我建议这么做/这么干是否更加好    |
| 你写的代码比较差 | 这块代码写得比较差               |
| 你这里写得太坑了 | 重构里面提议这种情况应该提取函数 |

**最重要的一点就是，不要吝啬你的夸奖！**

当你实在找不到问题的时候，多夸夸你的同事吧。这段代码设计得真好，这段代码性能提升得真高。当然，平时做人的时候也应该如此。

## 五、小公司是否需要 Code Review

**不需要！**

对于公司而言，**业务第一，产品第二，技术无所属**。领导只关心如何活下去。所以对于你如何使用技术并不关心，关心的是业务是否来钱，自己还有几套房可以抵押。

你们进行 CR 是需要时间，这是钱。

你们想要提高代码质量，需要持续重构优化，客户操作界面的时候感受得出来么？如果没有，那是浪费钱。

无关褒贬，客观事实罢了。

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670431699881-77bcfed9-e230-428b-8631-7e558d4977ea.png)

但是对于个人而言呢？**需要，相当需要**。

都不小了，要明白自己应该做什么。

如果团队的 Code Review 有没有推行没关系,有,自然是非常的。没有的话，你也要通过别的手段自我提升。

但凡有好的事物都应该主动去尝试,去坚持,克服外来因素影响。

一个人,也同样可以 Review 自己和同事代码,为的不是公司，为的是自己。

Review 水平比自己高的，可以直接提升自己的编码能力，学习高水平的思路和设计。

Review 水平比自己低的，可以看看那些错误都是怎么发生的，告诫自己。

Review 水平和自己差不多的，可以换位思考，如果是自己来实现会怎么实现。

卷起来吧，

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670432316837-879ab9e2-8ee5-4cdb-a6eb-0e9b4e01b655.png)

放错图，应该是

![](https://cdn.nlark.com/yuque/0/2022/png/654315/1670432581437-dbcfb7eb-1e13-43f2-8bb2-60010b9f1c14.png)
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[Code评审模板和礼仪]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/Code评审模板和礼仪</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/Code评审模板和礼仪</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[Code 评审模板和礼仪 <font style="color:rgb(0, 0, 0);">Code Review 就是将自己的代码公开的给其他程序员审查的过程。Reviewer 和 Reviewee 之间主要是通过 comment 来进行沟通，comment 可以针对每一行来进行评论。</font> <font style="color:rgb(0, 0, 0);">熟悉同事在编程时的思考方式，这样其余同事以后如果有需要就可以更轻松、快速的修改代码。</font> <font style="color:rgb(0, 0, 0);">向同事介绍修改了哪些文件，增加了什么样的功能，这样在问题出...]]></description>
            <content:encoded><![CDATA[# Code 评审模板和礼仪

<font style="color:rgb(0, 0, 0);">Code Review 就是将自己的代码公开的给其他程序员审查的过程。Reviewer 和 Reviewee 之间主要是通过 comment 来进行沟通，comment 可以针对每一行来进行评论。</font>

<font style="color:rgb(0, 0, 0);">熟悉同事在编程时的思考方式，这样其余同事以后如果有需要就可以更轻松、快速的修改代码。</font>

<font style="color:rgb(0, 0, 0);">向同事介绍修改了哪些文件，增加了什么样的功能，这样在问题出现时，可以保证至少有两个人可以帮助诊断、解决问题。</font>

## <font style="color:rgb(0, 0, 0);">一、评审模板</font>

### <font style="color:rgb(0, 0, 0);">1.1 选择对应的标签</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704007605452-078202ed-ca9d-406d-b0a6-1a1475468e12.png)

### <font style="color:rgb(0, 0, 0);">1.2 comment 规范</font>

- <font style="color:rgb(0, 0, 0);">[必要]我建议这里可以更改为函数 forEach 用户，这个更加的复合规范</font>
- <font style="color:rgb(0, 0, 0);">[建议]这里的判断为了应对之后的扩展，可以考虑使用策略模式</font>
- <font style="color:rgb(0, 0, 0);">[疑问]为什么需要多加一个变量来进行判断</font>

### <font style="color:rgb(0, 0, 0);">1.3 "[]"中对应的含义如下：</font>

- <font style="color:rgb(0, 0, 0);">[必要] ⇒ 必须要修改才能够通过</font>
- <font style="color:rgb(0, 0, 0);">[建议] ⇒ 不修改也可以通过</font>
- <font style="color:rgb(0, 0, 0);">[疑问] ⇒ 需要 reviewee 解释一下</font>

### <font style="color:rgb(0, 0, 0);">1.4 案例</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704007605531-f0001593-a743-44d0-b9b3-d8846d1cda0b.png)

<font style="color:rgb(0, 0, 0);">数字分别对应：</font>

1. <font style="color:rgb(0, 0, 0);">标签</font>
2. <font style="color:rgb(0, 0, 0);">当前评论是否已经解决</font>
3. <font style="color:rgb(0, 0, 0);">对于当前评论的建议等级</font>
4. <font style="color:rgb(0, 0, 0);">评论主体</font>

<font style="color:rgb(0, 0, 0);">推荐在评审设置的地方，将只有解决才可通过的勾选</font>

### <font style="color:rgb(0, 0, 0);">1.5 如何收集自己的评审信息</font>

1. <font style="color:rgb(0, 0, 0);">打卡 TT，选择研发云聊天框</font>![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704007605460-00677f8e-a96d-415e-80bc-5318e6d2054e.png)
2. <font style="color:rgb(0, 0, 0);">打开聊天记录，输入‘【已解决】。’ ，主要是全角。这样搜索出来的结果就是和你相关的评审，可以加上日期来进行过滤。</font>![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704007605498-beb4f2a1-f1eb-47de-9452-e9a88d150f85.png)

## <font style="color:rgb(0, 0, 0);">二、Code Review 礼仪</font>

<font style="color:rgb(0, 0, 0);">代码质量包括这些内容：</font>

- <font style="color:rgb(0, 0, 0);">人工检查代码格式化的漏网之鱼</font>
- <font style="color:rgb(0, 0, 0);">是否存在重复</font>
- <font style="color:rgb(0, 0, 0);">最佳实践，if else、参数过多、ES6、设计模式（怼人的理论基础是《重构-改善既有代码》）</font>
- <font style="color:rgb(0, 0, 0);">命名可读性,能自我阐述的最好,英文用词尽量准确(命名是所有程序员的头痛之一)</font>
- <font style="color:rgb(0, 0, 0);">注释,恰到好处的注释,重要的地方及时备注,不需要的地方要删除一定的注释信息,代码既是给机器运行的,也同时是交接给人看的.</font>
- <font style="color:rgb(0, 0, 0);">代码是否健壮，是否可扩展</font>

<font style="color:rgb(0, 0, 0);">我们的目标是消灭下面这张图：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/654315/1704007605504-be64e3d8-8221-4b84-ba93-21d45ab19af6.png)

<font style="color:rgb(0, 0, 0);">同时，我们还需要注意一下礼仪。</font>

<font style="color:rgb(0, 0, 0);">Code Review 的礼仪决定了你是否会被同事背后捅刀。主要是谨记一条原则：</font>

**<font style="color:rgb(0, 0, 0);">只针对代码不针对人</font>**<font style="color:rgb(0, 0, 0);">。</font>

**<font style="color:rgb(0, 0, 0);">对评审人员的建议</font>**<font style="color:rgb(0, 0, 0);">：</font>

- <font style="color:rgb(0, 0, 0);">看不明白的时候，可以适当的提醒对方添加注释</font>
- <font style="color:rgb(0, 0, 0);">看不明白的时候，是请教对方而不是责问对方</font>
- <font style="color:rgb(0, 0, 0);">不管是明确修改的方案还是指出问题，给出自己的理由，依据，而不是感觉</font>
- <font style="color:rgb(0, 0, 0);">评论的内容不要过于广泛</font>

<font style="color:rgb(0, 0, 0);">作为 reviewer 提出 comment,目的是提升项目代码质量，而不是抨击别人，质疑别人的能力，应该保持平等友善的语气。</font>

<font style="color:rgb(0, 0, 0);">评论的内容广泛的问题，比如说，评论 Reviewee 的耦合度太高。这么的言论就很操蛋，我们需要提出的是具体的建议，可以给出具体的改进的伪代码。不然最好闭嘴。</font>

**<font style="color:rgb(0, 0, 0);">对提审人的建议:</font>**

- <font style="color:rgb(0, 0, 0);">每次提交的代码量都尽可能的小</font>
- <font style="color:rgb(0, 0, 0);">反驳一定需要给出的依据</font>
- <font style="color:rgb(0, 0, 0);">相比评审人要更加的谦虚</font>

<font style="color:rgb(0, 0, 0);">第一点，为了方便审阅者可以轻松了解代码中有哪些更改以及做了什么。如果 code review 的内容足够少，则可以更频繁地进行，可能每天几次，而且更易于管理。</font>

<font style="color:rgb(0, 0, 0);">对于第二点，评审的人花了这么多时间给你来看代码。如果提出的建议能够改善你写的代码，或者直接指出了问题，提审人都是最大的受益者。</font>

**<font style="color:rgb(0, 0, 0);">话术的建议</font>**

| **<font style="color:rgb(0, 0, 0);">bad</font>**          | **<font style="color:rgb(0, 0, 0);">good</font>**                         |
| --------------------------------------------------------- | ------------------------------------------------------------------------- |
| <font style="color:rgb(0, 0, 0);">你要这么做</font>       | <font style="color:rgb(0, 0, 0);">我建议这么做/这么干是否更加好</font>    |
| <font style="color:rgb(0, 0, 0);">你写的代码比较差</font> | <font style="color:rgb(0, 0, 0);">这块代码写得比较差</font>               |
| <font style="color:rgb(0, 0, 0);">你这里写得太坑了</font> | <font style="color:rgb(0, 0, 0);">重构里面提议这种情况应该提取函数</font> |

**<font style="color:rgb(0, 0, 0);">最重要的一点就是，不要吝啬你的夸奖！</font>**<font style="color:rgb(0, 0, 0);"><br />当你实在找不到问题的时候，多夸夸你的同事吧。这段代码设计得真好，这段代码性能提升得真高。当然，平时做人的时候也应该如此。</font>
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[React中如何分组件]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/最佳实践/React中如何分组件</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/最佳实践/React中如何分组件</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[React 中如何分组件 > 基于自己工作中的体会，还有在做的过程中翻阅的资料，看的资料没有收藏起来，很想指出具体的出处，但是很多都是从各个地方看到的。不过都是在掘金、公众号前端开发、还有知乎上看到的。  😫 前言 随着 web 业务越来越复杂，一个页面必须要分成多个部分才能使得代码逻辑更加的清晰，出了问题也能更加快速的定位。所以说如果分组件的重要性不言而喻。  一、基本原则 - 每个组件不能超过 300 行。网上看好多人都说是 200 行，但是那样实际操作的话，压力会很大的，导致很多时候会为了分组件而分组件。其实分组件的目的就是为了可读性和可维护性。为了分组件而分组件的话，很多时候写的会很...]]></description>
            <content:encoded><![CDATA[# React 中如何分组件

> 基于自己工作中的体会，还有在做的过程中翻阅的资料，看的资料没有收藏起来，很想指出具体的出处，但是很多都是从各个地方看到的。不过都是在掘金、公众号前端开发、还有知乎上看到的。

## 😫 前言

随着 web 业务越来越复杂，一个页面必须要分成多个部分才能使得代码逻辑更加的清晰，出了问题也能更加快速的定位。所以说如果分组件的重要性不言而喻。

## 一、基本原则

- **每个组件不能超过 300 行**。网上看好多人都说是 200 行，但是那样实际操作的话，压力会很大的，导致很多时候会为了分组件而分组件。其实分组件的目的就是为了可读性和可维护性。为了分组件而分组件的话，很多时候写的会很散很乱，违背了分组件的原则 。
- **一切都是为了可读性和可维护性**
- 组件有两种类型：**一种是有状态的，一种是无状态的**
- 从不同纬度考虑的话，可以分为四种：**逻辑组件（智能组件）、UI 组件（木偶组件）**、路由组件、状态组件（当前工作环境等常量）
- **业务代码的复用高于代码的复用**
- 公共组件可以有自己的方法，但是数据的展示依旧是拿 props。**一定要在跨页面使用的情况下才放在主目录的 componets 中**

> <font style="color:#333333;">无论是 Vue、augular 还是 React 提倡的基于数据驱动的设计理念——程序定义好 Model 和 View 的关系，剩下的业余处理只需要关心数据变化，View 的变化由框架自动执行，无需像 jquery 时代再去手动操作 DOM。</font>

| 展示组件                                                         | 容器组件                                                                                                                                    |
| ---------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| 关注事物的展示                                                   | 关注事物如何工作                                                                                                                            |
| 可能包含展示和容器组件，并且一般会有 DOM 标签和 css 样式         | 可能包含展示和容器组件，并且不会有 DOM 标签和 css 样式                                                                                      |
| 常常允许通过 this.props.children 传递                            | 提供数据和行为给容器组件或者展示组件                                                                                                        |
| 对第三方没有任何依赖，比如 store 或者 flux action                | 调用 flux action 并且提供他们的回调给展示组件                                                                                               |
| 不要指定数据如何加载和变化                                       | 作为数据源，通常采用较高阶的组件，而不是自己写，比如 React Redux 的 connect(), Relay 的 createContainer(), Flux Utils 的 Container.create() |
| 仅通过属性获取数据和回调                                         |                                                                                                                                             |
| 很少有自己的状态，即使有，也是自己的 UI 状态                     |                                                                                                                                             |
| 除非他们需要的自己的状态，生命周期，或性能优化才会被写为功能组件 |                                                                                                                                             |

## 二、组件实例（反面例子）

### 1. 分享组件

功能：一个弹框，弹出需要分享的类型、有微信好友、朋友圈、链接微信好友、短信、还有海报生产的路由带参跳转。

变量：按钮的类型、分享出去封面的样式、分享出现带的参数（h5 和小程序由于历史原因还是有一些不同的）

![](https://cdn.nlark.com/yuque/0/2020/png/654315/1598714815713-1236debd-6c03-45d9-8b84-4ebc94a046c2.png)

文件结果还是很乱的，这是由于本来最外层只有一个 index.js，随着开发发现要判断的东西越来越多，所以把他逻辑都拆分了。

- assets: 常量、参数的封装、工具库
- images: 图片库
- renders: 业务组件夹，三种分享类型的不同的封面样式和一个分享标题的组件
- styles: 样式库
- Contianer: 容器组件，把组件的三个部分的组件都包含在外
  - ButtonMain
  - CoverView
  - TitleVIew
- index.js: 逻辑组件，所有逻辑的操作都在这里，参数的封装太多分离到了 assets 中
- ShareWechat: 封装的原生微信 SDK 分享

**容器组件：**

![](https://cdn.nlark.com/yuque/0/2020/png/654315/1598715361734-9c8c5a97-26e7-4b4c-b0d1-b3e90ca8d78e.png)

**逻辑组件（智能组件）**:

![](https://cdn.nlark.com/yuque/0/2020/png/654315/1598715567256-1e69d9fd-1f6b-42fd-ab83-db33cc0e6faf.png)

通过容器组件爆出的 props 来进行控制容器组件的逻辑。

### 2. 页面组件

![](https://cdn.nlark.com/yuque/0/2020/png/654315/1598715672704-f98b40f9-ea83-4471-984c-07d672fa9dd8.png)

- index: 主页功能
- pages：该房地产功能的其他页面
- componet: 该功能的公共组件
- renders: 主页的业务组件，由于主页内容太多分离出去的

![](https://cdn.nlark.com/yuque/0/2020/png/654315/1598716061847-99777b5f-c6ed-4e88-89b8-c89168fcff68.png)

即使分离来页面的各个功能，但是单单是这样引入依旧够多且长的。本来这个是我想要再分离出去。但是一想到要 props 这么多参数，反而影响来可读性。所以这个组件超过来 500 行代码。**写代码的时候，不管碰到了什么问题，如果影响到了可读性，而自己会一时半会没想到怎么解决，或事件来不及的时候。永远要选择可读性。**

### 3. 对于组件中方法的复用。

```javascript
<shareModule ref={(ref) => (this.shareModuleHandle = ref)} />;
// ...
test = () => {
  this.shareModuleHandle.manHdele(); //
};
```

**通过 ref 就可以暴露出组件中的方法来给予别的组件进行使用。**

---

## 三、其他心得

之前我一直认为 代码的重复是罪恶的，是让人唾弃的！ 但是看了知乎这篇文章，我发现我好像偏离的轨道，代码的封装是为了代码更容易的去维护。有一种幡然醒悟的感觉。醍醐灌顶一般！

[前端写代码真的有必要封装太好么? - 知乎](https://www.zhihu.com/question/397593209/answer/1257454291)

觉得很好的两个问题：

1. 人的精力是有限的，多考虑大的价值。  
   我现在在面对这么封装，是否应该封装的过程中，耗费的时间确实不少，这样是否是对的呢？肯定不是坏的，但是是否是现阶段最有意义的呢？
2. 你现在写的代码，不管公司怎么样，只要你还在写，那么你就要对自己写的代码负责。“你写的项目，你做的项目很有可能在下一个季度交给另外一个人维护，我希望接受代码的人不会在背后骂你”，多想想你未封装的代码会对他人维护带来困扰吗？
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[组合式API：依赖注入]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Vue/组合式API：依赖注入</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Vue/组合式API：依赖注入</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[组合式 API：依赖注入  参考质量 组合式 API：依赖注入  基础使用 父级组件如下： js <template> 	<button @click='addCount'>Add Count</button> 	<inject /> </template> <script setup> import { provide } from 'vue' const count = ref(0) provide('ProvideCount', count) const addCount = () => { 	count.value++ } </script> 自己组件中如下： js <template...]]></description>
            <content:encoded><![CDATA[# 组合式 API：依赖注入

## 参考质量

[组合式 API：依赖注入](https://cn.vuejs.org/api/composition-api-dependency-injection.html)

### 基础使用

父级组件如下：

```js
<template>
	<button @click='addCount'>Add Count</button>
	<inject />
</template>
<script setup>
import { provide } from 'vue'
const count = ref(0)
provide('ProvideCount', count)
const addCount = () => {
	count.value++
}
</script>
```

自己组件中如下：

```js
<template>
	{{ count }}
</template>
<script setup>
import { inject } from 'vue'
const count = inject('ProvideCount')
</script>
```

只要是处于这个分支节点下的子节点，无论层级多么深，都可以通过通过绑定一样的`key`拿到传递下来的参数，这个参数可以是基础类系、而可以是引用类型、也就是说包括函数。

### 优化 key 值的绑定

key 值如果只是通过字符串来区分，是存在混淆的可能的，所以我们通过`contants.ts`的常量作为 key 值。

```js
// contans.ts
export const COUNT_SYMBOL = symbol("provide 组件中的 count 哦");
```

在`provide.vue` 中：

```js
<template>
	<button @click='addCount'>Add Count</button>
	<inject />
</template>
<script setup>
import { provide } from 'vue'
import { COUNT_SYMBOL } from './contants'
const count = ref(0)
provide(COUNT_SYMBOL, count)
const addCount = () => {
	count.value++
}
</script>
```

然后在`inject.vue` 中引入这个常量即可。

### 扩展使用

```js
<script setup>
import injectChild from './injectChild.vue'
</script>
<template>
  <provide>
	<template #test>
	  <injectChild />
	</template>
  </provide>
</template>
```

`provide.vue`:

```js
<script setup>
import injectChild from './injectChild.vue'
</script>
<template>
	<div>
	    <slot name="test" v-if="hasTestSlot()">
	      <h2>默认插槽</h2>
	    </slot>
  </div>
</template>
```

`injectChild.vue`

```js
<template>
  <h3>这个是插槽</h3>
  <p>{{ name }}</p>
  <p>{{ nickName }}</p>

  <el-button @click="changeAge">改变年龄</el-button>
</template>
<script setup>
import { inject } from "vue";
import { nameKey, handleChangeAge } from "./constans";
import { ElButton } from "element-plus";

const name = inject("name");
const nickName = inject(nameKey);

const changeAgeInject = inject(handleChangeAge);
const changeAge = () => {
  changeAgeInject(20);
};
</script>
```
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[垃圾回收机制]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/brower/垃圾回收机制</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/brower/垃圾回收机制</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[我们为什么需要了解 作为前端，和 GC 强相关就是内存泄漏场景、调试工具、基础优化策略，这就是需要我们理解可达性、分代回收概念，以及熟练使用 DevTools 分析内存。  为什么需要 GC GC 就是垃圾回收的缩写。下面统一使用 GC 来指代垃圾回收。 众所周知，应用程序在运行过程中需要占用一定的内存空间，且在运行过后就必须将不再用到的内存释放掉，否则就会出现下图中内存的占用持续升高的情况，一方面会影响程序的运行速度，另一方面严重的话则会导致整个程序的崩溃。 我们可以通过 Dev Tool 的 Performance 来直观的观察到内存的改变，在页面加载完毕之后，正常的应该如下，线条在没有控...]]></description>
            <content:encoded><![CDATA[## 我们为什么需要了解

作为前端，和 GC 强相关就是内存泄漏场景、调试工具、基础优化策略，这就是需要我们理解可达性、分代回收概念，以及熟练使用 DevTools 分析内存。

## 为什么需要 GC

GC 就是垃圾回收的缩写。下面统一使用 GC 来指代垃圾回收。

众所周知，应用程序在运行过程中需要占用一定的内存空间，且在运行过后就必须将不再用到的内存释放掉，否则就会出现下图中内存的占用持续升高的情况，一方面会影响程序的运行速度，另一方面严重的话则会导致整个程序的崩溃。

我们可以通过 Dev Tool 的 Performance 来直观的观察到内存的改变，在页面加载完毕之后，正常的应该如下，线条在没有控制界面之后会趋于直线。

<img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/0c66a19062d84bbda286d89129595ec9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756124349&x-orig-sign=yB3a6eYAmxhFUy%2Fy1tJDJNorVxY%3D" alt="图片.png" width="70%">

如果真的存在内存的问题，我们可以通过点击

<img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/662000b355f24a6c8d37bb8cafd48b73~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756124349&x-orig-sign=oDs%2BHPEWxPkd1R3IWgskJpdJfXw%3D" alt="图片.png" width="20%">

中间的圆圈键进行持续性的观察，得到下面的这张图，js heed 持续性的上升。

![图片.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/a797bb047f2e49cbaed2ef87b1090cad~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756124349&x-orig-sign=TCBTdpeCPARbEh3I76mr%2BK3OqYs%3D)

## GC 是如何解决这些问题的

我们要了解 GC，就要了解 GC 作用的对象：内存。内存的管理和编程语言无关，基本都生命周期都是一样的：

1.  分配程序需要的内存
2.  使用分配到的内存
3.  把不需要的内存给回收了

GC 主要作用于第三点，识别不需要的内存，如何回收这些不需要的内存。

### 全停顿

在理解 GC 之前，还有一个重要的概念，“全停顿”。

GC 运行的时候，会阻塞 JS 主线程的运行。虽然不会影响到 Web Worker 的运行，它运行在独立的子线程中，但是到运行结束，把数据返回到主线程的时候依旧会受到影响。

> Web Worker 有自己的 GC

全停顿是为了解决数据不一致的问题，以经典的饭店作为场景来描述。你还没有吃完饭，只是临时起来去上一个厕所，这个时候服务员看到座位上没有人了，就以为桌面上的饭已经没有人吃了，所以就收拾了，等你上完测试，面对空空如也的桌面，只能干瞪眼。 这个是因为服务员和你对于同一个场景的理解是不一致的，导致服务员做的事情不符合我们的预期。为了解决这个问题，就需要同一时间只有做一件事情。GC 运行的时候，JS 不要运行。

> 除了 GC 的时候回全停顿，在 DOM 渲染的时候（script 标签的加载），同步的 API（alert、confirm），DOM 的重排和重绘等，都会出发全停顿。

### 解决的目标（什么对象是垃圾）

GC 的实现思路每个高级语言基本都是一样的：**确定哪个变量不会再使用，然后释放它占用的内存**。

什么样的变量是不会再被使用的，有如下情形：

- 对象不在被引用
- 对象不能从根上访问到

### 解决的方案（GC 算法）

GC 的算法是为了判断什么对象是垃圾的问题。常见的有如下四种：

- 引用计数
- 标记清楚
- 标记整理
- 分代回收

#### 引用计数

属于 GC 算法一个过去的算法，现在不再使用。它的实现思路是，在声明变量的时候给它赋一个引用值，这个值的引用数为 1。如果这变量又赋值给了另外一个变量，那么它的引用数就加一，当引用数为 0 的时候，就可以安全的回收其内存。

但是在循环遍历的场景中就无能为力了，如下代码中：

```js
function fn(a, b) {
  a.pre = b.next;
  b = a;
}
```

a 和 b 相互引入，它们的引用数都是 2。计数算法就无法判断对象的是否应该进行清除回收。而且当对象大了之后，需要给这个计数开辟的内存空间也是一个不小的花销。

#### 标记清除（mark-and-sweep）

实现思路：分标记和清除两个阶段完成。

1.  遍历所有对象找标记活动对象
2.  遍历所有对象清除没有标记对象
3.  回收相应的空间

快速回收内存。最大的优点可以回收循环引用的对象，是 V8 引擎使用得最多的算法。具体的标记方法对于学习语法规范的而言不重要，有很多方法，并且随着 v8 版本的更新一直都有在优化和更新。我们可以通过“活动”这个字眼可以看出来它的含义。比引用计数更加的大，但是它也不是没有缺点，如下图：

![图片.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/0bf74df0ec8b429bb3b1c563eb9a0bbf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756124349&x-orig-sign=zoXMYB2Ll%2FK3trq5svSVK9WpM14%3D)

红色区域是一个根对象，就是一个全局变量，会被标记；而蓝色区域就是没有被标记的对象，会被回收机制回收。这时就会出现一个问题，表面上蓝色区域被回收了三个空间，但是这三个空间是不连续的，当我们有一个需要三个空间的对象，那么我们刚刚被回收的空间是不能被分配的，这就是“空间碎片化”。

#### 标记整理

为了解决内存碎片，就引入了“标记整理”这一算法。就是在回收垃圾之前添加一个标记整理的操作。如下图：

![图片.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/13367f3e8718484ab57da2a52dd0d99c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756124349&x-orig-sign=PyLS7S0a5K7UYRjlpLmbljglaX0%3D)

基本实现思路为，活动的对象放在内存的一边，非活动的对象字段就在另外一遍，这样直接清除另外一边的非活动对象就可以有效解决内存碎片的问题。如下图：

<img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/a35248d2b31844b8aa6693af60cd249f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756124349&x-orig-sign=Yh%2B34spANN4pLy%2F%2BM7jDcV7vrmI%3D" alt="图片.png" width="70%">

但是这样又会带来新的问题：移动对象，不会立即回收对象，降低了回收的效率。

#### 垃圾回收策略

##### 增量标记（incremental Marking）

为了减少全停顿的时间，`V8`对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。

<img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/7fb9d209aed74cbbab61ce98ca7dd4f2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756124349&x-orig-sign=mGq9TpiYSmqk%2BBu2zqgAF%2Fggceo%3D" alt="图片.png" width="70%">

##### 分代回收

上面属于回收的算法，而分代回收属于回收的策略。主要思路是。将内存分为新生代和老生代，分别采用不同的算法，最大限度的优化垃圾回收的过程。

（1）新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。\
（2）老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。

两者空间的主要差别分配到到的内存是不一致的。

| 类型   | 64 位  | 32 位 |
| ------ | ------ | ----- |
| 老生代 | 1400MB | 700MB |
| 新生代 | 64MB   | 16MB  |

可以明显看他们的差距是非常大的，这也直接导致了两者空间使用到的 GC 算法的侧重点不同。

###### 回收新生代对象

主要使用标记整理算法和 Scavenge 算法，Scavenge 算法主要是将新生代中开辟为 From 和 To 两个空间，内存对半分。如下图：

<img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/87d88ab7b5be46a896d7d5e500855f67~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756124349&x-orig-sign=yMHiGMqZxYUH8%2B%2FqLt7XhSm6HAQ%3D" alt="图片.png" width="70%">

新生代中的内存回收发生在 From 空间中，过程如下：

1.  GC 一遍之后，检查在 From 空间，清空不活动的内存
2.  活动的对象判断是否符合晋升的机制，符合就复制到老生代空间中，其余复制到 To 空间中
3.  From 被清空之后，To 空间作为 From 空间，原本的 From 就作为 To。即 From 和 To 空间的翻转。

上面提到的 From 晋升到老生代空间的条件有如下两个：

1.  已经经过一轮 GC 了
2.  To 中的内存空间使用量超过 25%​

设计的原因分别如下：

1.  新生代假设“大多数对象生命周期短暂”，因此经历两次回收仍存活的对象更可能长期存在，适合转移到老生代进行更高效的管理
2.  Scavenge 回收完成后，​**​To 空间会变为下一次分配的 From 空间 ​**​。若 To 空间占用过高（如超过 25%），剩余空间不足以容纳后续新对象分配，会导致频繁触发垃圾回收或内存分配失败。通过直接晋升对象，可避免这一问题 ​

总结整个过程如下图：

<img src="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/f6bbf251055d44558027757367e549a2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756124349&x-orig-sign=%2Fim9i41UozPJqUrSWWuYIuJdM%2Bo%3D" alt="图片.png" width="60%">

## 性能和 GC 的关系

垃圾回收机制是我们应用层上需要关注的语法规范，但是 ES6 的 WeakMap 和 WeakSet 这类的语法规范也定义了内存管理的逻辑约束，没有修改 GC 的实现逻辑。

GC 的过程属于一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是不能完全解决的。

这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。

这就是为什么 WEB 项目中在有了 GC 情况下，依旧会出现了内存泄露的问题。

### 内存泄露

当内存持续的增长，对象和变量没有被及时的垃圾回收就会造成内存泄露。

我们一般会说造成内存泄露的有如下六种情况：

#### 1. 全局变量滥用

问题：

```js
function leak() {
  globalVar = "未声明的全局变量"; // 隐式全局变量
  this.anotherGlobal = "this 指向全局对象"; // 在非严格模式下，this 指向 window
}
```

Vue3 默认或推荐启用严格模式，这个问题大复减弱。但是依旧存在一些全局的应用，比如全局使用的缓存。

```js
windows.cache = new Map();
```

全局的变量可以统一使用`WeakMap`进行处理。

#### 2. 闭包未及时清理

现代项目中，模块化的开发，这个问题基本不存在。但是仍然存在使用定时器实现的闭包依旧存在可能的问题：

```js
export function useTimer() {
	const data = ref('yoran')
	setInterval(() => console.log(data.value). 10000)
	return { data }
}
```

#### 3. 未清理的事件监听器与第三方库资源 ​

- ​**​DOM 事件监听器 ​**​\
  即使使用 Vue 模板语法（如 `@click`），若 ​**​ 手动绑定事件 ​**​（如通过 `addEventListener`）且未在 `onUnmounted` 中解绑，仍会泄漏

- ​**​ 第三方库实例未销毁 ​**​\
  如 ECharts、WebSocket 或地图 SDK，需在组件卸载时手动调用 `dispose()` 或关闭连接

#### 4. 未清除的定时器与异步任务 ​

不用多说

#### 5. 残留的 DOM 的引用

手动操作 DOM 并缓存引用时，即使元素被移出 DOM 树，JavaScript 对象的强引用仍会阻止其回收：

```javascript
const elements = [];
elements.push(document.getElementById("my-element")); // 强引用导致无法回收
```

### 静态分配

为了压榨浏览器,一个关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。

GC 虽然是**自动周期性的执行**，但是开发者也是有一些操作可以控制这周期的到来。

**浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。** ，如下面的代码片段：

```js
const obj = [];
for (let i = 0; i < 10000; i++) {
  const item = { count: i };
  obj.push(item);
}
```

在循环中会频繁的使用创建和注销 item 对象，当 JS 运行时存在频繁的创建和注销的对象的时候，JS 引擎就会自动的调用 GC ，频参照\[\[全停顿]]的改变，频繁的调用 GC 会阻塞 JS 的运行，对性能造成明显的影响。

为了解决这个问题，我们可以先创建一个确定长度的对象，然后修改这个对象数组上面的元素。

```js
const obj = Array.from({ length: 10000 }, () => ({
  count: null,
}));

for (let i = 0; i < 10000; i++) {
  obj[i].count = i;
}
```

这样就可以避免频繁的创建销毁变量，直接减少 GC 的调用，达到性能优化的效果。

还有一个常见的场景：

```js
const fn = (a, b) => {
  const obj = {};

  obj.x = a.x + b.x;
  obj.y = a.y + b.y;
  return obj;
};
```

这个代码片段和《红宝书》4.3.4 例子相似，如果这个函数是被频繁的调用的话，也会影响 JS 对象的的更替速度。我们可以修改如下：

```js
const fn = (a, b, obj) => {
  obj.x = a.x + b.y;
  obj.y = a.y + b.y;
  return obj;
};

const a = { x: 1, y: 2 };
const b = { x: 3, y: 4 };
const c = fn(a, b, {});
```

### 隐藏类和删除操作

代码非常注重的性能的话，才需要考虑隐藏类和删除操作。一般来说，如果两个变量都使用同一个构造函数来 new 的话，它们就拥有同一个隐藏类，因为他们共用同一个原型。如下代码片段：

```js
function Persion(height = 0) {
  this.height = height;
}

const a = new Person();
const b = new Person();
```

a 和 b 有同一个隐藏类。但是当`a.name = 'yoran'`添加一个 Persion 不存在的 name 的时候，浏览器就会给 a 和 b 创建两个不同的隐藏类。即使他们都是有同一个构造函数。

同理的，如果对生成的对象进行删除对象元素的操作也是如此。

```js
function Persion(height = 0) {
	this.height = height
}

const a = new Person()
const b = new Person()

delect a.height
```

为了极致的性能的话，最佳实践如下：

```js
function Persion(height = 0, name) {
  this.height = height;
  this.name = name;
}

const a = new Person("yoran");
const b = new Person();

a.height = null;
```

1.  构造函数的上下文变量一次性声明所有可能需要的属性，避免“先创建再补充”
2.  对于需要的属性，定义将它置于`null`

## 总结

1.  内存管理的生命周期部分程序语言，都是分配内存 -> 使用内存 -> 释放内存。
2.  GC 执行的时候，会阻塞 JS 主线程的运行；此时不会影响 Web Worker 的运行， 它有自己独立的子线程。
3.  现代 GC 的主要使用到两种算法：标记清除算法和标记整理清除算法。执行的算法策略有两种：增量标记算法和分代回收算法。
4.  新生代空间和老生代空间由于分配到的内存的不同，直接影响算法的使用策略。
5.  GC 性能优化的关键在于减少 GC 的频繁调用。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[浏览器缓存机制]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/brower/浏览器缓存机制</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/brower/浏览器缓存机制</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[浏览器缓存机制 -  所谓机制,就是说有这么一套规则来束约缓存的逻辑. 束约的工具是浏览器内部实现的. 束约的参数就是我们 [[HTTP和HTTPS协议]]的报文内容. 结果就是用户看到的资源. - 所以说我们在讨论的浏览器缓存机制的时候,就是在讨论[[HTTP报文]]中的某些对应字段的发挥的作用, 辅以一套处理这些字段的逻辑. - 这套处理的逻辑可以分为两种[[强制缓存]]和[[协商缓存]]  强制缓存 - 在 http1.0 时代,通过配置expires相应头的属性,设置过期的时间,只要超过这个时间,资源就从服务器上获取.反之就从本地获取. - 很简单,但是问题也很多   - 对本地时间...]]></description>
            <content:encoded><![CDATA[# 浏览器缓存机制

-  所谓机制,就是说有这么一套规则来束约缓存的逻辑. 束约的工具是浏览器内部实现的. 束约的参数就是我们 [[HTTP和HTTPS协议]]的报文内容. 结果就是用户看到的资源.
- 所以说我们在讨论的浏览器缓存机制的时候,就是在讨论[[HTTP报文]]中的某些对应字段的发挥的作用, 辅以一套处理这些字段的逻辑.
- 这套处理的逻辑可以分为两种[[强制缓存]]和[[协商缓存]]

## 强制缓存

- 在 http1.0 时代,通过配置`expires`相应头的属性,设置过期的时间,只要超过这个时间,资源就从服务器上获取.反之就从本地获取.
- 很简单,但是问题也很多

  - 对本地时间戳过分的依赖,如果客户端本地的时间和服务器的时间不一致的话,那么缓存过期的判断就无法和预期相符

  - > 浏览器中的这个时间叫做格林威治时间

- 所以为了解决这个问题. 在 http1.1 时代,出现了`cache-control`字段. 其中的`max-age`属性就是对于`expires`的补充.
  - 不是进行替代,而是补充.`expires`因为简单依旧存在它的使用场景

**如下配置, 单位是秒:**

```JavaScript
res.writeHead(200m {
  "Cache-control": "max-age:5"
})
```

    - 这个`max-age`的含义超过相对时间. 每一次刷新都更新初始化时间，类似防抖函数的作用，当你渲染界面之后的 5 秒钟内，都是可以从缓存中拿到数据的。一旦渲染界面之后，再超出 5 秒钟才再点击拿资源的话，就会重新从服务器上面拿该资源。
    - 很多时候还是需要加上`public`属性的. `"public, max-age:5"`的. 含义是: **响应可以被任何对象缓存(包括发送请求的客户端、代理服务器等)**
    - 如果只是使用`max-age`依旧是存在问题的.如果你后台的接口,资源就是在配置的的几秒钟更新了你怎么办?GG了. 所以出现了下面的协商缓存

## 协商缓存

- 协商缓存就要求每次都向服务器要结果. 缓存的有效性决定权交给后台.这样自然缓存存在的意义就很大的问题了.对于这个问题暂时不表,先来看看它是如果进行协商缓存的逻辑处理的.

### last-modified 实现的协商缓存

    - 这是最简单的协商缓存的方案, 根据文件的修改时间来进行判断. 如下配置

    -

```text
res.setHeader('last-modified', mtime.toUTCString())
res.setHeader('Cache-Control', 'no-cache')
```

    - 配置成功了之后, 响应头会生成一个属性 `if-modified-since`. 然后后台再进行如下的判断:

    -

```JavaScript
const ifModifiedSince = req.headers["if-modified-since"];
if (ifModifiedSince === mtime) {
  // 缓存生效
  res.statusCode = 304;
  res.end();
  return;
}
```

    - 如此一来,是能够满足绝大多是的场景的. 但是还是有如下的不足:
        - 1. 它只是根据时间戳来进行判断,如果只是改变了文件名,而实际内容没有任何改变的情况下,还是会进行服务器的请求拿取.这实在是太蠢了.
            1. 它的单位是秒.如果修改文件的速度非常快,在一些自动化文件处理中.在几百毫秒就完成了.那么它的单位就没有办法通过验证了.
    - 所以为了解决这两点问题, HTTP1.1在随后更新版本中提供`etag`响应头字段来处理

### ETag 实现协商缓存

    - 处理逻辑和`last-modified`基本一致

```JavaScript
const etag = require("etag");

const data = fs.readFileSync("./img4.png");
const etagContent = etag(data);

const ifNoneMatch = req.headers["if-none-match"];

if (ifNoneMatch === etagContent) {
  // 缓存生效
  res.statusCode = 304;
  res.end();
  return;
}

res.setHeader("etag", etagContent);
res.setHeader("Cache-Control", "no-cache");
res.end(data);
```

    - etag 表示的是对文件内容的解析进而生成的一个 id，只要文件内容有了改变才会进行变更。自然就能够改变last-modified的两点的不足。它是对其的一个补充方案，而不是替代方案。
    - etag 依旧带来了新的问题:
        - 1. 服务器生成文件资源 Etag 需要付出额外的计算开销，如果资源尺寸比较大，数量较多且修改比较频繁的话，那么生成 Etag 的过程显然会印象服务器的性能。
            1. Etag 字段值的生成两种类型，一种是强验证，即更具资源内容的每一个字节来进行验证，最可靠，性能消耗也最大。相对应的就是弱验证，它使用资源内容的部分的属性值来进行生成，生成速度快，但是没有办法很高的成功率。尤其是在服务器集群场景下。
    - 所以说不管哪种缓存方式都有不足,结合具体的场景使用才是正确对待它们的方式. 一般来说,`etag`和`last-modified`都是使用的. 所以说对于它们的使用还有一个优先级的问题.

### ETag 和 Last-Modified 的优先级

    - 一般来说,默认配置的话. 是先进行`etag`的判断的,如果返回的是true的话,再判断`last-modified`.
    - 当然这个可以后台自己实现自己喜欢的策略.

### 协商缓存过程的简单总结

    - 可以总结如下图

    ![](https://secure2.wostatic.cn/static/uAtCi1KDZYYPijhV37Uqb2/image.png?auth_key=1755803199-icU1rsNaTFbg4viRzkW6oo-0-304ce8cebaee3474c3a8b5dd9b925d99)

## 其他相关配置的豹纹字段

- Paragma: no-cache(响应头) HTTP/1.0 版本的字段
- Cache-Control: 也是操作缓存的.是 HTTP/1.1 版本字段,向下兼容的,所以说 Paragma 还是存在的. Cache-Control 的优先级是比前者高的.
- Expires: Mon, 15 Aug2016 03:56:47 GMT(格林威治时间)
- 在 HTTP/1.1 使用 Cache-control 中的 max-age 来代替
- Cache-Control 的相关属性
  - no-cache: **忽略缓存在本地的副本,强制从服务器上拿资源**
  - no-store: **强制缓存在任何情况下都不要保留任何副本**
  - max-age=314600: 知识缓存副本的有效时长,从请求时间开始到过期时间之间的描述
  - public: 表明响应可以被任何对象缓存(包括:发送请求的客户端、代理服务器等)
  - private: 表明响应只能被耽搁用户缓存,不能作为共享缓存(即代理服务器不能缓存它)

## 我们前端需要做些什么

这里是熟悉前端工程话的知识点了.很多 [[Webpack基础]]已经帮我们做了. 我们只需要进行进行对应的配置就可以了. 比如说,修改每次打包都修改生成的入口文件的文字

```text
entry:{
    main: path.join(__dirname,'./main.js'),
    vendor: ['react']
},
output:{
    path:path.join(__dirname,'./dist'),
    publicPath: '/dist/',
    filname: 'bundle.[chunkhash].js'
}

```

- `chunkhash`就代表出口文件没有打包都会生层对应的 hash 值. 还有另外两个值可以替换它.`hash`、`contenthash`
- 三者的差别可以用一句话来概括:
  - `hash` 计算和整个项目的构建相关
  - `chunkhash`计算同一 chunk 内容相关
  - `contenthash`计算和文件内容本身相关
- 详情可以自己尝试一下.看官网.
- 还有一些前端世界常听到的:
  - html 使用协商缓存
  - css、js、静态资源 使用强缓存,文件名带上 hash 值

## 用户行为对浏览器缓存的影响

- 1. 打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
- 2. 普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
- 3. 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache),服务器直接返回 200 和最新内容。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[样式覆盖问题解决]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/微前端/样式覆盖问题解决</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/微前端/样式覆盖问题解决</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[微前端样式覆盖问题解决  一、背景 现在没有哪家公司不使用微前端来进行作为项目的组织架构了。 但是这个东西的出现也带来了新的问题。 比如说各个业务团队使用的 UI 框架不一样的时候，就会导致如下这样的样式污染。 !image.png 样式的污染，css-scoped 或者 css module 解决了绝大部分，但是对于多子应用同时加载，主子应用之间的冲突，导致了所有的弹窗样式都是有问题的。  二、解决方案  使用 qiankun 沙盒模式隔离 这是一个坑。神光最近也写过相关的文章，想要详细的了解，可以自寻查找。下面我简单的总结一下： - qiankun 的 css 沙箱的原理是重写 HTMLH...]]></description>
            <content:encoded><![CDATA[# 微前端样式覆盖问题解决

## 一、背景

现在没有哪家公司不使用微前端来进行作为项目的组织架构了。

但是这个东西的出现也带来了新的问题。

比如说各个业务团队使用的 UI 框架不一样的时候，就会导致如下这样的样式污染。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d11950d8419c4a8c9bc23615dc3c8684~tplv-k3u1fbpfcp-watermark.image?)

样式的污染，css-scoped 或者 css module 解决了绝大部分，但是对于多子应用同时加载，主子应用之间的冲突，导致了所有的弹窗样式都是有问题的。

## 二、解决方案

### 使用 qiankun 沙盒模式隔离

这是一个坑。神光最近也写过相关的文章，想要详细的了解，可以自寻查找。下面我简单的总结一下：

- `qiankun` 的 `css` 沙箱的原理是重写 `HTMLHeadElement.prototype.appendChild` 事件，记录子项目运行时新增的 `style/link` 标签，卸载子项目时移除这些标签。

思路就是将子项目的样式局限到子项目的容器范围，不在这个范围样式不生效。但是对于一些弹窗就无能为力了，它们需要挂载到 `body` 上面，不在子应用容器中，样式就无法生效。

- 使用换肤的思路来解决 ：在子项目给 `body` 加一个唯一的 `id` 或`class`），在对应的全局的样式前面加上这个 `id/class`。而 `single-spa` 模式则在 `mount` 周期给 `body/html` 加上这个唯一的 `id/class`，在 `unmount` 周期去掉，这样就可以保证这个全局 `css` 只对这个项目生效了。

这两个方案的致命点都在于无法解决多个子项目同时运行时的 `css` 污染，以及子项目对主项目的 `css` 污染。

这两个方案已经能够把绝大多数问题解决。但是我们的项目中，是有一个看板的业务的。看板的业务就会把多个子应用同时加载。如果使用上面的两种方案，那么谁的包大，谁加载得慢，那么 body 的 id/class 就归谁的。物尽天择？

### 添加自定义命名空间

如果使用了 element plus 版本的简单很多了。2.20 版本以上的，详情可以点击[https://element-plus.gitee.io/zh-CN/guide/namespace.html#设置-elconfigprovider](https://element-plus.gitee.io/zh-CN/guide/namespace.html#%E8%AE%BE%E7%BD%AE-elconfigprovider)

核心代码如下：

```
// styles/element/index.scss
// we can add this to custom namespace, default is 'el'
@forward 'element-plus/theme-chalk/src/mixins/config.scss' with (
  $namespace: 'ep'
);
// ...
```

### 使用 postcss-plugin-namespace 插件添加自定义命名空间

其他版本就需要借助插件来实现自定义命名空间了。有很多可以实现相同功能的插件，下面我以插件为例子。

```
npm i postcss-plugin-namespace -D
```

在根目录创建`postcss.config.js` 文件。

```
module.exports = (ctx) => {
  return {
    plugins: [
      require('postcss-plugin-namespace')('#lee_project', {
        ignore: [
          'html', /body/, 'span', 'el-form-item', /[data/,
        ]
      }),
    ]
  }
}
```

ignore 顾名思义就是忽略的 class,也可以使用正则，如 `/body/` 。里面有一个 data，这是使用了 style scroped 之后，会给节点上面添加 data-xxxx 。所以它也需要忽略掉。

### 直接覆盖样式

我劝你不要冲动，这是我们统计一部分样式污染的 class 名称：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91142fee4c644af0ae06e3e46e5ce9ea~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="30%" />

主应用使用了和子应用不同的 UI 框架。我们为了让样式在加载我的应用的时候，需要全局复写上面的这些 class 名，并放在全局。

上面这些污染的 class 只是冰山一角哦，可自行评估一下需要多少工时。

## 三、容易疏忽的问题

字体属于静态资源。项目肯定是开启了协商缓存的。所以说，加载过之后的静态资源也是会污染全局的。而这个时候我们就需要处理两个问题。

### 自己从 iconfont 中下载下来的字体图标

直接修改 iconfont 的前缀即可。如下图配置：

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ede642e497242fbb39e814a551b9dff~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="50%" />

### element ui 内置的图标

并没有搞明白为什么什么的插件没有自动添加修改前缀。所以我们使用了最暴力的解决办法。不用 element ui 内置的图标，全部替换成 iconfont 的。问题解决就行。

这是因为我们项目的图标很少，所以能够这样干。如果你项目中有大量的图标的话，还是想想怎么使用插件来解决吧。解决了求求教教我。求求了！

改为使用 **按需引入** 问题即可解决。

## 四、总结

- 编程没有银弹，引入的 qiankun 解决了多团队协作的问题，也带来了新的问题。但是也要有我们在做技术选项的时候要有这样的心理预期。
- 自定义命名空间本质依旧是约定样式规范。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[内置组件]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Vue/内置组件</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Vue/内置组件</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[内置组件  参考资料 - Transition - TransitionGroup - KeepAlive - Teleport - Suspense  Transition & TransitionGroup 它的使用没有比官网更加的清晰了。 html <Transition   name="fade"   @before-enter="beforeEnter"   @after-enter="afterEnter"   @before-leave="beforeLeave"   @after-leave="afterLeave" > </Transition> css / 进入阶段：从隐藏...]]></description>
            <content:encoded><![CDATA[# 内置组件

## 参考资料

- [Transition](https://cn.vuejs.org/api/built-in-components.html#transition)
- [TransitionGroup](https://cn.vuejs.org/api/built-in-components.html#transitiongroup)
- [KeepAlive](https://cn.vuejs.org/api/built-in-components.html#keepalive)
- [Teleport](https://cn.vuejs.org/api/built-in-components.html#teleport)
- [Suspense](https://cn.vuejs.org/api/built-in-components.html#suspense)

## Transition & TransitionGroup

它的使用没有比官网更加的清晰了。

```html
<Transition
  name="fade"
  @before-enter="beforeEnter"
  @after-enter="afterEnter"
  @before-leave="beforeLeave"
  @after-leave="afterLeave"
>
</Transition>
```

```css
/* 进入阶段：从隐藏到显示 */
.fade-enter-from {
  opacity: 0;
} /* 初始状态 */
.fade-enter-to {
  opacity: 1;
} /* 目标状态 */

.fade-enter-active {
  transition: opacity 1s;
} /* 过渡动画 */

/* 离开阶段：从显示到隐藏 */
.fade-leave-from {
  opacity: 1;
} /* 初始状态 */

.fade-leave-to {
  opacity: 0;
} /* 目标状态 */

.fade-leave-active {
  transition: opacity 0.3s;
}
```

如果没有`name`的话，就默认以`v-`作为 class 的前缀。

## 生命周期如下

![](../../assets/posts/Pasted%20image%2020250814174646.png)

## Transition 和 TransitionGroup 的区别

```html
<TransitionGroup name="fadeTransform">
  <div v-for="item in list" :key="item">{{ item }}</div>
</TransitionGroup>
```

`TransitionGroup`可以作用于每一个 div，而`Transition`只能作用于一整个 Div。

## Teleport

### 父子组件使用 Teleport 的问题

存在无法正确插入到引入的父组件的位置上面，警告信息如下：

**_[Vue warn]: Failed to locate Teleport target with selector "#body". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree._**

这个是由于 vue3 的生命周期，父组件的 onMounted 在子组件渲染之后。所以我们只需要确保父组件上面要挂载的组件在`Teleport`中组件之前渲染就可以了。

```html
<Teleport to="#body" v-if="hasTargetElement">
  <div>teleport 组件</div>
</Teleport>
```

```js
const hasTargetElement = ref(false);
onMounted(() => {
  hasTargetElement.value = !!document.querySelector("#body");
});
```

上面可以处理在同一个生命周期之中，把`onMounted`换成`nextTick`也是一样的。

但是如果想要挂载的 dom 和当前的`Teleport` 不在同一个生命周期的话，那么就需要监听目标 Dom 什么时候渲染的，方法如下：

```js
const targetElement = ref(null);
// 检查目标元素的辅助函数
function checkTargetElement() {
  const element = document.querySelector("#body");
  targetElement.value = element;
}
watchEffect(() => {
  const timer = setTimeout(() => {
    checkTargetElement();
  }, 100);
  return () => {
    clearTimeout(timer);
  };
});

const showTeleport = computed(() => {
  return !!targetElement.value;
});
```

**_setTimeout 可以换成 MutationObserver 监听目标元素的变化或者 inject ，等等_**
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[响应式API：基础]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Vue/响应式API：基础</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Vue/响应式API：基础</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[响应式 API：基础  参考资料 - ref() - computed() - reactive() - readonly() - watchEffect() - watchPostEffect() - watchSyncEffect() - watch() - onWatcherCleanup()  1. ref 无需多说它的使用，说一个可以对 ref 的初始化和赋值的封装，让它和 react hook 的写法一致。 js const useRef = <T>(value: T): [Ref<T>, (value: T) => void] => {   const targetRef = r...]]></description>
            <content:encoded><![CDATA[# 响应式 API：基础

## 参考资料

- [ref()](https://cn.vuejs.org/api/reactivity-core.html#ref)

- [computed()](https://cn.vuejs.org/api/reactivity-core.html#computed)

- [reactive()](https://cn.vuejs.org/api/reactivity-core.html#reactive)

- [readonly()](https://cn.vuejs.org/api/reactivity-core.html#readonly)

- [watchEffect()](https://cn.vuejs.org/api/reactivity-core.html#watcheffect)

- [watchPostEffect()](https://cn.vuejs.org/api/reactivity-core.html#watchposteffect)

- [watchSyncEffect()](https://cn.vuejs.org/api/reactivity-core.html#watchsynceffect)

- [watch()](https://cn.vuejs.org/api/reactivity-core.html#watch)

- [onWatcherCleanup()](https://cn.vuejs.org/api/reactivity-core.html#onwatchercleanup)

## 1. ref

无需多说它的使用，说一个可以对 ref 的初始化和赋值的封装，让它和 react hook 的写法一致。

```js
const useRef = <T>(value: T): [Ref<T>, (value: T) => void] => {
  const targetRef = ref<T>(value);
  const setTargetValue = (value: T) => {
    targetRef.value = value;
  };
  return [targetRef as Ref<T>, setTargetValue];
};
```

具体的使用的组件中使用如下：

```js
const [count, setCount] = useRef < number > 0;

const addCount = () => {
  const newCount = count.value + 1;
  setCount(newCount);
};
```

很多人都说这样封装造成了代码的冗余，直接操作 count.value 就可以很方便了。非常的有道理，这个只是个人的喜欢而已，个人感觉给封装了一个 setCount 会让 ref 的操作更加的函数式，而不是直接操作这个变量。最大的好处就是**统一通过** `**setCount**`**来更新状态，提高代码的一致性**。

## 2. computed

大多数使用手法如下：

```js
<script setup>
  const count = ref(1) const doubleCount = computed(（） => count.value++)
</script>
```

直接操作 `doubleCount`会报错，它是只读的。

另外一个比较不常用的，我们可以通过点击 `computed`打开它的 TS 类型，官方的例子依有记载，如下：

```js
export declare function computed<T>(getter: ComputedGetter<T>, debugOptions?: DebuggerOptions): ComputedRef<T>;
export declare function computed<T, S = T>(options: WritableComputedOptions<T, S>, debugOptions?: DebuggerOptions): WritableComputedRef<T, S>;
```

利用 TS 的重载功能，支持两种使用方式，第一种就是传入一个 `getter`函数，返回的值为只读。而另外一种是一个 `options`对象，同时支持 `setter`和 `getter`两个函数，通过它的类型名字就可以看出 `writable`，既可写的对象。使用如下：

```js
const ableWrite = computed({
  get() {
    // 读取时: 原始值 * 10
    return count.value * 10;
  },
  set(newValue) {
    // 验证输入是否为有效数字
    if (
      newValue === null ||
      newValue === undefined ||
      isNaN(Number(newValue))
    ) {
      errorMessage.value = "请输入有效的数字!";
      return;
    }

    // 验证通过，清除错误信息
    errorMessage.value = "";

    // 写入时: 新值同步到原始数据
    count.value = Number(newValue);
  },
});
```

例子也是使用 options 的典型使用场景，可以用于数据的校验，和 `customRef`的使用场景是有重合的。但是有不错，`customRef`就是元数据，而 computed 不是，它返回的是另外一个响应式变量来处理。举个如下的 例子：

```js
// 需要额外的ref和watch，不直观
const inputValue = ref("");
const debouncedValue = ref("");

// 防抖逻辑与计算逻辑分离
watch(inputValue, (newVal) => {
  const timeout = setTimeout(() => {
    debouncedValue.value = newVal;
  }, 300);
  return () => clearTimeout(timeout);
});

// 基于防抖后的值计算
const computedValue = computed(() => debouncedValue.value.toUpperCase());
```

同样是需要防抖的功能，翻阅[进阶 API](https://www.yuque.com/xiaoganju-ynq12/ypvc5e/gisghexpqziklrry "进阶 API")中的 `customRef`，它操作的更加底层，所以逻辑能够更加的内聚，防抖也是官方给出的典型的例子。

## 3. reactive

同 `ref`。

## 4. readonly

```js
<script setup>
const data = reative({
  count: 0
})
const obj2 = readonly(obj);
const obj3 = readonly({
  cout: 0
})

const handleClick = () => {
  obj.count++;
};
</script>
```

`obj2`依旧是可写。`obj3`才可读。

## 5. watchEffect

值得一提的就是它的 `onCleanup`回调函数的使用。和组件的生命周期非常的相似。

```js
watchEffect(async (onCleanup) => {
  const controller = new AbortController();

  // 注册清理：取消未完成的请求
  onCleanup(() => controller.abort());

  try {
    const res = await fetch("/api/data", {
      signal: controller.signal,
    });
    const data = await res.json();
    // 处理数据...
  } catch (e) {
    if (e.name !== "AbortError") console.error(e);
  }
});
```

等同于

```js
import { onWatcherCleanup } from "vue";
watchEffect(() => {
  onWatcherCleanup(() => {
    /* 清理逻辑 */
  }); // 功能等同 onCleanup
});
```

业务开发中，很很多方法可以实现这样的监听，所以大多数情况我们是禁止使用 `watchEffect`了，它的随意使用给排查问题带来了非常大的问题。团队开发的原则是可读性，而不是方便，所以才有各种规范。

## 6. watch

```js
watch(id, (newId, oldId, onCleanup) => {
  const timer = setInterval(() => console.log("Running"), 1000);
  onCleanup(() => clearInterval(timer)); // 注册清理函数
});
```

和 watchEffect 一致，但是用法更加的内聚，不需要想使用 watchEffect 一样，人工去判断里面到底是哪个响应式变化了引起了问题。

这两个监听 API 最重要的就是 `onCleanup`方法，业务开发中，多用于手动清除一下宏任务，比如 setTimeout 方法等，以及取消请求，如下：

```js
watch(keyword, async (newVal, oldVal, onCleanup) => {
  const controller = new AbortController();
  onCleanup(() => controller.abort()); // 依赖变化时取消旧请求
  const data = await fetch(url, { signal: controller.signal });
});
```

在 input 输入框中，连续输入需要中断上一次请求。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[响应式API：工具]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Vue/响应式API：工具</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Vue/响应式API：工具</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[响应式 API：工具  参考资料 - isRef() - unref() - toRef() - toValue() - toRefs() - isProxy() - isReactive() - isReadonly() 这些 API 的用法非常的简单，而且通过这些命名就可以知道它们属于可有可无的一些方法。  防御性编程 API - isRef() : 检车某个值是否为 ref。 - isProxy() : 检测某个值是否为reactive、shallowReactive、readonly，以及shallowReaonly。 - isReactive() : 检测某个值是否为reactive...]]></description>
            <content:encoded><![CDATA[# 响应式 API：工具

## 参考资料

- [isRef()](https://cn.vuejs.org/api/reactivity-utilities.html#isref)
- [unref()](https://cn.vuejs.org/api/reactivity-utilities.html#unref)
- [toRef()](https://cn.vuejs.org/api/reactivity-utilities.html#toref)
- [toValue()](https://cn.vuejs.org/api/reactivity-utilities.html#tovalue)
- [toRefs()](https://cn.vuejs.org/api/reactivity-utilities.html#torefs)
- [isProxy()](https://cn.vuejs.org/api/reactivity-utilities.html#isproxy)
- [isReactive()](https://cn.vuejs.org/api/reactivity-utilities.html#isreactive)
- [isReadonly()](https://cn.vuejs.org/api/reactivity-utilities.html#isreadonly)

这些 API 的用法非常的简单，而且通过这些命名就可以知道它们属于可有可无的一些方法。

### 防御性编程 API

- `isRef()` : 检车某个值是否为 `ref`。
- `isProxy()` : 检测某个值是否为`reactive`、`shallowReactive`、`readonly`，以及`shallowReaonly`。
- `isReactive()` : 检测某个值是否为`reactive`、`shallowReactive`。
- `isReadonly()` : 检测某个值是否为`readonly`，`shallowReaonly`。

这种 API 就是典型的类型判断的 API，多用于 Hook 函数中对于传入参数的值得类型的判断，不同的类型使用不同的取值逻辑。

### 灵活性访问 API

- `unref()`：等同于`const a = isRef(b) ? b.value : b` ，是为了拿到 ref 的值的语法糖。
- `toRef()`：将非响应式的变量，基础类系和引用类型都可以，转化为 ref。
- `toRefs()`：针对`reactive` 对响应式对象，让它的对象每一个解耦出来的属性都是 ref。
- `toValue()`: 比 `unref`多出一个转化的情况，可以转化`() => 9` 这样的而 `getter`函数的值。

这一组 API，解决了响应式编程中的核心问题： 保持数据响应性的同时提供更灵活的访问方式。

其他`toRefs()` 典型的用法就是说明这个问题，可以让开发者直接解耦代码而不失去响应式，官网的例子如下：

```js
function useFeatureX() {
  const state = reactive({
    foo: 1,
    bar: 2,
  });

  // ...基于状态的操作逻辑

  // 在返回时都转为 ref
  return toRefs(state);
}

// 可以解构而不会失去响应性
const { foo, bar } = useFeatureX();
```
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[响应式API：进阶]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Vue/响应式API：进阶</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Vue/响应式API：进阶</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[响应式 API：进阶  参考资料(vue3 官网) - shallowRef() - triggerRef() - customRef() - shallowReactive() - shallowReadonly() - toRaw() - markRaw() - effectScope() - getCurrentScope() - onScopeDispose()  前言 官方已经很好的写出了这些 API 是如何使用的，但是没有结合实践的业务场景来说明运用的场景，这个对于我们实际的开发非常的重要，而且在现在离不开大模型的情况下，对于我这种业务开发员来说，广度可能比深度更加的重要。  1....]]></description>
            <content:encoded><![CDATA[# 响应式 API：进阶

## 参考资料(vue3 官网)

- [shallowRef()](https://cn.vuejs.org/api/reactivity-advanced.html#shallowref)
- [triggerRef()](https://cn.vuejs.org/api/reactivity-advanced.html#triggerref)
- [customRef()](https://cn.vuejs.org/api/reactivity-advanced.html#customref)
- [shallowReactive()](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive)
- [shallowReadonly()](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreadonly)
- [toRaw()](https://cn.vuejs.org/api/reactivity-advanced.html#toraw)
- [markRaw()](https://cn.vuejs.org/api/reactivity-advanced.html#markraw)
- [effectScope()](https://cn.vuejs.org/api/reactivity-advanced.html#effectscope)
- [getCurrentScope()](https://cn.vuejs.org/api/reactivity-advanced.html#getcurrentscope)
- [onScopeDispose()](https://cn.vuejs.org/api/reactivity-advanced.html#onscopedispose)

## 前言

官方已经很好的写出了这些 API 是如何使用的，但是没有结合实践的业务场景来说明运用的场景，这个对于我们实际的开发非常的重要，而且在现在离不开大模型的情况下，对于我这种业务开发员来说，广度可能比深度更加的重要。

## 1. ShallowRef

shallow 翻译为浅的，读音：ˈʃæləʊ/，这里的 shallowRef 是浅的引用。

### 1.1 基础使用

```
<template>
  <p>多层级 shallowRef: {{ objShallow.count }}</p>
  <p>shallowRef: {{ count }}</p>
  <button @click='addShallowRefCount1'></button>
  <button @click='addShallowRefCount2'></button>
</template>
<script setup>
  const objShallow = shallowRef({
    count: 0,
  });
  const count = shallowRef(0)
  const addShallowRefCount1 = () => {
    objShallow.value.count++ // 界面没有变化
  }
  const addShallowRefCount2 = () => {
    count.value++ // 界面实时改变
  }
</script>
```

也就是说 `shallowRef`它只收集 root 层级的数据变化，所以 `objShallow.value.count++`在界面没有响应。**换一句话说，就是只监听.value 这个层级的变化**。只是进行依赖收集，而不会监听.value 之后的层级的属性的变化。可以通过如下的方法让它可以在界面渲染：

```
<script setup>
const addShallowRefCount1 = () => {
  objShallow.value.count++ // 和下面的 count.value 在一起就界面就会改变了
  count.value++
}
const addShallowRefCount3 = () => {
  objShallow.value = {
    count: ++objeShallow.value.count
  }
}
</script>
```

Diff 算法用于比较新旧虚拟 DOM 树的差异,发现有变化了就重新更新整个组件

上面的两种方式本质都是触发了组件的重新渲染。`addShallowRefCount3`不用多说，第一个方法是更加的让人错愕。当触发 count.value++的时候会执行 diff 算法，然后 diff 算法发现了差异之后，会重新更新**整个组件。**这个时候 `objShallow.value.count`会渲染最新的值。

对象如此，数组也一样：

```
<template>
  <button @click="pushShallowRef">push shallowRef</button>
  <p>shallowRef: {{ refShallow }}</p>
</template>
<script setup>
const refShallow = shallowRef([1, 2, 3]);
const pushShallowRef = () => {
  refShallow.value[1] = 4444; // ❌
  refShallow.value.push(4); // ❌
};
</script>
```

### 1.2 业务使用场景

#### 1.21 一次性处理大批量的数据

添加下数据

```
<script setup>
const originArray = () => {
  return { items: [{ count: 0 }] }
}
const arrayShallow = shallowRef(originArray())
const addArrayShallow = () => {
  // 插入 1000 个元素到 arrayShallow
  for (let i = 0; i < 1000; i++) {
    arrayShallow.value.items.push({ count: i })
  }
  triggerRef(arrayShallow) // 仅一次更新
}

const arrayRef = ref(originArray());
const addArrayRef = () => {
  let template = { items: [{ count: 0 }] }
  for (let i = 0; i < 1000; i++) {
    template.items.push({ count: i })
  }
  arrayRef.value = template
}
</script>
```

使用 `originArray`函数封装原始数据，是为了之后可能存在初始化的可能性。s

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1754306966587-4647f582-3d60-49ad-9737-60543246b9a7.png)

这个是两个函数的运行时间，并没太大的差别，虽然理论上说 ref 会个嵌套每一个属性添加响应式代理，这样无疑会导致运行时间增加，但是实际的测试等于没有差别，即便数据量添加到 1 万。shallowRef 的优势在于 uptate 的时候，如下代码片段。

```
<script>
const changeArrayShallow = () => {
  const start = performance.now();
  // 高频修改内部属性
  for (let i = 0; i < 10000; i++) {
    arrayShallow.value.items[i].count =
      arrayShallow.value.items[i].count + 1000; // 无响应式开销
  }
  triggerRef(arrayShallow); // 仅一次更新
  const end = performance.now();
  console.log("changeArrayShallow 运行时间: ", end - start);
};

const changeArrayRef = () => {
  for (let i = 0; i < 10000; i++) {
    arrayRef.value.items[i].count = arrayRef.value.items[i].count + 1000; // 无响应式开销
  }
};
</script>
```

运行的结果如下：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1754313858262-123f7b4b-e552-4267-93f5-7e2f54de49ba.png)

使用 Ref 的 更改数据的用时是 25ms，而使用 ShallowRef 的是 0.7。应该它只更新一次数据，而 Ref 触发了 10000 次的。**本质创建 10000 个响应式代理与创建 1 个响应式代理的性能差异巨大。**

但是 只使用 ref 不可以实现 shallowRef 一样的性能效果吗？它性能提升的主要是 shallowRef 在数据改变之后，再进行一次的响应式触发，所以我们只需要讲 ref 也改为响应式触发就可以了。

具体如下：

```
<script>
  const changeArrayRefOptimized2 = () => {
  const start = performance.now();

  // 获取原始对象
  const rawData = toRaw(arrayRef.value);

  // 直接修改原始对象（无响应式开销）
  for (let i = 0; i < 1000; i++) {
    rawData.items[i].count += 1000;
  }

  // 手动触发更新
  arrayRef.value = { ...rawData };

  const end = performance.now();
  console.log("changeArrayRefOptimized 运行时间: ", end - start);
}
</script>
```

运行的耗时如下：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1754319412934-a1cb9376-14a7-4127-9e4c-69b404e7fa20.png)

只是 ref 一样可以到底性能优化的目的。只是 shallowRef 会更加的方便，不需要通过 `toRaw`将响应式数据转化为原始对象，非响应式的。如果数据量多了，多创建一个大数据依旧会增加内存的占用的。

ref 加 toRaw 是 "绕过响应式" 的临时解决方案，而 shallowRef 是 Vue 为 "浅层响应式需求" 设计的原生 API，在初始化性能、内存占用、引用追踪的简洁性和第三方库集成方面，具有 ref 无法替代的优势。

#### 1.22 大表单有优化： ref 和 shallowRef 极致的性能优化

总体思路是 shallowRef 负责大数据的渲染，ref 负责单个表单元素的实时渲染。

```
<template>
  <table>
  <tr v-for="row in bigData.rows" :key="row.id">
    <td>
      <!-- 绑定到 currentEditRow，确保输入时实时反馈 -->
      <input
        v-model="currentEditRow[row.id].value"
        @focus="startEdit(row)"
        @blur="saveEdit(row)"
      />
    </td>
  </tr>
</table>
</template>
<script setup>
  const bigOriginData = () => {
  // 模拟大数据
  const rows = [];
  for (let i = 0; i < 1000; i++) {
    rows.push({
      id: i,
      value: `第${i}行`,
    });
  }
  return { rows }
}
const bigData = shallowRef(bigOriginData())

// 当前正在编辑的行用 ref（保证实时反馈）
const currentEditRow = ref(bigOriginData().rows)

// 开始编辑时：将行数据复制到 currentEditRow
const startEdit = (row) => {
  currentEditRow.value[row.id] = { ...row }
};

// 失去焦点时：同步修改到大数据，并触发更新
// 每一次都是改变一次引用
const saveEdit = (row) => {
  // 将修改同步到大数据
  const target = bigData.value.rows.find((r) => r.id === row.id)
  Object.assign(target, currentEditRow.value[row.id])

  // 手动触发大数据更新（界面刷新）
  bigData.value = { ...bigData.value }
}
</script>
```

本质还是为了降低响应式处理的耗时，正如上面代码片段描述的一样，每一次更多只是改变一次响应式的变化，而且还能够帮助界面的实时改变。

## 2. CustomRef

这是一个非常典型符合元编程范式的 API，和 `Proxy`api 一样。不仅仅局限于业务的逻辑，可以从修改程序本身。

元编程的最大特点就是操作程序自身

`customRef`相比 `ref`而言，白盒子和黑盒子的对比，它提供了 ref 内部的 track 和 trigger 方法，可以直接操作 `ref`内部不暴露的依赖收集和响应式的方法。而这两个方法就等于程序自身，而 `customRef`可以操作这个程序，也就论证了可以操作程序自身，所以 `customRef`符合元编程范式。

### 2.1. 基础使用

customRef 将依赖收集和响应式变化的调用时机完全交给开发者。

```
<script setup>
import { customRef, ref } from "vue"
const testCount = customRef((track, trigger) => {
  let value = 0 // 值的初始化
  return {
    get() {
      track()
      return value
    },
    set(newValue) {
      value = newValue;
      trigger()
    },
  }
})
const addTestCount = () => {
  testCount.value++
}
</script>
```

### 2.2. 业务使用场景

#### 2.2.1. 防抖

```
<template>
  <button @click="addCount">count++</button>
  <p>count: {{ count }}</p>
</template>
<script setup>
const useDebouncedRef = (value, delay = 200) => {
  let timeout
  return customRef((track, trigger) => {
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          value = newValue;
          trigger();
        }, delay);
      },
    };
  });
}
const count = useDebouncedRef(0);
const addCount = () => {
  count.value++
}
</script>
```

#### 2.2.2. 验证

```
<template>
  <input v-model="emailValue" />
  <p style="color: red">{{ errorText }}</p>
</template>
<script setup>
const errorText = ref("")
const emailValue = customRef((track, trigger) => {
  let value = ""
  return {
    get() {
      track()
      return value
    },
    set(newValue, oldValue) {
      value = newValue;
      if (newValue.trim() === "") {
        errorText.value = "请输入邮箱"
        return
      }
      if (newValue.includes("66")) {
        errorText.value = "你够 6"
        trigger()
        return
      }
      errorText.value = ""
      trigger()
    },
  }
})
</script>
```

#### 2.2.3. 数据持久化

```
<script setup>
const valueLocal = customRef((track, grigger) => {
  return {
    get() {
      track();
      return localStorage.getItem("valueLocal") || "light"
    },
    set(newValue) {
      localStorage.setItem("valueLocal", newValue)
      grigger();
    },
  }
})
const changeTheme = () => {
  valueLocal.value = valueLocal.value === "dark" ? "light" : "dark"
}
</script>
```

## 3. ShallowReactive

### 3.1. 基本使用

```
<template>
  <button @click="addShallowReactiveCount">addShallowReactiveCount</button>
  <button @click="addShallowReactiveCount2">addShallowReactiveCount2</button>
  <p>
    shallowReactive: {{ objShallow.count }}; 多层级 shallowReactive:
    {{ objShallow.obj.count }}
  </p>
</template>
<script setup>
const objShallow = shallowReactive({
  count: 0,
  obj: {
    count: 0,
  },
})
const addShallowReactiveCount = () => {
  objShallow.count++
}
const addShallowReactiveCount2 = () => {
  objShallow.obj.count++
}
</script>
```

和 `shallowRef`基本是一致的，只是面试操作的类型不一样。和 ref 之于 reactive 的一样。

### 3.2. 业务使用场景

同 `shallowRef`。

## 4. ShallowReadonly

主要是和一些 API 进行比较，本身的使用还是很简单的。

### 4.1. 基本使用

```
const shallowReactiveObject = shallowReadonly({
  foo: 42,
  obj: {
    too: 11,
  },
});
shallowReactiveObject.foo = 33; // ❌ 改
shallowReactiveObject.bar = 11; // ❌ 增
delete shallowReactiveObject.foo; // ❌ 删
shallowReactiveObject.obj.too = 22; // ✅ 改
shallowReactiveObject.obj.bar = 11; // ✅ 增
delete shallowReactiveObject.obj.too; // ✅ 删
console.log("shallowReactiveObject.foo:", shallowReactiveObject); // Expected output: 42
```

第一层数据和 `readonly`的一致，第二层就和操作普通的对象一样的，增删改查的都可以了。

#### 4.1.1. readonly

```
/**
 * readonly() 方法可以创建一个只读的对象，对象的属性不能被修改。
 */
const readonlyObject = readonly({
  foo: 42,
  obj: {
    too: 11,
  },
});
readonlyObject.foo = 33; // ❌ 改
readonlyObject.bar = 11; // ❌ 增
delete readonlyObject.foo; // ❌ 删
readonlyObject.obj.too = 22; // ❌ 改
readonlyObject.obj.bar = 11; // ❌ 增
console.log("readonlyObject.foo:", readonlyObject); // Expected output: 42
```

#### 4.1.2. Object.seal

从此开始下面都是原生底层的 API，不是上面的 vue3 框架提供的 API。这些方法直接修改对象的 内部属性描述符 （如 [[Extensible]] 、 [[Writable]] 、 [[Configurable]]）。

seal() 方法可以防止新属性的添加和已有属性的删除，但是可以修改已有属性的值。

```
const object = {
  foo: 42,
};

Object.seal(object);
object.foo = 33;
console.log(object.foo); // Expected output: 33

delete object.foo; // Cannot delete when sealed
console.log("seal() delete object.foo:", object.foo); // Expected output: 33
object.foo = 11; // ✅
object.bar = 11; // ✅
console.log("seal() object.foo:", object.foo); // Expected output: 33
```

#### 4.1.3. Object.freeze

```
const object2 = {
  foo: 42,
};

Object.freeze(object2);
object2.foo = 33; // ❌
object2.bar = 11; // ❌
delete object2.foo; // ❌
console.log("freeze() object2.foo:", object2.foo); // Expected output: 42
```

只可以读取，其他任何的操作都会直接报错，阻塞 JS 主线程的运行。

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1754328281285-67f3d43d-0d56-4706-ac5c-ddb3c4011355.png)

#### 4.1.4. Object.preventExtensions

preventExtensions() 方法可以防止新属性的添加，但是可以修改已有属性的值。

```
const object3 = {
  foo: 42,
};

Object.preventExtensions(object3);
object3.foo = 33; // ✅
object3.bar = 11; // ❌
delete object3.foo; // ✅
object3.foo = 11; // ❌
console.log("preventExtensions() object3.foo:", object3.foo); // Expected output: 42
```

#### 4.1.5. 校验是否被以上 API 修改对象的数据属性的方式

`Object.isFrozen`、`Object.isSealed`、`Object.isExtensible`。

```
/**
 * 4. Object.isFrozen() 方法
 * isFrozen() 方法可以判断一个对象是否被冻结。
 */
console.log("------------Object.isFrozen() 方法分割线--------------");
console.log("Object.preventExtensions()", Object.isFrozen(object3)); // 空对象了，才是true
console.log("Object.freeze()", Object.isFrozen(object2)); // true
console.log("Object.seal()", Object.isFrozen(object)); // false

/**
 * 5. Object.isSealed() 方法
 * isSealed() 方法可以判断一个对象是否被密封。
 */
console.log("------------Object.isSealed() 方法分割线--------------");
console.log("Object.seal()", Object.isSealed(object)); // true
console.log("Object.freeze()", Object.isSealed(object2)); // true
console.log("Object.preventExtensions()", Object.isSealed(object3)); // false

/**
 * 6. Object.isExtensible() 方法
 * isExtensible() 方法可以判断一个对象是否是可扩展的。
 */
console.log("------------Object.isExtensible() 方法分割线--------------");
console.log("Object.preventExtensions()", Object.isExtensible(object3)); // false
console.log("Object.freeze()", Object.isExtensible(object2)); // false
console.log("Object.seal()", Object.isExtensible(object)); // false
```

-Object.isExtensible() 对应的判断对象的数据属性中的 [[Extensible]] 为 false。

所以想要通过判断对象被那个方法处理了，需要用这三个结合判断。如下：

```
// 假设 object3 已被某种方法处理
const isPrevented = !Object.isExtensible(object3) && !Object.isSealed(object3) && !Object.isFrozen(object3);
const isSealed = !Object.isExtensible(object3) && Object.isSealed(object3) && !Object.isFrozen(object3);
const isFrozen = !Object.isExtensible(object3) && Object.isSealed(object3) && Object.isFrozen(object3);

console.log('被 preventExtensions 处理:', isPrevented);
console.log('被 seal 处理:', isSealed);
console.log('被 freeze 处理:', isFrozen);
```

## 5. toRaw

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1754330006417-d6b88f62-d1cd-4b69-99fa-012038f8ebbf.png)

toRaw() 可以返回由 reactive()、readonly()、shallowReactive() 或者 shallowReadonly() 创建的代理对应的原始对象。

在前面说到 shallowRef 部分已经提到了这个 API 的作用了，可以配合 ref 实现接近 shallowRef 的性能。

```
<template>
  <button @click="changeName">changeName</button>
  <button @click="changeRaw">changeRaw</button>
  <p>{{ data.name }}</p>
  <p>{{ data.age }}</p>
</template>
<script setup>
  const data = reactive({
  name: "张三",
  age: 18,
});
const raw = toRaw(data);
const changeName = () => {
  data.name = data.name === "李四" ? "张三" : "李四";
  data.age++;
};
const changeRaw = () => {
  raw.name = raw.name === "李四" ? "张三" : "李四";
  raw.age++;
};
</script>
```

`changeRaw`方法没有反应，视图不会更新，说明 raw 已经是原对象了，非响应式了。但是修改 raw 依旧会影响到 `data`这个响应式对象。

修改 toRaw()返回的对象，删除以及修改都会影响到原始的响应式对象。它们两个都是引向同一个内存地址，只是一个用 Proxy 进行了再加个，另外一个没有。

## 6. markRaw

它的效果和 `toRaw`有一定相似的。都是让某一个对象更改为非响应式的。但是 markRaw 可以直接用在依旧被定义过的响应式对象中，如下：

```
<template>
  <p>
    标记为非响应式的对象，不会触发视图更新,但是初始化的时候依旧会改变，点击
    changeMarked 按钮，就不会改变视图
  </p>
  <button @click="changeMarked">changeMarked</button>
  <p>{{ state.config.name }}</p>
</template>
<script setup>
const rawObject = { name: "静态数据" };
const markedObject = markRaw(rawObject); // 标记为非响应式

// 即使放入响应式对象中，markedObject 仍保持原始状态
const state = reactive({
  config: markedObject, // 不会被代理
});

state.config.name = "修改"; // ❌ 无效（非响应式，视图不更新）

const changeMarked = () => {
  state.config.name = state.config.name === "静态数据" ? "修改" : "静态数据";
};
</script>
```

我们初始化的时候依旧是“修改”，那是因为 vue3 收集依赖是在 `onMounted`生命周期之前。

```
setup() → 初始化响应式数据
  ↓
onBeforeMount() → 渲染前准备
  ↓
渲染 DOM → 访问响应式数据，触发依赖收集
  ↓
onMounted() → 组件挂载完成
```

- 依赖收集发生在 渲染 DOM 的过程中 ，介于 onBeforeMount 和 onMounted 之间
- 这就是为什么界面显示的是「修改」而非「静态数据」的关键

而当我使用 `setTimout`来包裹住 `state.config.name`的时候，初始化的指就是'静态数据'了。

## 7. effectScope

### 7.1. 基本使用

```
<template>
   <el-button @click="counter++">增加</el-button>
  <el-button @click="startEffects">启动</el-button>
  <el-button @click="stopEffect">停止</el-button>
  <el-button @click="runEffect">重新运行</el-button>
  <p>计算结果：{{ counter }} 计算结果：{{ doubled }}</p>
  <p>条件性启用和禁用作用域</p>
</template>
<script setup>
const counter = ref(0)
const doubled = computed(() => counter.value * 2)
const scope = effectScope()

const startEffects = () => {
  scope.run(() => {
    watch(doubled, () => console.log(doubled.value));
    watchEffect(() => console.log("Count: ", doubled.value));
  });
}
const stopEffect = () => {
  scope.stop()
}
const runEffect = () => {
  scope.run()
}
</script>
```

### 7.2. 业务使用场景：全局响应式变量

```
import { effectScope, type EffectScope } from 'vue'

// 创建全局状态的工厂函数
export const createGlobalState = <T>(stateFactory: () => T) => {
  // 用于存储全局作用域
  let global: T
  // 用于存储effect作用域
  let scope: EffectScope

  // 返回一个函数，该函数用于获取或创建全局状态
  return () => {
    // 如果全局状态已存在，直接返回
    if (global) return global

    // 如果全局状态不存在，创建一个新的effect作用域
    scope = effectScope(true)

    // 在作用域内运行状态工厂函数，创建全局状态
    global = scope.run(() => stateFactory())!

    return global
  }
}
```

使用的时候

```
import { createGlobalState } from '../../hooks/globalScope'
import { ref } from 'vue'
export const useGlobalCount = createGlobalState(() => {
  const count = ref<number>(222)
  const increment = () => count.value++
  return { count, increment }
})
```

在组件中使用，可以跨组件：

```
<template>
  <div class="container">
    <!-- 页面内容区域 -->
    <h2>{{ count }}</h2>
  </div>
</template>

<script setup>
import { useGlobalCount } from "./global-count";
const { count } = useGlobalCount();
</script>
```

`count`可以在多个组件中同时使用。这个也是 vueuse 中 createGlobalState 的实现原理。利用的就是 effectScope 可以控制副作用的清除和重启的方法。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[网络缓存机制]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Network/网络缓存机制</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Network/网络缓存机制</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[缓存机制  所谓机制,就是说有这么一套规则来束约缓存的逻辑. 束约的工具是浏览器内部实现的. 束约的参数就是我们 HTTP 和 HTTPS 协议的报文内容. 结果就是用户看到的资源. 所以说我们在讨论的浏览器缓存机制的时候,就是在讨论 HTTP 报文中的某些对应字段的发挥的作用, 辅以一套处理这些字段的逻辑. 这套处理的逻辑可以分为两种强制缓存和协商缓存  强制缓存 在 http1.0 时代,通过配置expires相应头的属性,设置过期的时间,只要超过这个时间,资源就从服务器上获取.反之就从本地获取. 很简单,但是问题也很多 对本地时间戳过分的依赖,如果客户端本地的时间和服务器的时间不一致的...]]></description>
            <content:encoded><![CDATA[# 缓存机制

 所谓机制,就是说有这么一套规则来束约缓存的逻辑. 束约的工具是浏览器内部实现的. 束约的参数就是我们 HTTP 和 HTTPS 协议的报文内容. 结果就是用户看到的资源.

所以说我们在讨论的浏览器缓存机制的时候,就是在讨论 HTTP 报文中的某些对应字段的发挥的作用, 辅以一套处理这些字段的逻辑.

这套处理的逻辑可以分为两种强制缓存和协商缓存

## 强制缓存

在 http1.0 时代,通过配置`expires`相应头的属性,设置过期的时间,只要超过这个时间,资源就从服务器上获取.反之就从本地获取.

很简单,但是问题也很多

对本地时间戳过分的依赖,如果客户端本地的时间和服务器的时间不一致的话,那么缓存过期的判断就无法和预期相符

> 浏览器中的这个时间叫做格林威治时间

所以为了解决这个问题. 在 http1.1 时代,出现了`cache-control`字段. 其中的`max-age`属性就是对于`expires`的补充.

不是进行替代,而是补充.`expires`因为简单依旧存在它的使用场景

如下配置, 单位是**秒**:

```js
res.writeHead(200m {
    "Cache-control": "max-age:5"
})
```

这个`max-age`的含义超过相对时间. 每一次刷新都更新初始化时间，类似防抖函数的作用，当你渲染界面之后的 5 秒钟内，都是可以从缓存中拿到数据的。一旦渲染界面之后，再超出 5 秒钟才再点击拿资源的话，就会重新从服务器上面拿该资源。

很多时候还是需要加上`public`属性的. `"public, max-age:5"`的. 含义是: **响应可以被任何对象缓存(包括发送请求的客户端、代理服务器等)**

如果只是使用`max-age`依旧是存在问题的.如果你后台的接口,资源就是在配置的的几秒钟更新了你怎么办?GG 了. 所以出现了下面的协商缓存

## 协商缓存

协商缓存就要求每次都向服务器要结果. 缓存的有效性决定权交给后台.这样自然缓存存在的意义就很大的问题了.对于这个问题暂时不表,先来看看它是如果进行协商缓存的逻辑处理的.

### last-modified 实现的协商缓存

这是最简单的协商缓存的方案, 根据文件的修改时间来进行判断. 如下配置

```js
res.setHeader("last-modified", mtime.toUTCString());
res.setHeader("Cache-Control", "no-cache");
```

配置成功了之后, 响应头会生成一个属性 `if-modified-since`. 然后后台再进行如下的判断:

```js
const ifModifiedSince = req.headers["if-modified-since"];
if (ifModifiedSince === mtime) {
  // 缓存生效
  res.statusCode = 304;
  res.end();
  return;
}
```

如此一来,是能够满足绝大多是的场景的. 但是还是有如下的不足:

1. 它只是根据时间戳来进行判断,如果只是改变了文件名,而实际内容没有任何改变的情况下,还是会进行服务器的请求拿取.这实在是太蠢了.
2. 它的单位是秒.如果修改文件的速度非常快,在一些自动化文件处理中.在几百毫秒就完成了.那么它的单位就没有办法通过验证了.

所以为了解决这两点问题, HTTP1.1 在随后更新版本中提供`etag`响应头字段来处理

### ETag 实现协商缓存

处理逻辑和`last-modified`基本一致

```js
  s const etag = require("etag");

  const data = fs.readFileSync("./img4.png");
  const etagContent = etag(data);

  const ifNoneMatch = req.headers["if-none-match"];

  if (ifNoneMatch === etagContent) {
    // 缓存生效
    res.statusCode = 304;
    res.end();
    return;
  }

  res.setHeader("etag", etagContent);
  res.setHeader("Cache-Control", "no-cache");
  res.end(data);
```

etag 表示的是对文件内容的解析进而生成的一个 id，只要文件内容有了改变才会进行变更。自然就能够改变 last-modified 的两点的不足。它是对其的一个补充方案，而不是替代方案。

etag 依旧带来了新的问题:

1. 服务器生成文件资源 Etag 需要付出额外的计算开销，如果资源尺寸比较大，数量较多且修改比较频繁的话，那么生成 Etag 的过程显然会印象服务器的性能。
2. Etag 字段值的生成两种类型，一种是强验证，即更具资源内容的每一个字节来进行验证，最可靠，性能消耗也最大。相对应的就是弱验证，它使用资源内容的部分的属性值来进行生成，生成速度快，但是没有办法很高的成功率。尤其是在服务器集群场景下。

所以说不管哪种缓存方式都有不足,结合具体的场景使用才是正确对待它们的方式. 一般来说,`etag`和`last-modified`都是使用的. 所以说对于它们的使用还有一个优先级的问题.

### ETag 和 Last-Modified 的优先级

一般来说,默认配置的话. 是先进行`etag`的判断的,如果返回的是 true 的话,再判断`last-modified`.
当然这个可以后台自己实现自己喜欢的策略.

### 协商缓存过程的简单总结

可以总结如下图

![截屏2022-02-25 16.10.36.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8bda1eb17fa4a7baeb17c437a8d6c08~tplv-k3u1fbpfcp-watermark.image?)

## 其他相关配置的豹纹字段

Paragma: no-cache(响应头) HTTP/1.0 版本的字段

Cache-Control: 也是操作缓存的.是 HTTP/1.1 版本字段,向下兼容的,所以说 Paragma 还是存在的.

Cache-Control 的优先级是比前者高的.

Expires: Mon, 15 Aug2016 03:56:47 GMT(格林威治时间)

在 HTTP/1.1 使用 Cache-control 中的 max-age 来代替

Cache-Control 的相关属性

- no-cache: **忽略缓存在本地的副本,强制从服务器上拿资源**

- no-store: **强制缓存在任何情况下都不要保留任何副本**

- max-age=314600: 知识缓存副本的有效时长,从请求时间开始到过期时间之间的描述

- public: 表明响应可以被任何对象缓存(包括:发送请求的客户端、代理服务器等)
- private: 表明响应只能被耽搁用户缓存,不能作为共享缓存(即代理服务器不能缓存它)

## 我们前端需要做些什么

这里是熟悉前端工程话的知识点了.很多 Webpack 基础已经帮我们做了. 我们只需要进行进行对应的配置就可以了. 比如说,修改每次打包都修改生成的入口文件的文字

```js
  entry:{
      main: path.join(__dirname,'./main.js'),
      vendor: ['react']
  },
  output:{
      path:path.join(__dirname,'./dist'),
      publicPath: '/dist/',
      filname: 'bundle.[chunkhash].js'
  }

```

`chunkhash`就代表出口文件没有打包都会生层对应的 hash 值. 还有另外两个值可以替换它.`hash`、`contenthash`

三者的差别可以用一句话来概括:

- `hash` 计算和整个项目的构建相关
- `chunkhash`计算同一 chunk 内容相关
- `contenthash`计算和文件内容本身相关
  详情可以自己尝试一下.看官网.

还有一些前端世界常听到的:

- html 使用协商缓存
- css、js、静态资源 使用强缓存,文件名带上 hash 值
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[MVC 设计规范]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Vue/MVC 设计规范</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Vue/MVC 设计规范</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[MVC 设计规范 想要真正的明白 MVC 的框架是需要大量的实战的. 而 MVC 框架是 MVVM 框架的前置知识. 而 MVC 框架带的前置知识是整个 JavaScript 知识体系. MVC 是 Model、View、Controller 三个的缩写合并而成. 今天的我的目标是要创造一个能够自加自减的工具. 点击 + 可以增加岁数, 减就减少对应的岁数.如图所示: !截屏2022-02-2023.04.1316453694990110.png  接下来进入 code 缓解, 现在需要创建一个容器来承载接下来的内容 html <body>   <div id="app"></div> </b...]]></description>
            <content:encoded><![CDATA[# MVC 设计规范

想要真正的明白 MVC 的框架是需要大量的实战的. 而 MVC 框架是 MVVM 框架的前置知识. 而 MVC 框架带的前置知识是整个 JavaScript 知识体系.

MVC 是 `Model`、`View`、`Controller` 三个的缩写合并而成.
今天的我的目标是要创造一个能够自加自减的工具. 点击 + 可以增加岁数, 减就减少对应的岁数.如图所示:

![截屏2022-02-20_23.04.13_1645369499011_0.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb7b0e8150a46f3b891381815f52b4c~tplv-k3u1fbpfcp-watermark.image?)

## 接下来进入 code 缓解, 现在需要创建一个容器来承载接下来的内容

```html
<body>
  <div id="app"></div>
</body>
```

还需要创建对应的三个对象来分别对应 MVC 三部分:

```js
(function () {
  const Model = {};
  const View = {};
  const Controller = {};
})();
```

三者各司其职, 现在添加一些默认相上去,以使它们能够启动.

```JavaScript
  ;(function(){
    init()

    const Model = {
      data: {},
      init() {}
    }
    const View = {
      render() {}
    }
    const Controller = {
      init() {}
    }

    function init() {
      Model.init()
      View.render()
      Controller.init()
    }
  }())
```

这里面的知识点涉及到了[[IIFE]] 立即执行函数是我们在没有模块化管理工具之前,进行插件开发的一个必要的工具

基本的代码结构已经完成了.

## 我们先对`Model`部分进行详细的 code

```js
const Model = {
  data: {
    name: "橘子哥哥",
    age: 18,
  },
  init() {
    for (let key in this.data) {
      Object.defineProperty(this, key, {
        get() {
          return this.data[key];
        },
        set(newValue) {
          this.data[key] = newValue;
          // View.render({[key]: newValue})
        },
      });
    }
  },
};
```

我们对`Model`来进行初始化,就是为了让外面的可以直接通过`Model.name` 就能够访问到内容的 data 对象中定义的值. 而多出一个 data 来包裹着变量, 主要是为了增加代码的可读性.让数据和方法分离.

我们的目的是对数据进行响应式的封装.所以说在`set`的时候,进行`View.render`的调用.一旦变量改变了就调用`View`模块渲染部分逻辑.

传入的参数是当前改变的值,将来是要根据这个值来改变对应内容的重新渲染的.

这里涉及到了 [[数据劫持]] ,Flutter 的 Getx 框架就显行的使用数据劫持来进行数据的处理.在 JS 中属于[[对象的访问器属性]]的知识

## 数据已经处理好了,我们来处理界面渲染部分的逻辑,我们逻辑的最终的出口:

```js
const View = {
  el: "#app",
  template: `
        <div class="box">
             <div class="cal-name">{{ name }}</div>
             <div>,今年</div>
             <div class="cal-age">{{ age }}</div>
             <div>岁</div>
             <div class="splice"></div>
             <button class="cal-button add">+</button>
             <button class="cal-button reduce">-</button>
         </div>
      `,
  reg: /\{\{(.*?)\}\}/g,
  render(mutedData) {
    if (!mutedData) {
      this.template = this.template.replace(this.reg, (node, key) => {
        return model[key.trim()];
      });

      const container = document.createElement("div");
      container.innerHTML = this.template;
      document.querySelector(this.el).appendChild(container);
    } else {
      for (let key in mutedData) {
        document.querySelector(`.cal-${key}`).textContent = mutedData[key];
      }
    }
  },
};
```

`el`的命名和作用和`Vue`框架中的保持一致.目的也一目了然.就是把我们要渲染的内容都挂载在 id 为`app`的标签中.

`template`就对应`Vue`中的模版,或者说是`JSX`.

`render`部分涉及到了[[正则表达式的基础]],以及如何使用正则来实现简单的模版替换. 通过判断,如果没有参数传进来,即`mutedData`为`undefined`的话,就是初始化渲染全部内容. 而有值传进来就表示值有变化,就直接改变对应的地方渲染就可以了.

## 此时可以查看界面,以及出现了我们一开始的目标样子.这个时候我们还需要加上我的操作逻辑.

```js
const Controller = {
  init() {
    const oCalButtons = document.querySelectorAll(".cal-button");

    for (let i = 0; i < oCalButtons.length; i++) {
      btnItem = oCalButtons[i];
      btnItem.addEventListener("click", this.handleBtnClick, false);
    }
  },
  handleBtnClick(e) {
    switch (e.target.textContent) {
      case "+":
        model.age++;
        break;
      case "-":
        model.age--;
        break;
      default:
        break;
    }
  },
};
```

1. `init`绑定上点击事件

1. `handleBtnClick`处理具体的事件

## 最后我们来看一下整体的代码:

```js
(function () {
  function init() {
    model.init();
    view.render();
    controller.init();
  }

  const model = {
    data: {
      name: "橘子哥哥",
      age: 19,
    },
    init() {
      for (let key in this.data) {
        Object.defineProperty(this, key, {
          get() {
            return this.data[key];
          },
          set(newValue) {
            this.data[key] = newValue;
            view.render({ [key]: newValue }); // ❌
          },
        });
      }
    },
  };

  const view = {
    el: "#app",
    template: `
	        <div class="box">
	          <div class="cal-name">{{ name }}</div>
	          <div>,今年</div>
	          <div class="cal-age">{{ age }}</div>
	          <div>岁</div>
	          <div class="splice"></div>
	          <button class="cal-button add">+</button>
	          <button class="cal-button reduce">-</button>
	        </div>
	  	`,
    reg: /\{\{(.*?)\}\}/g,
    render(mutedData) {
      if (!mutedData) {
        this.template = this.template.replace(this.reg, (node, key) => {
          return model[key.trim()];
        });
        const container = document.createElement("div");
        container.innerHTML = this.template;
        document.querySelector(this.el).appendChild(container);
      } else {
        for (const key in mutedData) {
          document.querySelector(`.cal-${key}`).textContent = mutedData[key];
        }
      }
    },
  };

  const controller = {
    init() {
      const oCalButtons = document.querySelectorAll(".cal-button");

      for (let i = 0; i < oCalButtons.length; i++) {
        btnItem = oCalButtons[i];
        btnItem.addEventListener("click", this.handleBtnClick, false);
      }
    },
    handleBtnClick(e) {
      switch (e.target.textContent) {
        case "+":
          model.age++;
          break;
        case "-":
          model.age--;
          break;
        default:
          break;
      }
    },
  };

  init();
})();
```

整个代码就是很典型的 MVC 结构的代码,在`Model`中定义参数之余,还要监听参数的变化,来进行界面的渲染.根据代码可以得出这样的一张图:

![无标题-2022-02-21-0010_1645373736968_0.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5b1eef86ff4e46980051ca359238db~tplv-k3u1fbpfcp-watermark.image?)

- 我们喜欢的是三者能够完全的独立,但是 MVC 没有给我们带来. 每一个模块之间还是有所牵连.所以我们需要改变.这就有了`MVVM`的出现. MVVM 的出现解决了`MVC`的一部分问题. [[手写MVVM框架]]
- 缺点:
  - 驱动被 MVC 三个部分分离了.而我们的 MVVM 就是把驱动的封装起来
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[vapor]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Vue/vapor</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Vue/vapor</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[Vapor  性能提升测试 |                  | 首屏加载速度       | 更新耗时 | 更新内存使用 | | ---------------- | ------------------ | -------- | ------------ | | traditional Mode | 1.82s 到 2.28s | 143ms    | 180 mb       | | Vapor Mode       | 1.72s 到 2s    | 25ms     | 144 mb       |  测试方法 浏览器：Chorme 版本 135 隐私模式 创建项目，把 vite...]]></description>
            <content:encoded><![CDATA[# Vapor

## 性能提升测试

|                  | 首屏加载速度       | 更新耗时 | 更新内存使用 |
| ---------------- | ------------------ | -------- | ------------ |
| traditional Mode | **1.82s 到 2.28s** | 143ms    | 180 mb       |
| Vapor Mode       | **1.72s 到 2s**    | 25ms     | 144 mb       |

### 测试方法

浏览器：Chorme 版本 135 隐私模式

创建项目，把 `vite-plugin-vue-devtools`插件删除。删除默认的.vue 文件，删除样式文件。

template 核心代码如下：

```vue
<div class="flat-form">
  <div v-for="item in formData" :key="item.id" class="flat-form-item">
    <input type="text" v-model="item.name" placeholder="Name" />
    <input type="email" v-model="item.email" placeholder="Email" />
    <input
      type="number"
      v-model="item.age"
      min="18"
      max="120"
      placeholder="Age"
    />
    <label class="active-label">
      <input type="checkbox" v-model="item.active" /> Active
    </label>
  </div>
</div>
```

数据生成逻辑如下：

```typescript
const generateTestData = () => {
  formData.value = Array.from({ length: totalItems }, (_, i) => ({
    id: i + 1,
    name: `User ${i + 1}`,
    email: `user${i + 1}@example.com`,
    age: Math.floor(Math.random() * 50) + 18,
    active: i % 2 === 0, // 确保正好一半数据的active为true
  }));
  isLoading.value = false;
};
```

active 确保正好一半数据的 active 为 true，是为了测试数据更新的时候数据变量的量样本一致。

更新数据的关键代码如下：

```typescript
const fixedUpdateCount = 20000;
formData.value.forEach((item, index) => {
  if (index < fixedUpdateCount) {
    item.active = !item.active;
  }
});
```

性能监听关键代码如下：

```typescript
// 等待DOM更新完成
await nextTick();

// 记录结束时间并计算差值
const endTime = performance.now();
updateTime.value = Math.round(endTime - startTime);

if (performance.memory) {
  const memoryUsageBytes = performance.memory.usedJSHeapSize;
  const memoryUsageMB = (memoryUsageBytes / (1024 * 1024)).toFixed(2);
  memoryUsage.value = parseFloat(memoryUsageMB);
  console.log(`Memory usage after update: ${memoryUsageMB} MB`);
}

console.log(`DOM update completed in ${updateTime.value}ms`);
```

> 之所以不完全使用控制台中的 Performance 来记录，是因为电脑比较卡，打开控制台本身就消耗了电脑不少性能。而且我们不需要多么精准的数据，需要的是对比。有了对比数据即可。

### 数据来源

**Vapor Mode:**

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753260936414-c4c79d5c-54cd-4126-bc1e-5ad60bf9d66c.png)

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753264996004-4812f646-3f94-4358-9e53-7a0755a86244.png)

**传统模式：**

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753260964666-3d085815-2c0c-4c45-9f3c-a889e19ba06f.png)

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753264977057-87195717-c3a6-473a-84ff-494fafc93f8e.png)

## Vapor 工作原理

### 配置流程

基于 vue3@3.6.0-alpha.2 版本

#### 渐进式使用方式(混合渲染模式)

1. 从 vue 中导出 vaporInteropPlugin 并 use

```vue
import { createApp, vaporInteropPlugin } from 'vue' import App from './App.vue'
import router from './router' const app = createApp(App)
app.use(vaporInteropPlugin) app.use(router) app.mount('#app')
```

2. 在需要使用的 SFC 文件的 setup 中配置上 `vapor` 即可。

#### 全量使用

修改 main.ts 中的引入组件

```typescript
import { createVaporApp } from "vue";
import App from "./App.vue";
createVaporApp(App).mount("#app");
```

> vue 的包体积从 50K 减少到 6k

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753265976128-e7d94807-36af-4fba-87ea-9ec2ae23dbd3.png)

### vapor 执行过程

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753271068555-e6b29728-1703-45ac-876c-1b33060fdb70.png)

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753266797992-fb35a48c-fb11-4887-a00e-0d4bf3288dec.png)

> 编译后的文件一般在 source 对应文件的下面，它的作用就是识别.vue 文件，然后把.vue 文件编译为 js 代码

简化代码如下

```javascript
const t0 = _template("<button>add count</button>");
const t1 = _template("<div> </div>");
const t2 = _template("<button>update class</button>");
const t3 = _template("<div>我是什么颜色</div>");
function _sfc_render(_ctx, $props, $emit, $attrs, $slots) {
  const n1 = t0();
  const n2 = t1();
  const n3 = t2();
  const n4 = t3();
  n1.$evtclick = _ctx.addCount;
  const x2 = _child(n2);
  n3.$evtclick = _ctx.updateClass;
  _renderEffect(() => {
    _setText(x2, _toDisplayString(_ctx.count));
    _setClass(n4, _ctx.color);
  });
  return [n1, n2, n3, n4];
}
```

上面是编译后的结果。

编译时: 识别了我绑定的在 DOM 上面可以进行的动态变改的是什么类型的节点。这次我想要改变的是 div 标签中的文本和 div 中字体的颜色。所以在生成的代码中就提前导入了 `setText` 以及 `setClass` 两个方法。

以 `setClass`为例，参数有两个：`_template("<div>我是什么颜色</div>")`和 `ctx.color`。

我们最后来看看`_renderEffect`函数，看名字你可能已经猜出来了。这个函数和`vue3`中的`watchEffect`比较相似，会立即运行一个函数。并且追踪函数中用的的依赖，这里的依赖是`msg`变量。当依赖的值变化时会再次执行这个函数。

这里的`_setText(n1, _ctx.msg)`，实际就是执行了`n1.textContent = _ctx.msg`。`textContent` 属性表示一个节点及其后代的文本内容，也可能通过给它赋值的方式删除它的所有子节点，并替换为一个具有给定值的文本节点，和`innerText`功能比较相似。

#### \_template 源码

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753277987653-172779a2-e138-484d-87d6-e2d0d2ad2cb0.png)

1. isHydrating 为服务端渲染，服务 SSR，跳过
2. `html[0] !== '<'`为 true 说明是纯文本内容，直接创建文本节点，跳过模板解析流程。
3. t 使用单例模式，不多于创建 `template`。
4. `if(!node)`缓存首次解析的 DOM 节点，避免重复解析 HTML 字符串, 如果已经存在了，通过 `cloneNode` 复用已经创建，减少 DOM 操作成本。

#### \_setText 源码

#### ![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753279257903-7fbace23-1e13-4758-99c2-b1f72c7e9137.png)

> `nodeValue`：直接修改 DOM 文本节点的内容（`textContent` 的底层实现）。

这里做了一个优化，如果值没有变化，就不重新个 `el.nodeValue`赋值。

上面代码转化为下面代码片段，直接改变的是文本本身，因为传进来的 childNodes 只有文本。

```javascript
const el = document.getElementById("test").childNodes[0];
el.nodeValue = el.$txt = value;
```

#### \_renderEffect 源码

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753280633388-6d30f4dc-c8d1-4ece-8585-27b0a96be070.png)

renderEffect 继承于 `ReactiveEffect`类，也就是说，我们传进去的函数作为一整个副作用在运行。

> `watchEffect` 本质上是通过封装 `ReactiveEffect` 类实现的高级用户 API。

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753281228512-0d4e769d-4c18-49d6-8885-b282d829cbf1.png)

`this.render()`就是执行我们传进行的下面的代码。

```javascript
() => {
  _setText(x2, _toDisplayString(_ctx.count));
  _setClass(n4, _ctx.color);
})
```

`_renderEffect(() => { ... })` 会自动追踪其回调函数内访问的所有响应式变量（如 `_ctx.count` 和 `_ctx.color`）。无论这些变量是否在本次更新中真正变化，只要它们被访问，就会被记录为依赖。

然后只有其中一个变量改变了，就会执行一次上面的 `fn()`函数，`_setText`和 `_setClass`都会被执行。

> 这个应该是需要它们后期优化的，我明明只是修改其中一个变量，为什么另外一个不相关的 \_setClass 也执行了呢？但是执行函数里面有了一定的优化，看\_setText 源码部分。

上面的代码简而言之，就是 直接调用 DOM API 对变量进行精细化渲染。

:::info
<u><font style="color:#DF2A3F;">也就是说？Vapor 在编译时就确定了 t1 这个 DOM 节点需要更新 count 数据,不需要再 diff 一遍！</font></u>

:::

#### compiler-vapor 源码

IR 是重点.....

看不懂，编译时，在解析文本，确定哪个 Dom 是需要精准更新的。

#### apiCreateFor

diff 不完全从运行时中删除了。比如在 v-for 中。源码位置如下：

`packages/runtime-vapor/src/apiCreateFor.ts`

源码如下：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753696188297-a7d841ab-2126-4a96-abd5-43798be69458.png)

在运行时 中，v-for 循环依旧使用了 diff 算法。

#### 总结一下它执行的过程：

- 编译时：通过 AST 分析标记动态绑定与响应式依赖，生成精准的 DOM 操作指令；
- 运行时：通过 `_renderEffect` 实现细粒度更新，完全跳过虚拟 DOM；

所以等同于把 “diff 算法” 或者“虚拟 DOM”这些的操作提前在 vue 的 Compiler 中进行了处理。运行时只需要操作 DOM API 精准渲染，不存在寻找这次改变的是哪一个位置的逻辑了，运行时简化了计算节点的逻辑。

> _**这就是本地初始化的时候，首屏加载的速度没有明显的提升，那是因为 Compiler 增加了对于动态绑定标记与响应式依赖分析逻辑，会在本地开发或首次构建时带来额外开销。**_

## 传统 node 执行过程

具体代码如下：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753271321802-b29229a5-eeb4-4ac6-a160-1f21063bc301.png)

简化如下

```typescript
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (
    _openBlock(),
    _createElementBlock(
      _Fragment,
      null,
      [
        _createElementVNode(
          "button",
          { onClick: $setup.addCount },
          "add count"
        ),
        _createElementVNode(
          "div",
          null,
          _toDisplayString($setup.count),
          1
          /* TEXT */
        ),
        _createElementVNode(
          "button",
          { onClick: $setup.updateClass },
          "update class"
        ),
        _createElementVNode(
          "div",
          {
            class: _normalizeClass($setup.color),
          },
          "我是什么颜色",
          2
          /* CLASS */
        ),
      ],
      64
      /* STABLE_FRAGMENT */
    )
  );
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753270858551-4b0d5e8d-6c4b-46de-b3ec-7d25fb791b98.png)

相比传统的执行过程，vapor 模式执行如下：

![](https://cdn.nlark.com/yuque/0/2025/png/654315/1753270866798-fa49bc7a-9263-456b-a005-074a468a4fde.png)

总结：

1. diff 算法的删除减少了 patch 的执行时间。
2. 虚拟 DOM 删除，减少了大量变量的存在，直接减少了内存的占用。

### 执行过程

#### 1. 初始化阶段

模板编译：Vue 的编译器会将你的 template 编译为渲染函数（render function），生成的虚拟 DOM 结构大致如下：

```tsx
function render() {
  return h("div", [
    h("h1", "HelloWorld"),
    h("button", { onClick: () => count.value++ }, `count is ${count.value}`),
  ]);
}
```

响应式数据绑定：count 被 ref(0) 包裹后，Vue 会将其转换为响应式对象，并建立依赖追踪。

#### 2. 首次渲染

生成虚拟 DOM 树，执行渲染函数，生成初始虚拟 DOM（VNode）。

```tsx
{
  type: 'div',
    children: [
    { type: 'h1', children: 'HelloWorld' },
    { type: 'button', props: { onClick: handler }, children: 'count is 0' }
  ]
}
```

挂载真实 DOM：Vue 将虚拟 DOM 转换为真实 DOM 并插入页面。

```tsx
<div>
  <h1>HelloWorld</h1>
  <button>count is 0</button>
</div>
```

#### 3. 更新阶段

- 触发响应式更新：点击按钮 → count.value++ → 触发 count 的 setter 通知依赖（副作用）。
- 重新生成虚拟 DOM：重新执行渲染函数，生成新的虚拟 DOM。

```tsx
{
  button: { ..., children: 'count is 1' } // 只有 count 文本变化
}
```

- Diff 算法对比差异：Vue 对比新旧虚拟 DOM，发现只有 button 的文本子节点变化（0 → 1）。
- 精准更新真实 DOM：直接修改按钮的 textContent，无需重新创建整个 DOM 树。

button.textContent = 'count is 1';

以上便是对 Vue 虚拟 DOM 工作流程的简化描述，Vue 的虚拟 DOM 工作流程在实际执行中还有一些优化细节和边界情况，这个大家有兴趣可以去看一下 Vue 的源码，这里不做过多的阐述，只是让大家有个印象。

#### 感想

痛苦不会消失，只是会转移，Vapor 将耗时的逻辑从运行时转移到了编译时。但是优化编译时的逻辑，所以实现了总体性能的极大提升的同时，总的痛苦也减少了很多。

## 当前版本注意事项

### 官方的话:

- 适用场景：

  - ✅ 新项目初始化（createVaporApp）
  - ✅ 性能敏感页面（如首屏、数据看板）的局部启用（`<script setup vapor />`）

- 规避风险：
  - ❌ 避免老项目全量迁移
  - ❌ 暂勿依赖高级功能（如 SSR 激活、异步组件）
  - ❌ 大量依赖第三方 VDOM 组件库（兼容性存在边界问题）；
  - ❌ 暂勿依赖高级功能（如 SSR 激活、异步组件）
  - ❌ 大量依赖第三方 VDOM 组件库（兼容性存在边界问题）；

### 不使用的具体 API

defineAsyncComponent、`<KeepAlive>`、`<Teleport>`、`<Suspense>`都没有支持，计划中。

:::info
列表渲染 v-for 中依旧存在 diff 算法，而且是完整的 diff 算法。
:::

**Vapor 并不是简单粗暴地抛弃了所有 diff 算法，而是做了精细化的场景区分。**

- 在 90%的常规场景下，通过编译时优化实现了"无 diff"更新
- 在复杂的列表场景下，保留了成熟稳定的 diff 算法

**理出一个简单的表格总结：**

| 场景                | Vapor 的策略      | 原因                     |
| ------------------- | ----------------- | ------------------------ |
| 简单绑定 {{ name }} | 直接更新，无 dif  | 编译时就能确定更新目标   |
| 条件渲染 v-if       | 简单替换，无 diff | 只需要显示/隐藏，不复杂  |
| 列表渲染 v-for      | 保留 diff 算法    | 需要处理复杂的增删改移动 |
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[内置指令]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Vue/内置指令</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Vue/内置指令</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[内置指令  参考资料 - 内置指令  v-text & 插值语法 > 插值语法就是 {{ message }} v-text 相比插值语法最大的作用就是语义化更加的好，理论上它的性能可能要比插值语法好，不过可以忽略不计。 当我们在v-text的元素中添加子节点，这个子节点包括textContent或者其他节点类型的话，会在编译时就报错，报错信息如下： ![[Pasted image 20250813143743.png]] 这个是从语法层面的规范，利好团队协作，然后其他开发看一眼就知道这个 dom 的意图，不要往它子节点添加东西。  v-html 和 xss  基础用法 js <templat...]]></description>
            <content:encoded><![CDATA[# 内置指令

## 参考资料

- [内置指令](https://cn.vuejs.org/api/built-in-directives.html)

## v-text & 插值语法

> 插值语法就是 `{{ message }}`

v-text 相比插值语法最大的作用就是语义化更加的好，理论上它的性能可能要比插值语法好，不过可以忽略不计。

当我们在`v-text`的元素中添加子节点，这个子节点包括`textContent`或者其他节点类型的话，会在编译时就报错，报错信息如下：

![[Pasted image 20250813143743.png]]

这个是从语法层面的规范，利好团队协作，然后其他开发看一眼就知道这个 dom 的意图，不要往它子节点添加东西。

## v-html 和 xss

### 基础用法

```js
<template>
	<div v-html='richText'></div>
</template>
<script setup>
const richText = ref(`
	<div style="font-family: Arial, sans-serif;">
		<h1 style="color: #333;">这是富文本标题</h1>
		<p>这是一段<strong>加粗文本</strong>和<em>斜体文本</em>。</p>
		<ul style="list-style-type: circle;">
			<li>列表项 1</li>
			<li>列表项 2</li>
		</ul>
		<p>
			<a href="https://wyc7758775.github.io/yoran-secret/" style="color: blue;">
				这是一个链接
			</a>
		</p>
	</div>
`);
</script>
```

和`v-text` 最大的不同，就是不转移标签`<`这些，直接渲染。所以这也带来了一个问题，那么就是 [[xss]] 攻击。

### xss 攻击

```HTML
<!-- v-html 面对图片的攻击 -->
<button @click="changeHtml">开始攻击</button>
<div v-if="isAttack" v-html="xssHtml"></div>
```

```js
// xss 攻击测试
const xssHtml = ref(
  `<img src="x" onerror="alert('XSS攻击成功!');window.location.href='https://wwww.baidu.com'">`
);
const isAttack = ref(false);
const changeHtml = () => {
  isAttack.value = true;
};
```

点击"开始攻击"之后，就会触发`alert`以及后面的页面跳转。如果这个图片公共显示的，那么每一个用户打开这页面都会出发 `alert`，然后就跳转到什么乱七八糟的地址上面去。

而如果使用插值指令的话, 就会直接显示出来，因为插值指令会自动转义。

```html
<button @click="changeHtml">开始攻击</button>
<div v-if="isAttack2">{{ xssHtml }}</div>
```

![[Screenshot 2025-08-13 at 16.50.23.png]]

上面的例子不足够贴近实际业务，它通常出现在评论区中。

```html
<<textarea v-model="xssRichTextType" />
<button @click="saveRichText">保存</button>
<div v-html="xssRichText"></div>
```

`textarea`作为输入框，而下面的`xssRichText`作为评论区渲染的插值。JS 如下：

```js
const xssRichText = ref("请输出内容");
const saveRichText = () => {
  const rawHTML = document.getElementById("rich").innerHTML;
  xssRichText.value = xssRichTextType.value;
};
```

随后在输入框 中输入“\<img src="x" onerror="alert('XSS 攻击成功!') /\>”，点击保存按钮，会立即触发`alert` 时间，造成[[xss]]攻击。

> 如果将 textarea 替换成`<div contenteditable> </div>` 构成了多文本输入框的时候，它也是会自动转义标签的，这个是基于浏览器自身的安全策略。[[tiptap]] 这个第三方库的核心输入区域也是基于 HTML 的 contenteditable 属性实现的。所以如果是基于输入框中输入的文本是不会造成 xss 攻击的，所以只需要后端对于他们数据进行防范即可。

基于 html 的 contenteditable 属性的值为“&lt;imgsrc=\"x\" onerror=\"alert('XSS 触发成功')\"&gt;”。

**&lt; 转化为 \&lt;**

### 如何防范[[xss]]攻击

应对 xss 攻击，后台比前端更加的合适，这个是基于逻辑内聚的工程角度思考的。因为前端可以只需要面对 xss 攻击，但是后台还需要面对其他各种安全问题，所以集中在后台处理是更加好的选择。双端都处理的话，无疑会造成的资源的浪费。

前端的话，可以使用`import DOMPurify from "dompurify";` 来解决。使用方式如下：

```js
const sanitizedHtml = computed(() => DOMPurify.sanitize(xssRichText.value));
```

## v-if & v-else & v-else-if 和 v-show

### `display: none` 和 `visibility: hidden`

v-show 为 false 本质就是`display: none`。一般是用来和`v-if`来进行对比，`v-if`是一种惰性指令，如初始化为 false 的时候，不会渲染出来，而 `v-show` 为 false 的时候，组件依然会被渲染，只是不展示而已。

`visibility: hidden`属性还没有内置的指令。还是它任何值得一提，它也会隐藏组件，但是依旧保留原本的位置。

频繁切换显示/隐藏时，优先考虑  `v-show`（需完全移除布局）或  `opacity: 0`（需保留交互）。

> opacity: 0 会保留布局占位，和 visibility 一样。

## v-once & v-memo

`v-once` 等同于 `v-memo='[]'`。`[]` 意味着没有因为任何元素改变。所以一旦初始化渲染之后，就不再改变, 响应式变量的改变也不会引起界面的变化。

### 基本使用

```html
<button @click="updateItem">更新数据</button>
<ul>
  <li
    v-for="(item, index) in list"
    :key="item.id"
    v-memo="[index === 0 && item.name === '马总']"
  >
    <span>id:</span>{{ item.id }} ----<span>nickname:</span>{{ item.name }}
  </li>
</ul>
```

```js
const list = ref(getData());
list.value.unshift({
  id: 1,
  name: "马总",
});
let index = 0;
const updateItem = () => {
  list.value[index].name = "测试修改";
  index++;
};
```

`v-memo="[index === 0 && item.name === '马总']"`的意思是 index 等于 0，并且 item.name 初始化的时候为‘马总’的时候值的时候，只要有变化，这个对应的 DOM 就会经过 diff 算法，然后渲染界面。

也就是说，不需要判断`index === 0 && item.name === '马总'` 这个是为 true 还是为 false，只要有了变化就会经过 diff 的算法。以下几种情况都会渲染：

- **初始非“马总” → 改为“马总”​**, 触发重新渲染
- **初始非“马总” → 仍非“马总”​**, 复用缓存
- **初始是“马总” → 改为其他值 ​**，触发重新渲染

还有其他的一些使用的方法：
`v-memo='[product.id, product.price]'`, 这是比较常用的方式，表示只要 product.id 和 product.price 任意一个值有了变化就触发重新渲染。

`v-memo` 指令会根据指令的依赖数组来判断是否需要对比虚拟 DOM。如果依赖数组中的值没有发生变化，Vue 会直接跳过对比，从而避免不必要的 DOM 操作。所以对于性能优化而言，它的作用在于减少 diff 算法哪一部分。

> [[vapor]]出来之后，v-memo 的使用场景可以更加的少，需要更加新的精细化。

### 业务场景

可以具体看`v-memo-business-demo.vue`这个文件。

## v-slot

### 基本使用

#### 默认插槽

```html
<SlotChild>
  <template #default>
    <div>
      <h3>1.1 带 template 默认插槽的内容1</h3>
    </div>
  </template>
</SlotChild>
```

`SlotChild.vue`

```html
<div>
  slot-child 默认插槽
  <slot :data="data"></slot>
</div>
```

渲染如下：
![[Pasted image 20250813204503.png]]

#### 具名插槽

```html
<SlotChild>
  <template v-slot:header>
    <div>
      <h3>2.1 带 template 具名插槽的内容1</h3>
    </div>
  </template>
</SlotChild>
```

`v-slot:header` = `#header`

支持动态插槽名，如下：

```html
<SlotChild>
  <template v-slot:[dynamicSlotName]>
    <div>
      <h3>2.1 带 template 具名插槽的内容1</h3>
    </div>
  </template>
</SlotChild>
```

#### 作用域插槽

```html
<SlotChild v-slot="{ data }">
  <p>{{ data.nickName }}</p>
  <p>{{ data.age }}</p>
</SlotChild>
```

或者如下写法：

```html
<template>
  <Child>
    <!-- 作用域插槽：v-slot 可简写为 # -->
    <template #default="scope">
      <p>用户：{{ scope.data.nickName }}</p>
      <p>消息：{{ scope.data.age }}</p>
    </template>
  </Child>
</template>
```

SlotChild.vue 中如下：

```html
<slot :data="data"></slot>
<script setup>
  const data = ref({
    nickName: "yoran",
    age: 18,
  });
</script>
```

也可以用在具名插槽中：

```html
<slot name="header" :data="headerData"></slot>
```

使用的时候如下：

```html
<SlotChild>
  <template #header="headerScope">
    <h1>{{ headerScope.data.title }}</h1>
  </template>
</SlotChild>
```

## v-cloak

**_本质：通过 CSS 隐藏带有  `v-cloak`属性的元素（例如  `[v-cloak] { display: none; }`）。_**

用于判断当前组件是否依旧渲染完毕了，渲染完毕再漏出来，避免界面出现如下的样子：

```
<div>
	{{ msg }}
</div>
```

让用户直接看到插值指令。

现在基本已经不需要使用到`v-cloak` 这个内置的指令了，过时了，vue3 时代不存在这样的情况。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[HTTP 协议]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Network/HTTP 协议</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Network/HTTP 协议</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[<img width="60%" src="https://yoran-images-1256970527.cos.ap-guangzhou.myqcloud.com/20250824213628776.png" />  HTTP 协议 HTTP 协议可以等同于合同，大家按照合同办事就好，这个大家指的是浏览器和服务端，换句话来说就是它们之间的通信规则。 它本身是没有什么业务逻辑的，只存在通信规则的逻辑，所以我们作为一个 WEB 前端的开发而言，平时接触的 fetch 和 Axios 都是对于 HTTP 协议的使用。 所以我们学习的重点放在如下地方： 1. 业务开发的高频问题    1. 跨域（...]]></description>
            <content:encoded><![CDATA[<img width="60%" src="https://yoran-images-1256970527.cos.ap-guangzhou.myqcloud.com/20250824213628776.png" />

# HTTP 协议

HTTP 协议可以等同于合同，大家按照合同办事就好，这个大家指的是浏览器和服务端，换句话来说就是它们之间的通信规则。

它本身是没有什么业务逻辑的，只存在通信规则的逻辑，所以我们作为一个 WEB 前端的开发而言，平时接触的 fetch 和 Axios 都是对于 HTTP 协议的使用。

所以我们学习的重点放在如下地方：

1. 业务开发的高频问题
   1. 跨域（CORS）
   2. 缓存优化（强缓存和协商缓存）
   3. 上传/下载进度
   4. 鉴权（JWT、 Cookie）
2. 性能提升
   1. HTTP/2 和 HTTP/3 带来的特性
3. 调试和后端协作技巧
   1. 接口调式（看得懂 Network 面试，请求方法、状态码、请求头/响应头，快速定位问题）
   2. 和后端协作（method、参数格式、返回格式，扩展的知识点 RESTfull 和）

> 推视频课程: https://www.bilibili.com/video/BV1rt4y1m7o5?p=5
> 推介书籍：《图解 HTTP 》

## HTTP 协议包含的内容

1. 请求报文

```http
GET /api/data HTTP/1.1      ← 起始行
Host: example.com           ← 头部
User-Agent: Chrome
Accept: application/json    ← 空行分隔头部和主体
                            ← 主体（此请求没有主体）
```

- 第一行：请求方法（GET）、资源路径（/index.html）、协议版本（HTTP/1.1）。
- 后续行：请求头（描述浏览器信息、可接受的内容类型等）。

2. 响应报文

```http
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<!DOCTYPE html>
<html>...</html>
```

- 第一行：协议版本、状态码（200）、状态描述（OK）。
- 后续行：响应头（内容类型、长度等）。
- 空行后是响应体（实际返回的 HTML 内容）。

实际的场景 network 显示如下：

<img width="60%" src="https://yoran-images-1256970527.cos.ap-guangzhou.myqcloud.com/20250824232530716.png" />

**请求头如下：**

```http
GET /yoran-secret/observer-detail.html?src=/life/xxxxx.md HTTP/2
Host: wyc7758775.github.io
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:141.0) Gecko/20100101 Firefox/141.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate, br, zstd
Sec-GPC: 1
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
If-Modified-Since: Sun, 24 Aug 2025 12:30:13 GMT
If-None-Match: W/"68ab05d5-4660"
Priority: u=0, i
```

**响应头如下：**

```http
HTTP/2 304
date: Sun, 24 Aug 2025 15:02:39 GMT
via: 1.1 varnish
cache-control: max-age=600
etag: W/"68ab05d5-4660"
expires: Sun, 24 Aug 2025 15:12:39 GMT
x-served-by: cache-qpg1224-QPG
x-cache: MISS
x-cache-hits: 0
x-timer: S1756047759.443579,VS0,VE242
vary: Accept-Encoding
x-fastly-request-id: f28eeca139135be912285ed1f25113ba29ddc43a
X-Firefox-Spdy: h2
```

> 想要在 network 面板中查看 HTTP/2 的只能在火狐中查看，谷歌浏览器看不到。具体请看：https://stackoverflow.com/questions/40800140/how-does-view-source-in-response-headers-go-missing-for-certain-sites

## 业务开发高频问题

### 跨域（CORS）

JSONP、服务器反向代理（ng 配置和 vite 配置 proxy）、服务端配置白名单

1. ~~JSONP~~： 已经不在使用

2. Vite 的 proxy 配置：

```js
server: {
	proxy:{
		"/api": {
			target: "http://xxx.xxx.xx.x:8080",
			changeOrigin: true, // 允许跨域
			secure: false, //忽略安全证书
			rewrite: (path) => path.replace(/^\/api/, '')
		},
	},
}
```

当我需要请求的地址为`http://xxx.xxx.xx.x:8080/user/login`  则我们在 vue 里使用 axios 发起请求为 `axios.get('/api/user/login')`。

3. 生产环境 NG 配置

**生产环境使用 Nginx 反向代理 ​**​：

部署时通过 Nginx 配置反向代理，将前端静态资源（如  `https://your-domain.com`）的请求转发到跨域接口（如  `https://api.other-domain.com`）。

```nginx
server {
  listen       443 ssl;          # 监听 HTTPS 端口
  server_name  api.example.com;   # 实际域名

  # SSL 证书配置（替换为实际证书路径）
  ssl_certificate /path/to/fullchain.pem;   # 证书文件
  ssl_certificate_key /path/to/privkey.pem; # 私钥文件

  # 强制 HTTP 跳转 HTTPS（可选）
  if ($scheme != "https") {
    return 301 https://$host$request_uri;
  }

  # 反向代理规则（同上）
  location /api {
    proxy_pass http://localhost:8080/api;
    proxy_set_header Host $host;
    # ...其他头信息
  }
}
```

### 缓存优化（强缓存和协商缓存）

具体看[[HTTP 缓存机制]]

### 上传/下载进度

浏览器对于这部分的实现有两种方式，`fetch`和`XHR`。

`XHR`作为传统的网络实现，自带了`progress`事件实现监听下载进度，自带`upload`属性用于监听上传进度。

```js
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://example.com/large-file.zip");

// 监听下载进度
xhr.addEventListener("progress", (e) => {
  if (e.lengthComputable) {
    const percent = (e.loaded / e.total) * 100;
    console.log(`下载进度：${percent.toFixed(1)}%`);
  } else {
    console.log("总大小未知，无法计算百分比进度");
  }
});

// 监听上传进度
const upload = xhr.upload;
upload.addEventListener("progress", (e) => {
  if (e.lengthComputable) {
    const percent = (e.loaded / e.total) * 100;
    console.log(`上传进度：${percent.toFixed(1)}%`);
  } else {
    console.log("总大小未知，无法计算百分比进度");
  }
});

xhr.onload = () => {
  console.log("下载完成");
};
xhr.send();
```

`Fetch` API 的不提供，需要`ReadableStream` 和 请求头配置`Content-Length`来获取上传的进度，比较复杂，这里不展开说，我也没记住, 核心就是 fetch 需要配置其他的 API 来实现 xhr 中对应的功能，包括中断请求。

```js
const file = ... // 你要上传的文件
let uploaded = 0;
const total = file.size;
const stream = new ReadableStream({
	async start(controller) {
		const reader = file.stream().getReader();
		while (true) {
			const { done, value } = await reader.read();
			if (done) break;
			controller.enqueue(value);
			uploaded += value.length;
			// 这里可以更新进度条
			console.log(已上传: ${uploaded} / ${total});
		}
		controller.close();
	}
});

fetch('/upload', {
	method: 'POST',
	body: stream,
	headers: {
		'Content-Type': 'application/octet-stream',
		'Content-Length': total
	}
});
```

### 鉴权（JWT、 Cookie）

HTTP 协议是无状态的。

无状态的概念就是服务器不会通过 HTTP 协议来判断你是谁，不知道你是谁，自然就不会联系上下文，你不知道你知道问过什么？因为服务器要应对的不单单是你一个人。

**举个例子 🌰**：

- **有状态**：你和朋友聊天，朋友记得你之前说过的话（比如：“你上次说要去旅游，去了吗？”）。
- **无状态**：你每次给客服打电话，客服每次接电话都像第一次见你（比如你第一次说“我要订餐”，第二次说“我要付款”，客服不会自动关联这两次请求）。

设你用浏览器访问一个网站：

1. 第一次请求：你登录网站，服务器返回“登录成功”。
2. 第二次请求：你点击“查看购物车”，**服务器不知道你是谁**，因为它没记住你上次登录过！

**结果**：你每次操作（比如查看购物车、下单），服务器都像第一次见到你，需要你反复证明自己的身份。

- **简单高效**：服务器不用费心思记每个用户的状态，能轻松处理海量请求。
- **适合早期网页**：早期的网页只是展示静态内容（比如新闻），不需要记住用户。

所以问题就来了，我们实际业务中，确实是需求知道用户是谁的。那么就用以下的其他手段来解决这个问题了（扩展）

#### **方法 1：Cookie**

- 原理：服务器在第一次返回响应时，通过`Set-Cookie`头告诉浏览器：“存一个身份证（Cookie）”。
- 后续请求：浏览器每次自动带上这个 Cookie，服务器就知道你是谁了。
- 例子：登录后，服务器给你一个 Cookie，之后你每次访问页面都自动带着它，服务器就知道你是已登录用户。

#### **方法 2：Session**

- 原理：服务器在内存或数据库中存一个用户状态（比如 Session ID），通过 Cookie 把 Session ID 传给浏览器。
- 例子：你登录后，服务器生成一个 Session ID 存起来，并通过 Cookie 给你，后续请求用这个 ID 找到对应的 Session 数据。

#### **方法 3：Token（如 JWT）**

- 原理：服务器生成一个加密的 Token（令牌），里面直接包含用户信息，浏览器每次请求带着这个 Token。
- 例子：登录后服务器返回一个 Token，后续请求在`Authorization: Bearer <token>`头中带上它，服务器解密后就知道你是谁。

但是这样不是违背初衷了吗？直接给 HTTP 设计为有状态的不就可以了吗？如果面试官问：“HTTP 无状态是缺点吗？为什么不直接设计成有状态？”

**可以回答**： **“HTTP 的无状态设计是权衡后的结果。早期为了简单高效，它不需要维护状态，适合传输静态资源。后来为了满足动态交互需求，通过 Cookie 等机制在应用层扩展了状态管理，而不是修改协议本身。这种分层设计既保持了 HTTP 的轻量，又让开发者能灵活应对业务需求。”**

Cookie 和 JWT 的区别：

- ​Cookie 的局限性 ​：依赖同源策略，跨域（如前端  `app.example.com`调用后端  `api.example.com`）需额外配置 CORS，且 Cookie 无法直接用于移动端（无浏览器环境）。
- ​JWT 的优势 ​：作为请求头（如  `Authorization: Bearer <token>`）的一部分，天然支持跨域；移动端可直接存储 Token 并随请求发送，无需依赖 Cookie。

> JWT 或 Cookie 的使用场景高度依赖后端的架构设计、技术选型和业务需求 ​​。前端的选择往往是“被动适配”。

## 提升性能和体验

- HTTP/0.9
  - 仅支持 Get 请求
  - 仅支持 HTML 格式资源
- HTTP/1.0
  - 增加 POST 和 HEAD 请求方式
  - 支持多种数据格式的请求和访问
  - 支持 cache 缓存功能
  - 新增状态码、多字符集支持、内容编码等
  - 早起 HTTP/1.0 不支持 Keep-alive 长连接,只支持串行连接
  - 后期 HTTP/1.0 增加 Connection:keep-alive 字段(非标准字段),开始支持长连接
- HTTP/1.1
  - 增加持久连接（默认开启 Connection: keep-alive)
  - 增加管道机制（支持多个请求同时发送）
  - 增加 PUT/PATCH/OPTION/DELETE 等请求方式
  - 增加 Host 字段（指定服务器域名）-＞案例：搜素百度 查看 network
  - 增加 100 状态码 (Continue）,支持貝发送头信息
  - 扩展身份认证机制（配合 SSL 实现数据的安全传输）
  - 支持传送内容的一部分和文件断点续传
  - 新增了 24 个错误状态码
- HTTP/2.0
  - 新增双工通道(客户端同时发起多个请求,服务端同时处理多个请求)
  - 服务端推送(服务器会把客户端需要的资源一起推送到客户端,合适加载静态资源)
  - 头信息压缩机制(每次请求都会带上所有信息发给服务端)(HTTP 协议不带状态)
  - 二进制协议(头信息和数据体使用二进制进行压缩)
  - 多工(新增会先发送已处理好的部分，再响应其他请求，最后再处理没有处理好的部分)
- HTTP/3（2018 年草案，2020 年正式发布）
  - 底层协议变革：
    - 基于 QUIC 协议（UDP 实现），避免 TCP 的队头阻塞，提升移动网络下的连接稳定性 18；
    - 0-RTT 建连：复用会话上下文，减少握手延迟 12；
    - 独立流控制：每个数据流独立处理，丢包不影响其他流 68；
    - 连接迁移：通过`Connection ID`标识连接，切换网络时无需重建 12。
  - 意义：为高延迟、高丢包场景（如 5G、物联网）提供更优性能 28。

版本更新中有一些 feature 扩展:

- `keep-alive`
  - 每次请求都需经历 ​**​TCP 三次握手 ​**​（建立连接）和 ​**​ 四次挥手 ​**​（关闭连接）的开销（约 100ms~300ms，取决于网络延迟）；
  - 若网页包含多个资源（如图片、CSS、JS），每个资源都需单独建立 TCP 连接，导致“连接数爆炸”（例如一个页面加载 10 个资源，需 10 次 TCP 连接）, `keep-alive` 解决的就是这个。
- 双工通道（`keep-alive` 的 patch）
  - 多个请求共享同一个 TCP 连接，服务端只需维护少量长连接（如 1 个连接处理 100 个请求），资源利用率更高。
  - 10 个资源的请求通过多路复用并行传输，总耗时接近单个请求的延迟（如 100ms），加载速度提升 90%。 而`keep-alive`还是要串行传输，用时 1000ms。
- QUIC
  - 融合 UDP 性能和 TCP 的可靠性

这三点也是重要的性能提升，除此之外，还有配置`Content-Encoding: gzip` ，应用层调用压缩算法对于请求头和响应头进行压缩，降低传输数据的负载，这个也是一个很重要的性能优化。

## 调试和后端协作

RESTfull 规范参考路径：https://www.ruanyifeng.com/blog/2014/05/restful_api.html

- 通用 HTTP 状态码

| 类型 | 说明                                          |
| ---- | --------------------------------------------- |
| 1xxx | 信息,服务器收到请求,需要请求者继续执行操作    |
| 2xxx | 操作成功并被接受处理                          |
| 3xxx | 重定向,需要进一步的操作以完成请求             |
| 4xxx | 客户端错误,请求包含语法错误或无法完成请求     |
| 5xxx | 服务器端的锅,服务器在处理请求的过程中发生错误 |

#### 304 重定向

重定向的出现和[[HTTP 缓存机制]]有直接的关系.
在 HTTP 响应报文是默认配置的情况下,页面在已经访问过之后,再次访问的话,就有**可能**返回 304 的状态. 数据是直接从缓存中拿.

#### 503 服务器错误

找后台去处理吧
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[NodeJS-net 模块]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Network/NodeJS-net 模块</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Network/NodeJS-net 模块</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[NodeJS-Net 模块  1. 前言 这是 nodeJs 系列的第一篇文章, 我之前看教程的时候,很多都是从 IO、buffer、path、event、fs、process、node 事件循环机制开始说起的. 这些确实是 node 开发主要依赖的开发依赖. 但是我比较着急, 从了解到 node,就是说 node 可以干后端的话,但是这些课程前半截都在说它拥有的能力,就是最后才到如何和客户端通信的模块介绍. 我很难受,所以在我自己写总结的时候,一定要写先服务端和客户端通信的模块才舒服.即便过程中涉及到了 event 模块、fs 模块的知识点,可以暂时搁置,只从整体来理解net模块如何实现通信...]]></description>
            <content:encoded><![CDATA[# NodeJS-Net 模块

## 1. 前言

这是 nodeJs 系列的第一篇文章, 我之前看教程的时候,很多都是从 IO、buffer、path、event、fs、process、node 事件循环机制开始说起的. 这些确实是 node 开发主要依赖的开发依赖. 但是我比较着急, 从了解到 node,就是说 node 可以干后端的话,但是这些课程前半截都在说它拥有的能力,就是最后才到如何和客户端通信的模块介绍.

我很难受,所以在我自己写总结的时候,一定要写先服务端和客户端通信的模块才舒服.即便过程中涉及到了 event 模块、fs 模块的知识点,可以暂时搁置,只从整体来理解`net`模块如何实现通信的.

## 2. OSI 七层协议模型

想要学明白通信模块,就不得不了解网络通信模型,想要记住网络通信模型,就不得不实际操作来辅助记忆. 这个是面试的重点. 这一块内容很多,想要跟深入的了解,还说需要体系的学习的. 这里只是简单提提.

寄出这张老图:

![image_1649504393157_0.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70cb406271a845e58bc995cfac865768~tplv-k3u1fbpfcp-watermark.image?)

对于我们前端而言, 需要记住 TCP/IP 协议簇的体系结果既可.

- 应用层: http(80 端口)、FTP(21)、SMTP(发送邮件)、POP(接收邮件)、DNS

- 传输层: TCP/ UDP

- 网际层: IP,ICMP(是 IP 层的附属协议)

- 数据链路层: PPP, SLIP

- 物理层: 网有双绞线、同轴电缆、光纤等传输方式, 遵循 ISO2110 规范

从`ICMP`这种依附于 IP 协议的协议可以知道,对于网络协议的分层不用过于较劲. `ICMP`明明需要 IP 协议为基础,但是它也被规划为网络层. 我们对于 OSI 模型的正确的认识,我认为应该是用 OSI 模型来进行问题的分析比用来对于协议进行所谓的分层更加来得有意义.

> TCP/IP 协议簇 并不是只是指 TCP 和 IP 协议,只是因为这两个协议过于出圈,所以就用 TCP/IP 来统称互联网相关联的协议集合起来. 还有另外一种说法是,在使用 TCP/IP 协议过程中使用到的协议族的统称.

而客户端和服务端的传输流如下

![图片_1649505674172_0.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f3e15811b04cd5814185571b799279~tplv-k3u1fbpfcp-watermark.image?)

如果角色变成`发送者`和`接受者`的时候,传输流如下图:

![图片_2_1649505888621_0.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63933f8d4454244bc1397d04ea01d48~tplv-k3u1fbpfcp-watermark.image?)

 可以看出来传输的过程中,从发送端开始,没经过一层协议都会加上所需要的首部信息.层层把关,层层加码. 然后到了接收端的时候, 就反而行之, 每经过一层都剥去对应的首部. 只等到最后拿到的 HTTP 数据.

> 上面图片出自《图解 HTTP》

上面就是大体的网络协议模型.

疑惑: 为什么书上和很多地方在把 OSI 体系结果中合并成 TCP/IP 五层协议之后,网络层的名称会变成网际层呢?

## 3. TCP 连接

![image_1649509541746_0.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07786cf55a4246c5b91a5d1059111f8a~tplv-k3u1fbpfcp-watermark.image?)

第一次握手: 客户端向服务端发送 SYN 标志位(序号是 J), 并进入 SYN_SENT 状态(等待服务端确认状态)

第二次握手: 服务端收到来自客户端的 SYN J, 服务端会确认该数据包已收到并发送 ACK 标志位(序号是 J + 1)和 SYN 标志位(序号是 K), 随后进入 SYN_REVD 状态(请求接受并等待客户端确认状态)

第三次握手: 客户端进入连接建立状态后,向服务端发送 ACK 标志位(K+ 1) , 确认客户端已收到建立连接,服务器收到 ACK 标志后,服务端进入连接已建立状态.

> J 和 K 都是为了确立是谁在请求. SYN 和 ACK 的结构没有什么不同,只是发送的对象不一样.

## 4. net 模块

`net模块`就是对于上面 TCP 连接的具体实现.

首先, 学习 API 依旧推荐直接进入[官方文档](https://nodejs.org/dist/latest-v17.x/docs/api/net.html). 其中[中文文档](http://nodejs.cn/api/index.html)内容不会是最新版本的

> 在学习的时候,能够有时间看英文文档就尽量看英文文档. 对于这一点我坚持了半年. 从一开始看不下去,直到现在能够可以忍住不舒适感看下去. 半年时间进步就很明显了. 而且这种不舒适感是一件好事,说明这个不是你的舒适区,毕竟勇于跨过自己的舒适区才是进步的源泉

接下来,进行正题.既然要学习通信,那么我们就需要两个对象来模拟客户端和服务端.分别建立`client.js`和`service.js`两个文件. 通过命令行创建:

```bash
touch client.js && touch service.js
```

### 4.1 service.js 部分

 引入`net`模块,并让服务器进入`LISTENT`状态, 以及配置端口号和 HOST 地址(手动略过 DNS 解析过程), 等待客户端的召唤

```js
const net = require("net");
const post = 3306;
const host = "127.0.0.1";

const server = net.createServer();
server.listen(post, host);
```

此时服务器对应了 TCP 连接中服务器`LISTEN`状态.

随后监听一些必要的事件,也就是 server 提供的钩子. (属于 event 相关知识)

```js
server.on("listening", () => {
  console.log("服务器已经可以连接啦");
});

server.on("connection", (socket) => {
  console.log("有客户端来访咯");
});

server.on("close", () => {
  console.log("服务器关闭了");
});

server.on("error", (error) => {
  console.log("服务器出错啦: ", error); // error 有错误的信息
});
```

上面这一串代码涉及到了,

- `listening`: 监听端口后出发的事件
- `connection`: 有客户端来访的时候触发事件
- `close`: 服务器关闭触发
- `error`: 服务器出错触发

对于`close`我们需要注意的是,后台大哥一般是直接

```bash
ps
kill -9 pid
```

通过杀死线程的方式来进行的

在`connection`狗子中, 形参是 socket 命名. 它的中文翻译为嵌套字, 被 node 封装成了 stream(流).在可以粗浅的理解为就是客户端发送过来的数据. 这是这个数据自身是有方法的. 我在`connection`中对`socket`来进行处理

```js
server.on("connection", (socket) => {
  console.log("有客户端来访咯");

  socket.on("data", (data) => {
    console.log(data); // 客户端发送过来的数据
  });
});
```

> stream 以后的文章会进行介绍.

服务端既然能够接受客户端发过来的数据,自然也能够给客户端回复. 在`socket.on`中写入(当然也可以写在外面):

```js
socket.write("我已经收到你的服务器了哦,客户端");
```

此时如果客户端已经完成了数据的接受,然后关闭了连接.我们可以也可以通过`socket.on('close‘)`钩子监听到:

```js
socket.on("close", () => {
  console.log("客户端把另外一头的流给关了");
});
```

对于`socket`事件的总结放入`client.js`中.
此时`service.js`的所有内容如下:

```js
const net = require("net");
const post = 3306;
const host = "127.0.0.1";

const server = net.createServer();
server.listen(post, host);

server.on("listening", () => {
  console.log("服务器已经可以连接啦");
});

server.on("connection", (socket) => {
  console.log("有客户端来访咯");

  socket.on("data", (data) => {
    console.log(data); // 客户端发送过来的数据

    socket.write("我已经收到你的服务器了哦,客户端");
  });

  socket.on("close", () => {
    console.log("客户端把另外一头的流给关了");
    server.close(); // 客户端已经不要数据了,那么我们就把服务器给关闭了吧
  });
});

server.on("close", () => {
  console.log("服务器关闭了");
});

server.on("error", (error) => {
  console.log("服务器出错啦: ", error); // error 有错误的信息
});
```

### 4.2 client.js 部分

客户端的就简单很多.

```js
const net = require("net");
const post = 3306;
const host = "127.0.0.1";

const socket = net.connect(post, host);

socket.on("connect", () => {
  console.log("已经连接到服务器了哦");
});

socket.write("服务器, 我来了");
socket.on("data", (data) => {
  console.log(data.toString());
  socket.end();
});

socket.on("close", () => {
  console.log("连接已关闭了");
});
```

对于`socket`的事件的总结

- `connect`: 成功和服务器连接触发
- `data`: 接受到服务器发过来的参数
- `end`: 数据接收完毕之后可以触发
- `close`: socket 关闭触发

`service.js`和`client.js`框架已经写完, 那些先后在打开两个终端运行他们:

```bash
node service.js
node client.js
```

自行查看打印的结果.

整个 TCP 连接的框架大体就已经完成了. 当然实际的生产远远不止这些. 还要处理粘包、拆包/封包, 心跳包等等.

下一篇会结合实际浏览器发起请求来继续完善对于`net`模块的描述.
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[NodeJS-net 模块和 Http 模块]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Network/NodeJS-net 模块和 Http 模块</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Network/NodeJS-net 模块和 Http 模块</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[NodeJS-net 模块和 Http 模块  前言 这节内容会设置到如何完整的展示一个 html 页面,以及其上的图片样式. 其中涉及到了 fs 模块的知识和 buff 的概念. 要渲染一个 html 页面,自然就要涉及到报文, 所以也会简单的解释一下报文的概念. 正文如下.  HTTP 报文 在 TCP/IP 协议中,我们经常会听到请求报文,响应报文这样的字眼. 顾名思义. 由于 B/S 架构的标准是基于 HTTP 协议，客户端发送请求，服务器给出响应的一问一答形式进行通信。所以很明显, 请求报文就是客户端发出的, 而响应报文就是服务端发给客户端的,从语义而知,是为了回复请求,所以要响应....]]></description>
            <content:encoded><![CDATA[# NodeJS-net 模块和 Http 模块

## 前言

这节内容会设置到如何完整的展示一个 html 页面,以及其上的图片样式. 其中涉及到了 fs 模块的知识和 buff 的概念.
要渲染一个 html 页面,自然就要涉及到报文, 所以也会简单的解释一下报文的概念.

正文如下.

## HTTP 报文

在 TCP/IP 协议中,我们经常会听到`请求报文`,`响应报文`这样的字眼.

顾名思义. 由于 B/S 架构的标准是基于 HTTP 协议，客户端发送请求，服务器给出响应的一问一答形式进行通信。所以很明显, `请求报文`就是客户端发出的, 而`响应报文`就是服务端发给客户端的,从语义而知,是为了回复请求,所以要响应.

它们可以统称为`HTTP报文`, 作用就是用于规范信息的格式. 所以也叫`协议`.

`协议`类比到我们生活中, 我们在入职新公司的,就需要牵劳动合同,保密协议, 这些都是协议, 他们都是有固定需要需要的内容, 比如说甲方、乙方、日期、印章、正文等. 如果没有这些固定的内容话,那么协议就没有任何意义.

`HTTP报文` 也是如此,它有固定的格式,你只要按照这个格式填写上对应的信息, 客户端和服务端才能够识别出你的意思, 才算是一个有效的协议.

`HTTP报文`的格式如下:

![http报文.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18a6b92d4af44241958c86fa92843b25~tplv-k3u1fbpfcp-watermark.image?)

图片出自《图解 HTTP》. 上面是`请求报文`, 下面是`响应报文`.

- 报文主体是不一定要有的

如图所示, 隐藏的内容还有换行,空行等. 对应的实体是`\r`和`\n`.

对于图中各个字段的作用和含义, 可以自行参考图解 HTTP.

## net 模块展示完整的网页

知道了`HTTP报文`相关的概念之后,我们来通过代码来展示报文的具体结果.

和上一章内容一样 net 模块的. 创建我们的服务

```js
// netBrewer.js
const net = require("net");
const post = 3306;
const host = "127.0.0.1";

const server = net.createServer();
server.listen(post, host);

server.on("listening", () => {});
server.on("connection", (socket) => {
  // 浏览器对该域名发起的请求
});
```

随后命令行中输入`node server.js`

打开浏览器,输入`http://localhost:3306?params=1`, 并在`connenction`监听请求的报文

```js
server.on("connection", (socket) => {
  socket.on("data", (data) => {
    console.log(data.toString());
  });
});
```

在控制台就可以看到浏览器的请求报文:

![截屏2022-04-10 22.18.37.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6aa63ae2ff1422396a452669b9d9595~tplv-k3u1fbpfcp-watermark.image?)

也正好和上一节`HTTP报文`对应上了.

此时浏览器就会一直在转圈圈,因为它接收不到服务器响应内容, 所以我在下面中输入要`响应的报文`

```js
server.on("connection", (socket) => {
  socket.on("data", (data) => {
    socket.write("HTTP/1.1 200 OK\r\n\r\n<html><body>hello world</body><head>");
    socket.end();
  });
});
```

值得注意的是,一个报文必须要以`socket.end()`来告诉浏览器数据结束了. 不然它依旧会是转圈圈的状态.

> `socket.end()` 不能写在`socket.on('data')`的外面.因为`data`是一个微任务, 会先执行`end()`

顺利的话, 重启服务器,然后刷新页面,你就可以在页面中看到`hello world`了.

## 通过 fs 模块来获取`html`文件,并响应给浏览器

现在已经能够正常的让浏览器渲染出内容.接下来,我们更进一步,让浏览器渲染的内容更加的贴近我们的实际开发.

我们在使用`react`和`vue`开发完成之后,`npm run build`出来的入口文件一般来说都是`index.html`. 让我们来模拟这一个文件.

创建`index.html`并输入内容

```js
touch index.html
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Test</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- <link href="css/style.css" rel="stylesheet"> -->
  </head>
  <body>
    <h1>今日你学习了嘛?</h1>
    <img src="./img.png" />
  </body>
</html>
```

通过 fs 模块来读取该文件:

```js
server.on("connection", (socket) => {
  socket.on("data", (data) => {
    const dataFile = fs.readFileSync(__dirname + "/index.html");

    console.log(dataFile.toString());

    socket.write("HTTP/1.1 200 OK\r\n");
    socket.write(dataFile);

    socket.end();
  });
});
```

可以在控制台中看到打印出来的`index.html`的字符串. 刷新一下页面应该也能够看到界面渲染的结果.
意外也在这个时候发生来. 出现了一个报错:

![截屏2022-04-10 22.50.04.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bc284a3549043c297a17f878a08f141~tplv-k3u1fbpfcp-watermark.image?)

favicon.ico 图标用于收藏夹图标和浏览器标签上的显示，如果不设置，浏览器会请求网站根目录的这个图标. 我们现在没有指定 favicon.ico 的内容,为了不让它报错,我们可以可以抛出异常的方式来处理.

```js
try {
  const dataFile = fs.readFileSync(__dirname + "index.html");

  console.log(dataFile.toString());
  socket.write("HTTP/1.1 200 OK\r\n");
  socket.write(dataFile);

  socket.end();
} catch (e) {
  socket.write("HTTP/1.1 200 OK\r\n\r\n<body>404</body>");
  socket.end();
}
```

报错的问题已经解决. 当浏览器指定访问地址的是如何处理呢? 这个时候我们就需要解析`请求报文`的内容来做响应的判断:

```js
const url = data.toString().split("\r\n")[0].split(" ")[1];
```

通过简单的字符串截取,就可以获取当前浏览器访问的文件是什么.

完整的代码如下:

```js
const fs = require("fs");
const net = require("net");
const post = 3306;
const host = "127.0.0.1";

const server = net.createServer();
server.listen(post, host);

server.on("listening", () => {});

server.on("connection", (socket) => {
  socket.on("data", (data) => {
    // 1. 解析请求报文
    const url = data.toString().split("\r\n")[0].split(" ")[1];

    try {
      const dataFile = fs.readFileSync(__dirname + url);

      console.log(dataFile.toString());
      socket.write("HTTP/1.1 200 OK\r\n");
      socket.write(dataFile);

      socket.end();
    } catch (e) {
      socket.write("HTTP/1.1 200 OK\r\n\r\n<body>404</body>");
      socket.end();
    }
  });
});
```

> 在响应报文中, 只有在 chrome 浏览器中可以不配置`contentType:text/html`. 其他浏览器不配置是显示不出来的.
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[SSL 协议]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Network/SSL 协议</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Network/SSL 协议</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[SSL 协议 SSL（Secure Socket Layer），由于 HTTP 协议中传输的数据是明文，所以攻击者能够毫不费力的能够拿到开发者想要保证密文的数据，SSL 就是为了解决这个问题而诞生的，它运用一定的加密解密的策略来解决攻击者获取传输过程中数据的安全。  SSL 协议建立连接的过程  对称加密 对明文进行加密，让攻击者不知道它看到的数据是什么，但是同时又需要让客户端和服务端都能够解密，这样才可以进行沟通。所以对称加密就出现了，它的通过握手过程如下： <img witdh="50%" src="https://yoran-images-1256970527.cos.ap-guangz...]]></description>
            <content:encoded><![CDATA[# SSL 协议

SSL（Secure Socket Layer），由于 HTTP 协议中传输的数据是明文，所以攻击者能够毫不费力的能够拿到开发者想要保证密文的数据，SSL 就是为了解决这个问题而诞生的，它运用一定的加密解密的策略来解决攻击者获取传输过程中数据的安全。

## SSL 协议建立连接的过程

### 对称加密

对明文进行加密，让攻击者不知道它看到的数据是什么，但是同时又需要让客户端和服务端都能够解密，这样才可以进行沟通。所以对称加密就出现了，它的通过握手过程如下：

<img witdh="50%" src="https://yoran-images-1256970527.cos.ap-guangzhou.myqcloud.com/20250825155819211.png" />

1. 预主密钥的生成需要依赖于 TLS 和公开的加密算法，所以双方握手的时候需要同步 TLS 和算法的版本。
2. 密钥 = 加密 + 解密

根据这两点，也就是说攻击者拿到了预主密钥就可以直接加密和解密数据，那么这条数据传输通道将不再安全。

<img width="70%"  src="https://yoran-images-1256970527.cos.ap-guangzhou.myqcloud.com/20250825161152418.png"/>

所以这个时候就需要非对称加密了。

### 非对称加密（PKI）

它分为两个密钥，公钥和私钥

私钥只在服务端内部，中间人可以拿到公钥对数据进行加密，但是它无法使用公钥对数据进行解密。

这样子就能够解决了中间人攻击截获数据得到的真实数据。

过程如下：

![image.png｜300](https://yoran-images-1256970527.cos.ap-guangzhou.myqcloud.com/20250825170212001.png)

这个时候还有一个问题，**就是客户端没有办法判断这个公钥是不是服务端的公钥**，是不是你想要的服务端的那个公钥。中间人自己也可以生成公钥，那就意味着，中间人依旧可以截获客服端发出的信息，自己去和客户端进行沟通，获取到客户端发出的请求。

所以这个所以客户端需要判断当前的公钥是不是我们网站服务端发出的哪个公钥，这个时候就引入了一个身份认证系统，那就是证书。什么证书，它是如何解决这个问题呢？

## 证书，数字证书-Digital Certification

相当于一个网站的身份证信息。没一个证书上面都有一个指纹信息，这个信息是通过申请的证书添加的资料来生成的，是一个通过哈希函数解析出来的散列值，这个就是指纹信息。他是有一个 CA 组织发布，分配在各个国家当中。

整个过程如下：

![image.png](https://yoran-images-1256970527.cos.ap-guangzhou.myqcloud.com/20250825171609840.png)

证书市面上只有几家是可以让浏览器正确认识的，这些公司收到大家的信任，相信它们不会乱搞。

如何结合上 TCP 三次握手的话，这个过程如下：

![image.png](https://yoran-images-1256970527.cos.ap-guangzhou.myqcloud.com/20250825174317201.png)

这个过程称之为 TLS 握手。有什么面试官也会问 SSL 加密的过程是什么？也是这个。

## SSL 和 TLS 的差别

明明标题是 SSL，为什么文章内容都是 TLS？

因为 TLS 就是 SSL，等同于 SLL 3，只是改了一个名字。也可以说 TLS1.0 就等于 SSL 的 3.0。
我们现在使用 TLS 的居多, 但是平时在说 HTTPS 的时候，这个 S 一般都称呼为 SSL 是基于习惯，约定俗成。

那为什么 SSL 要改名为 TLS 呢？**完全是大公司斗争的产物**。

原文地址：https://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html

简单描述如下：

1. Sll 第一个版本被网景开发出来之后，不好用，所以没有发布过。
2. 市面上第一个版本是 sll 2
3. 但是这玩意儿还是存在问题，微软先解决了，并且加入了自己的一些内容，只支持 IE 和另外一个。
4. 网景自己也想 adress 问题，所以就弄了一个 TLS 出来，不使用微软的标准和版本来解决问题

## SSL 的成本和性能

1. SSL 证书需要购买申请，功能越强大的证书费用越高
2. 根据 ACM CONEXT 数据显示，使用 HTTPS 协议会使页面的加载时间延长近 50%，增加 10%到 20%的耗电。
3. HTTPS 连接缓存不如 HTTP 高效，流量成本高。
4. HTTPS 连接服务品端资源占用高很多，支持访客多的网站需要投入更大的成本。
5. HTTPS 协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是来用分而治之，类似 12306 网站的主页使用 HTTP 协议，有关于用户信息等方面使用 HTTPS.

**_上面的这些点都以及过时，在 TLS1.3 和 HTTP2/3 出来的现在，消耗的成本可以忽略不计_**
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[运算符的优先级]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/运算符的优先级</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/运算符的优先级</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[运算符的优先级  我们在讨论的是一个什么问题 - 我们在讨论的是处理计算的优先级.   比如说1 + 2  3 等价于 1 + (2  3). 计算的过程还是从左到右 - 所以说,在实际开发中,你想要谁优先处理,就用括号包裹住,准没错.而且也推荐在实际发开着么干. - 如果从编译器的角度上看的话,我们讨论的是[[AST节点]]和根的距离的问题.   - 简单的说就是在求值的过程中,对于整个 AST 树的遍历是[[后序遍历]], 就是说,理根节点越远就越早被求值.   - 具体可以查看[[JavaScript中运算符优先级]]这篇文章  如何记忆 https://developer.mozill...]]></description>
            <content:encoded><![CDATA[# 运算符的优先级

### 我们在讨论的是一个什么问题

- 我们在讨论的是处理计算的优先级.

  比如说`1 + 2 * 3` 等价于 `1 + (2 * 3)`. 计算的过程还是从左到右

- 所以说,在实际开发中,你想要谁优先处理,就用括号包裹住,准没错.而且也推荐在实际发开着么干.

- 如果从编译器的角度上看的话,我们讨论的是[[AST节点]]和根的距离的问题.
  - 简单的说就是在求值的过程中,对于整个 AST 树的遍历是[[后序遍历]], 就是说,理根节点越远就越早被求值.
  - 具体可以查看[[JavaScript中运算符优先级]]这篇文章

### 如何记忆

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

- 这个是总表. 其实没有必要记忆,因为实际中真的这样写, 得下地狱的.
- 真要用的话,直接去 MDN 查表就行

> 话说,我工作了四年,也就 2021 年才有意识查 MDN 来学习,之前都是直接谷歌百度,有代码报错最多就是 stackoverflow 定向查查看.果然是混了四年.😭

- 关于记忆的口诀,无意间看到掘金上面的这篇文章上面的
  https://juejin.cn/post/6844904048773201927#heading-0

  > **括点油调一成做衣 叫等位裸跳服展昭**

  感觉比我之前想的好太多了,居然的记忆方法可以点开链接去看看.掘金大佬就是有才.
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[迭代器与生成器]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/迭代器与生成器</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/迭代器与生成器</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[迭代器和生成器  前言 重看看红宝书，略微了解到迭代器和生成器这两个概念为什么那么难理解了。 首先是平时直接使用到的机会确实是非常的少，其次就是书上面为了介绍这两个概念使用了非常多的专业的名词来描述，而且相互穿插，能够把人给绕晕了，而且并没有明确的给出这些概念之间的关联。 所以我这篇文章为了辅助我的学习和记忆，着重于迭代器和生成器这关系。 首先简单的描述一下书中是如何描述这两个规范的,  迭代器导读 在迭代器中，先介绍了迭代，在 ES6 之前 for 和 forEach 两个循环的问题，引出了迭代器模式。接下来就自然的介绍迭代器模式，它包含两个概念： 1.  第一个是可迭代协议     介绍了...]]></description>
            <content:encoded><![CDATA[# 迭代器和生成器

## 前言

重看看红宝书，略微了解到迭代器和生成器这两个概念为什么那么难理解了。

首先是平时直接使用到的机会确实是非常的少，其次就是书上面为了介绍这两个概念使用了非常多的专业的名词来描述，而且相互穿插，能够把人给绕晕了，而且并没有明确的给出这些概念之间的关联。

所以我这篇文章为了辅助我的学习和记忆，着重于迭代器和生成器这关系。

首先简单的描述一下书中是如何描述这两个规范的,

## 迭代器导读

在迭代器中，先介绍了迭代，在 ES6 之前 for 和 forEach 两个循环的问题，引出了迭代器模式。接下来就自然的介绍迭代器模式，它包含两个概念：

1.  第一个是可迭代协议

    介绍了它具备的能力，以及实现它的必要条件，最后介绍了当前内置的类型都有那些实现了这个可迭代协议，并且可以接受这些内置类型的原生语言特使包括那些。

2.  第二个是迭代器协议

    介绍了它的基本概念和基本使用方法。了解了了迭代器的协议之后，也可以称呼它们为迭代器的接口，就介绍了自定义迭代器如何实现和一些细则。

但是关于两个协议的关系和职责范围没有总结出来，导致了我对于他们的关系一直很模糊，经常混淆在一起。

总结如下：

| **协议类型 ​**​    | ​**​ 可迭代协议（Iterable Protocol）​**​        | ​**​ 迭代器协议（Iterator Protocol）​**​   |
| ------------------ | ----------------------------------------------- | ------------------------------------------ |
| ​**​ 目的 ​**​     | 定义对象如何被迭代（如 `for...of` 遍历）        | 定义如何按顺序访问元素（如 `next()` 方法） |
| ​**​ 实现方法 ​**​ | 对象需实现 `[Symbol.iterator]()` 方法           | 对象需实现 `next()` 方法                   |
| ​**​ 返回值 ​**​   | 返回一个 ​**​ 迭代器对象 ​**​（符合迭代器协议） | 返回 `{ value: T, done: boolean }` 对象    |
| ​**​ 核心作用 ​**​ | ​**​ 声明对象可被迭代 ​**​                      | ​**​ 实际执行迭代过程 ​**​                 |

也就是所以说，可迭代对象是实现了可迭代协议的对象，迭代器就是实现了迭代器协议的一系列方法。两者也是不同的,相互独立的。

而书中并没有明确的说明这一点，导致我长期认为可迭代对象是包含在迭代器中的，这是错误的认知。而且这一章节的标题只有迭代器而没有可迭代对象，也是直接阻碍我对于他们的理解。差评！

## 生成器导读

在生成器中，先介绍了生成器的写法，包含的元素和生命周期，存在暂停状态，存在`next()`方法，该方法返回的对象也是包含 done 属性和 value 属性。接下来介绍生成器最重要的组成部分：`yield`，被称为生成器最有用的地方。包括如下内容：

1.  中断执行，异步变为同步的关键
2.  yiled 可以传递参数
3.  产品可迭代对象

> yiled 可以中断代码的进程，是它最不一样的地方，也是我们重要需要学习的地方

**生成器和迭代器的关系如下**：

生成器是一种特殊的函数结构，它返回的对象是一个生成器对象，这个生成器对象实现了包含了可迭代对象和迭代器，换句话说这个对象它实现可迭代协议和迭代器协议， 两个协议合起来 JS 引擎对于迭代器模式的具体实现。生成器函数本质上是 JavaScript 语法规范提供的一种**用户自定义的迭代器工厂函数**。

> 生成器（Generator）**不是基于 ES5 的语法糖**，而是 **ES6（ECMAScript 2015）引入的基础语言规范**，需要 JavaScript 引擎在底层实现支持。

第五版的新增了【异步迭代器和同步迭代器】这两小节，就是在说 for-await-of 在内部实现原理。等于把《你不知道的 JavaScript》中册对于迭代器的描述加入了进来。

```js
class Emiter {
  constructor(max) {
    this.max = max
    this.syncIdx = 0
    this.asyncIdx = 0
  }
  // 同步迭代器
  * [Symbol.iterator]() {
    while(this.syncIdx < this.max) {
      yield this.syncIdx++
    }
  }
  // 异步迭代器
  async *[Symbol.asyncIterator]() {
    while(this.asyncIdx < this.max) {
      setTimeout(() => {
        resolve(this.asyncIdx))
      }, Math.floor(Math.random() * 1000) // 默认后台接口返回的的实现不确定的情况
    }
  }
}
```

使用`for-await-of`隐式消费 具体代码如下如下：

```js
const emitter = new Emiter(5);
function syncCount() {
  const syncCounter = emitter[Sysmbol.iterator]();

  for (const x of syncCounter) {
    console.log(x);
  }
}
function asyncCount() {
  const asyncCounter = emitter[Sysmbol.asyncIterator]();

  for (const x of syncCounter) {
    console.log(x);
  }
}
syncCount();
// 0
// 1
// 2
// 3
// 4
asyncCount();
// 0
// 1
// 2
// 3
// 4
```

> 一般来说，只要存在同步迭代器，也会存在异步迭代器。但是并不是说两者同时存在。

如果是我来出这一章节的话，章节名就直接以「迭代器模式和生成器」。生成器和 迭代器 从实现角度而言并不是同层级的东西，他们紧密关联，而且都是 ES 新出的规范，红宝书作者可能基于这个逻辑在标题让他们并列出来。他们之间的关系我用一张图来表示，画图有助于理解：

![图片.png](https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/12e1812264b94d348a22124db88089a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56CC57OW5qmY5Yqg55uQ:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMzYwMjk1NTQ0MTQzMDMyIn0%3D&rk3s=f64ab15b&x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&x-orig-expires=1756126045&x-orig-sign=POktzZIhkUm7WscZmdaX8vBCzzw%3D)

## 循环语句和迭代语句

**_1. 我常常把`for、forEach、map、reduce`和`for of`混为一谈_**

**_2. 我常常把数组、类数组认为是可迭代对象_**

红宝书的 3.6 一节已经明确的说出了什么是循环语句，什么迭代语句。

## for of 是干什么用的

所有人都知道一些概念`for、forEach、map、reduce`这些是可以遍历数组的，`for of`是用于遍历迭代对象的。如下:

```js
const arr = [1, 2, 3];
arr.forEach((item, index) => {
  console.log(item); // 1, 2, 3
  console.log(index); // 0, 1, 2
});
```

而巧合的是`for of`也可以遍历数组

```js
for (let key of arr) {
  console.log(key); // 1 2 3
}
```

将 arr 改变为`const obj = { a: 1, b: 2, c: 3 }`的时候，两者都没有遍历出结果。

前者是没有反应，后者会直接报错：`TypeError: obj is not iterable`。翻译一下，类型错误:obj 不是一个可迭代对象。

那么什么是可迭代对象呢？

## 可迭代对象是什么？

我们先来看看下面这个例子：

```js
const itemLi1 = document.getElementByTagName("li");
const itemLi2 = document.querySelectorAll("li");

for (let key of itemLi1) {
  console.log(item);
}
for (let key of itemLi2) {
  console.log(item);
}
```

也就是说`HTMLCollection`和`NodeList`是可以迭代对象。其他的可迭代对象有`Array、map、set、string`等等。如果说类数组的话，是不是迭代对象呢？

```js
const arrLike = {
  0: 1,
  1: 2,
  2: 3,
  lenght: 3
}
for (let i = 0; i < arrLike.length; i++) {
    console.log(arrLike[i]) // 1, 2, 3
}
for (let of arrLike) {
    console.log(key) // uncachh TypeError: obj is not iterable
}
```

for 循环打印出了对应的结果，而 for of 报错了。类数组不是可迭代的的对象。这又是为什么呢？我们将类数组和 HTMLCollection 类型打印出来比较一下。

<img width="50%" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6008f3ccd2bb41d791c85f52d22eae3f~tplv-k3u1fbpfcp-watermark.image#?w=780&#x26;h=542&#x26;s=99067&#x26;e=png&#x26;b=212225">

而类数组如下：

<img width="50%" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acea203fc74d413eacd9d669be69119b~tplv-k3u1fbpfcp-watermark.image#?w=738&#x26;h=646&#x26;s=137327&#x26;e=png&#x26;b=202124">

它们有一个明显的不同，可迭代对象的原型链上面是包括`Symbol.iterator`的。而这个就是让数组变成可迭代的根本原因。

也就是说，当目的对象的原型链上面包括`Symbol.iterator`的时候，它才是可迭代对象。

> 对象是无序的，无序的东西自然不可以迭代

> 这里使用到了 Symbol 类型，它在 MDN 上面的解释就是用于生成全局唯一的变量。而可迭代对象就是它的使用场景。受它的启发，我们在业务当中，如果需要前端来生成一个唯一 ID 的时候，再次之前，通常都是创建一个 UUID 的函数来生成一个唯一 ID。Symbol 不用这么麻烦，直接使用就可以了。

由此可知，`Array.prototype[Symbol.iterater]`这个函数封装了一些东西，使得`for of`可以将对象的元素给打印出来。

换一句话来说，就是`Array.prototype[Symbol.iterater] = function() {}`的执行生成一个迭代器对象。

也就是说，当`Object.prototype`也有`[Symbol.iterater]`的方法的时候，`for of`也能够遍历它呢？我们来试试看吧。

```js
Object.ptotoype[Symbol.iterator] = function value() {};
```

这不就是生成器的作用么？

## 生成器和迭代器的关系。

生成器是一种特殊的函数结构，它返回的对象是一个迭代器。生成器函数本质上是 JavaScript 语法规范提供的一种**用户自定义的迭代器工厂函数**。

> 生成器（Generator）**不是基于 ES5 的语法糖**，而是 **ES6（ECMAScript 2015）引入的基础语言规范**，需要 JavaScript 引擎在底层实现支持。

表现形式如下：

```js
function* generation(iterableObject) {
  for (let i = 0; i < iterableObject; i++) {
    yield iterableObject[i];
  }
}
```

由`*`符号和`yield`关键字组成。

当`const iterator = generation([1, 2, 3])`, 其执行流程如下：

1.  iterator.next() ==> { value: 1, done: false }
2.  iterator.next() ==> { value: 2, done: false }
3.  iterator.next() ==> { value: 3, done: false }
4.  iterator.next() ==> { value: undefined, done: true }

到了第四次，value 为`undefined`的时候，done 为 true(也就是说，当 done 为 true 的时候，value 一定为 undefined)。所以说，`yield`的作用有两个：

1.  生成一个值，将该值封装成一个对象，而这个对象是`{ value: .., done: flase/true }`这样的形式。
2.  停下来

可以明显的看出来，生成器有一个作用，通过 next 这个接口，可以看到迭代的过程。

既然说生成器生成了一个迭代器，那么是不是说生成器**执行后**的结果就是一个迭代器呢？既然是迭代器，自然就可以被`for of`给遍历。

```js
for (const key of generation([1, 2, 3]) {
    console.log(key) // 1, 2, 3
}
```

果然可以。

经典面试题: 自己实现一个`next`这样的接口呢？

上面已经有了实现的思路。通过一个标识符和一个判断就能够使用 ES5 来使用，如下代码片段。

```js
function generation(iterableObj) {
  let nextIndex = 0;
  function next() {}

  return {
    next: () => {
      return nextIndex < iterableObj.length
        ? { value: iterableObj[nextIndex++], done: false }
        : { value: undefined, done: true };
    },
  };
}
```

当 nextIndex 下于数组长度的时候，没有迭代完毕。

注意：`nextIndex++`是先跑`nextIndex`，再自增。

> 何为接口，后台给你一个 url 地址，这个是网络接口。next 是设计师给你封装的一个方法，你通过这个方法来达到上吧`yield`的两个作用，所以 next()也是一个接口，前端接口。简单来说，一个封装好的方法就是一个接口。

## 让非迭代对象也可以使用 for of 进行遍历

正如第一节所说，`Symbol.iterator`的方法是迭代器的关键。那么我们也可以给`Object`挂载上该方法。既然该方法可以让对象变成迭代器，就可以直接使用上面 ES5 实现`next`方法的代码片段。

```js
const obj = {
  a: 1,
  b: 2,
  c: 3,
};
Object.prototype[Symbol.iterator] = function value() {
  const keys = Object.keys(Object(this));
  let nextIndex = 0;

  function next() {
    return nextIndex < keys.length
      ? { value: [keys[nextIndex], obj[keys[nextIndex++]]], done: false }
      : { value: undefined, done: true };
  }

  return {
    next,
  };
};
for (const [key, value] in obj) {
  console.log(key);
}
```

## for 循环和 for in 的关系

for 循环和 for in 看着很像，其实只是共用了`for`这个关键字，它们都是 JS 引擎底层实现的东西。和`forEach、map`这些是基于 for 循环的 API 不同，它们是在实现在 for 循环之上的。

## 总结

- 生成器 generator 执行的结果就是一个迭代器
- 生成器可以是也是由 ES5 实现的，不是基于底层 API
- 是否是迭代器的关键是`Symbol.iterator`方法
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[错误信息]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/错误信息</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/错误信息</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[错误信息   1. SyntaxError 语法错误(uncaught SyntaxError)  - Invalid or unexpected token - unexpected token = - Invalid or unexpected token   2. ReferenceError 引用错误  - Invalid left-hand side in assignment - ...   3. RangeError 范围错误  - Invalid array length  js var arr = [1, 2, 3]; arr.lengh...]]></description>
            <content:encoded><![CDATA[# 错误信息

## 1. SyntaxError 语法错误(uncaught SyntaxError)

- Invalid or unexpected token
- unexpected token =
- Invalid or unexpected token

## 2. ReferenceError 引用错误

- Invalid left-hand side in assignment
- ...

## 3. RangeError 范围错误

- Invalid array length

```js
var arr = [1, 2, 3];
arr.lenght = -1;
```

## 4. TypeErrro

```js
var a = {};
a.car();
```

## 5. URIError URI 错误

- [[URI]] 和 [[URL]] 的差别

```js
function test() {
  return 10;
}
```
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[隐式转化问题]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/隐式转化问题</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/隐式转化问题</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[隐式转化问题 之前写过一篇文章[[js让人诟病的这些feature]]中提出过一个疑问. 这个问题一开始我想简单了.认为只要记住一些特性就可以了.所以直接用穷举法来进行规律的总结. 但是当遇到console.log(Number([])) 的结果是 0, 而console.log(Number([1, 2])) 的结果是 NaN.都什么乱七八糟的,里面必有蹊跷.虽然能够强背背下来, 但是作为一个有追求的程序员还是要弄明白它是怎么一回事的. js console.log({} - {}); // NaN console.log([] - []); // 0 console.log([] - [1...]]></description>
            <content:encoded><![CDATA[# 隐式转化问题

之前写过一篇文章[[js让人诟病的这些feature]]中提出过一个疑问.

这个问题一开始我想简单了.认为只要记住一些特性就可以了.所以直接用穷举法来进行规律的总结.

但是当遇到`console.log(Number([]))` 的结果是 0, 而`console.log(Number([1, 2]))` 的结果是 NaN.都什么乱七八糟的,里面必有蹊跷.虽然能够强背背下来, 但是作为一个有追求的程序员还是要弄明白它是怎么一回事的.

```js
console.log({} - {}); // NaN
console.log([] - []); // 0
console.log([] - [1, 2]); // NaN
console.log([] == ![]); // true
console.log({} == {}); // false
```

要理解上面打印的结果,就是要理解`Number([])` 的值,`Number([1, 2])`的值, `Number({})`的值, 以及`Boolean([])`返回的值. 下面慢慢说道.

> Array.prototype.toString 和 Ob ject.prototype.toString 返回的结果不同

## 一、包装类

#### Boolean()

`Boolean`只有两种结果,`true`和`false`.

- `Boolean`结果为 false 的类型,我们通常称他为 `falsey`, 中文叫`虚值`. 这些值在 [[js让人诟病的这些feature]] 有所提及,即,

**0、null、undefined、false、''、NaN**

> 有些文章把-0 和+0 算成两个

上面这些都是原始值转原始值.其他的都是`true`

如果是引用值转原始值都为`true`. 还有下面这些一时间想不起来的引用类型.

```js
Boolean(/d/);
Boolean(new Error());
console.log(Boolean(Symbol()));
```

##### 扩展

还有一种容易弄混的`typeof` 返回结果, node 环境中:

```js
console.log(typeof Date());
console.log(typeof new Date());
console.log(Date()); // Thu Jan 13 202l2 22:29:36 GMT+0800 (中国标准时间)
console.log(new Date()); // 2022-01-13T14:29:36.660Z
```

#### Number()

##### 引用类型转换 Number

易错点出现在`Number()` 上面. 尤其是引用类型转化为原始类型. 了解了这个,开头的例子就能够理解了.

我们只有在知道了`Number(引用类型)`的规则才能够判断引用类型转化为原始类型的结果什么,不然是不可能判断得出的饿,靠猜走不远.

1. 我们假设有如下这么一个对象

```
const obj = {
  toString() {
    return 2
  },
  valueOf() {
    return 1
  }
}
```

2. 我们`Number()`包裹它

```js
console.log(Number(obj));
```

打印出的结果是`1`. 哦,有意思的来了,

```js
consot obj = {
  toString() {
    return 2
  },
  valueOf() {
    return {}
  }
}
console.log(Number(obj)) // 2
```

让我们让`valueOf` 返回的值是对象的时候, 打印出 2 , 反之则直接打印出 String 原始值,再转化为`number`类型.

> 一般来说`valueof` 就是代表值,没有意义,也不用处理. 值是什么就是什么,比如说[1, 2, 3].valueOf() 直接打印就是[1, 2, 3].

我们也可以通过这个方法来解决[[让 a == 1 && a == 2 && a == 3 成立]]的问题.

所以我们很容易得出这么一个规律: 当`valueOf` 返回值是引用类型的时候, 就去拿`toString` 返回的值. 展开来说就是:

1. 如果`valueOf`返回原始值,就 Number 包装之后返回
2. 如果 valueOf 返回的对象,就去`toString()`方法中找
3. 如果`toString()` 返回原始值,就 Number 包装之后返回
4. 如果`toString()`返回的是对象,且是自己重写的.那么就直接报错
5. 如果不是充血的,那么就调用 Obejct.prototye.toString 方法

这里显然还涉及到了[[原型链]]的问题,所以说其实隐式转化的问题不是想象中的那么简单的.

而我们创建的对象基本没讲过会创建这两个方法.所以它很显然就是继承至 Object 上面的方法. 也就是说,我们在研究这个问题的是,就是在研究`Object.prototype.toString.call()` 返回的值.

```js
console.log(Object.prototype.tostring.call('123'));

console.log(Object.prototype.toString.call(123));

console.log(object.prototype.tostring.call(true));

console.log(Object.prototype.tostring.call(undefined));

console.log(Object.prototype.tostring.call(null));

console.log(Object.prototype.tostring.call(function){}));

console.log(Object.prototype.toString.call([1,2,3]));

console.log(Object.prototype.tostring.call(ff));
```

打印的结果如下:

```js
[object string]
[object Number]
[object Boolean]
[object Undefined]
[object Null]
[object Functionl]
[object Arrayl]
[object objectl]
```

##### 原始类型转 Number

```js
console.log(Number(undefined)) // NaN
console.log(Number (null)) // 0
console.log(Number(true)) // 1
console.log(Number (false)) // 0
console.log(Number(NaN)) // NaN
console.1og(Number (Infinity))// Infinity
console.log(Number('') // 0
console.log(Number(' ') // 0
console.log(Number('123')) // 123
```

上面没啥好说的, 背下就行.
需要注意的是 Number 的值,除了我们平时使用的的数字意义之外,还有 NaN、Infinity.

##### 还有这些混淆点是需要注意的:

```js
console.log((123).toString()); // 123
console.log(undefined.toString()); // 报错
console.log(nul.toString()); // 报错
```

`undefined` 和 `null` 没有包装类, 本身又是`基础类型` ,自然没有其他乱码七糟的方法. 所以报错.

##### 扩展

###### Argument 和 document

```js
console.log(Object.toString.call(argument)); // [object Argument]
console.log(Object.toString.call(document)); // [object HTMLDocument]
```

`HTMLDocument`是浏览器给我们提供的对象类型.

由此也可以得知`Object.prototype.toString` 方法的运用之广, 识别类型之多, 比起`typeof` 简陋的返回值强大得多. 当然每个都有每个使用的场景就是了.

###### 手写 typeof

`typeof`是 jscore 自带,而且也不是语法糖. 我一开始看到这个面试题的时候是懵逼的. 难道要手写 typeof 的引擎代码? 解释一下从 js 第一个版本就存在的`typeof null`为`object吗?`

但是还真有公司考这个, 有点睿智,大聪明. 所以我看了看网上别人对于这的解析... 就是利用`Object.prototype.toString.call()`返回的结果,在进行字符串的切割,之后后面那个单词返回出去.

就这? 脱裤子放屁,多此一举.

###### Number 转化非二进制

```js
Number(0xfff); // 4095
Number(070); // 56
```

Number 可以直接识别不同位数转化成十进制.

###### parseInt 和 Number 关系

```js
Number("123abc"); // NaN
Number("ad123"); // NaN
Number("  123"); // 123
```

而[[parseInt 1]]就很好的解决了这个问题,它可以说是对于`Number()`很好的一个补充

```js
parseInt("123abc"); // 123
parseInt("123asd1"); // 123
parseInt("ad123"); // NaN
parseInt("  123"); // 123
```

### String()

## 二、隐式转化触发规则

前面说了显示转化的规律. 下面是能够触发隐式转化的规则.

和运算符规则是和[[运算符的优先级]],在这里不提,可自行查阅.

### 布尔的隐式转化

当出现判断的时候,会出现隐式转化.

```js
if,
switch,
while,
for(; ;),
&&,
||,
!,
!!,
? : 三元
```

### number 的隐式转化

只要有小学的知识都知道运算符,它是用于数字之间的计算的.在 JavaScript 中也是基本是一样的.

`+ - * % == ~~ & | ~ ^ << <<<` 等, 位运算符 、算术运算符

### 隐式转化最难的情况

> == !== >= <= < >

如下例子, 也是面试的高频题目,背下来之余,还是要知道得到这样结果的过程.

```js
console.log([] == ![]); // true
```

个人觉得隐式转化最复杂的就是这个例子了.再复杂大不了加上优先级.
回到这个例子中, 看似比较的是两个数组,或者说两个特殊对象.其实不全是.来解析这个例子:

1. 看到 等号 这个比较运算法就应该明白 等号 两边都要转化成 Number 类型
2. 从左到右的话,`Number([])`, `[]` 是引用类型,无法直接拿到原始值
3. `valueOf`拿不到值,就走`Array.prototype.toString.call([])`.从上面可以知道, 它返回的是去掉[],即字符串`''`.
4. 此时左边为`Number('')`. 所以左边返回的自然是`0`.

此时这个题目为`0 == ![]`. 接下来右边的转化,这就简单了.

1.  在`Boolean()`一节当中,就可以知道,除了`falsey`之外,其他都是 ture.而此时在!的加持下,`[]`会进行`Boolean()`
2.  此时右边为`true`. `!true`就为 false
3.  `Number(false)`的结果为 0

由上而得出 `0 == 0` 的结果为`true`.运用上面的知识点可以很好的解析问题,下面的这个例子就更加简单了.

```js
console.log({} == {}); // false
console.log({} != {});
```

如果按照一样的分析方式来解释的话:

1. 两边都`Number()`包裹住.
2. `toString()`之后都是`[obejct Object]`
3. `Number('[obejct Object]')` 为`NaN`
4. 所以最后转化为`console.log(NaN == NaN)`的比较

> NaN 和任何一个值比较都不想等

题目不难,但是综合的东西还是有一点的. 这两题解决了,隐式转化的问题也就到头了

## 三、特殊情况

最容易记住的就是`字符串运算符`.

```js
console.log(1 + "2" + "2"); // '122'
console.log(1 + +"2" + "2"); // '32'
console.log("A" - "B" + "2"); // 'NaN2'
console.log("A" - "B" + 2); // NaN
```

> js 字符串和任何数据类型想加都转化为字符串么?可以这么说,处理`symbol`类型直接报错之外.

```js
console.log(typeof +"2"); // number
```

还有下面`undfined`和`null`的特殊情况

```js
console.log(undefined == null); // true
console.log(NaN == NaN); // fasle
```

- `NaN`的语意是`not a number`,很明显了,指的就不是一个数字
- `NaN`在`typeof`中是`number`类型,但是它和任何数都不想.

## 四、工作不要使用

之前写过一篇文章[[js让人诟病的这些feature]]中提出过一个疑问.

这个问题一开始我想简单了.认为只要记住一些特性就可以了.所以直接用穷举法来进行规律的总结.

但是当遇到`console.log(Number([]))` 的结果是 0, 而`console.log(Number([1, 2]))` 的结果是 NaN.都什么乱七八糟的,里面必有蹊跷.虽然能够强背背下来, 但是作为一个有追求的程序员还是要弄明白它是怎么一回事的.

```js
console.log({} - {}); // NaN
console.log([] - []); // 0
console.log([] - [1, 2]); // NaN
console.log([] == ![]); // true
console.log({} == {}); // false
```

要理解上面打印的结果,就是要理解`Number([])` 的值,`Number([1, 2])`的值, `Number({})`的值, 以及`Boolean([])`返回的值. 下面慢慢说道.

## 一、包装类

#### Boolean()

`Boolean`只有两种结果,`true`和`false`.

- `Boolean`结果为 false 的类型,我们通常称他为 `falsey`, 中文叫`虚值`. 这些值在 [[js让人诟病的这些feature]] 有所提及,即,

**0、null、undefined、false、''、NaN**

> 有些文章把-0 和+0 算成两个

上面这些都是原始值转原始值.其他的都是`true`

如果是引用值转原始值都为`true`. 还有下面这些一时间想不起来的引用类型.

```js
Boolean(/d/);
Boolean(new Error());
console.log(Boolean(Symbol()));
```

##### 扩展

还有一种容易弄混的`typeof` 返回结果, node 环境中:

```js
console.log(typeof Date());
console.log(typeof new Date());
console.log(Date()); // Thu Jan 13 202l2 22:29:36 GMT+0800 (中国标准时间)
console.log(new Date()); // 2022-01-13T14:29:36.660Z
```

#### Number()

##### 引用类型转换 Number

易错点出现在`Number()` 上面. 尤其是引用类型转化为原始类型. 了解了这个,开头的例子就能够理解了.

我们只有在知道了`Number(引用类型)`的规则才能够判断引用类型转化为原始类型的结果什么,不然是不可能判断得出的饿,靠猜走不远.

1. 我们假设有如下这么一个对象

```
const obj = {
  toString() {
    return 2
  },
  valueOf() {
    return 1
  }
}
```

2. 我们`Number()`包裹它

```js
console.log(Number(obj));
```

打印出的结果是`1`. 哦,有意思的来了,

```js
consot obj = {
  toString() {
    return 2
  },
  valueOf() {
    return {}
  }
}
console.log(Number(obj)) // 2
```

让我们让`valueOf` 返回的值是对象的时候, 打印出 2 , 反之则直接打印出 String 原始值,再转化为`number`类型.

> 一般来说`valueof` 就是代表值,没有意义,也不用处理. 值是什么就是什么,比如说[1, 2, 3].valueOf() 直接打印就是[1, 2, 3].

我们也可以通过这个方法来解决[[让 a == 1 && a == 2 && a == 3 成立]]的问题.

所以我们很容易得出这么一个规律: 当`valueOf` 返回值是引用类型的时候, 就去拿`toString` 返回的值. 展开来说就是:

1. 如果`valueOf`返回原始值,就 Number 包装之后返回
2. 如果 valueOf 返回的对象,就去`toString()`方法中找
3. 如果`toString()` 返回原始值,就 Number 包装之后返回
4. 如果`toString()`返回的是对象,且是自己重写的.那么就直接报错
5. 如果不是充血的,那么就调用 Obejct.prototye.toString 方法

这里显然还涉及到了[[原型链]]的问题,所以说其实隐式转化的问题不是想象中的那么简单的.

而我们创建的对象基本没讲过会创建这两个方法.所以它很显然就是继承至 Object 上面的方法. 也就是说,我们在研究这个问题的是,就是在研究`Object.prototype.toString.call()` 返回的值.

```js
console.log(Object.prototype.tostring.call('123'));

console.log(Object.prototype.toString.call(123));

console.log(object.prototype.tostring.call(true));

console.log(Object.prototype.tostring.call(undefined));

console.log(Object.prototype.tostring.call(null));

console.log(Object.prototype.tostring.call(function){}));

console.log(Object.prototype.toString.call([1,2,3]));

console.log(Object.prototype.tostring.call(ff));
```

打印的结果如下:

```js
[object string]
[object Number]
[object Boolean]
[object Undefined]
[object Null]
[object Functionl]
[object Arrayl]
[object objectl]
```

##### 原始类型转 Number

```js
console.log(Number(undefined)) // NaN
console.log(Number (null)) // 0
console.log(Number(true)) // 1
console.log(Number (false)) // 0
console.log(Number(NaN)) // NaN
console.1og(Number (Infinity))// Infinity
console.log(Number('') // 0
console.log(Number(' ') // 0
console.log(Number('123')) // 123
```

上面没啥好说的, 背下就行.
需要注意的是 Number 的值,除了我们平时使用的的数字意义之外,还有 NaN、Infinity.

##### 还有这些混淆点是需要注意的:

```js
console.log((123).toString()); // 123
console.log(undefined.toString()); // 报错
console.log(nul.toString()); // 报错
```

`undefined` 和 `null` 没有包装类, 本身又是`基础类型` ,自然没有其他乱码七糟的方法. 所以报错.

##### 扩展

###### Argument 和 document

```js
console.log(Object.toString.call(argument)); // [object Argument]
console.log(Object.toString.call(document)); // [object HTMLDocument]
```

`HTMLDocument`是浏览器给我们提供的对象类型.

由此也可以得知`Object.prototype.toString` 方法的运用之广, 识别类型之多, 比起`typeof` 简陋的返回值强大得多. 当然每个都有每个使用的场景就是了.

###### 手写 typeof

`typeof`是 jscore 自带,而且也不是语法糖. 我一开始看到这个面试题的时候是懵逼的. 难道要手写 typeof 的引擎代码? 解释一下从 js 第一个版本就存在的`typeof null`为`object吗?`

但是还真有公司考这个, 有点睿智,大聪明. 所以我看了看网上别人对于这的解析... 就是利用`Object.prototype.toString.call()`返回的结果,在进行字符串的切割,之后后面那个单词返回出去.

就这? 脱裤子放屁,多此一举.

###### Number 转化非二进制

```js
Number(0xfff); // 4095
Number(070); // 56
```

Number 可以直接识别不同位数转化成十进制.

###### parseInt 和 Number 关系

```js
Number("123abc"); // NaN
Number("ad123"); // NaN
Number("  123"); // 123
```

而[[parseInt 1]]就很好的解决了这个问题,它可以说是对于`Number()`很好的一个补充

```js
parseInt("123abc"); // 123
parseInt("123asd1"); // 123
parseInt("ad123"); // NaN
parseInt("  123"); // 123
```

### String()

#### Object.prototype.toString

对于`String()`的使用依旧使用`Number()`使用的例子

```js
const obj = {
  toString() {
    return 2;
  },
  valueOf() {
    return 1;
  },
};
```

当我触发`String(obj)`的时候,就和`Number()`完全相反.

```js
console.log(String(obj)); // 2
```

直接访问的是`toString()`方法.

```js
const obj = {
  toString() {
    return {};
  },
  valueOf() {
    return 1;
  },
};

console.log(String(obj)); // 1
```

但是如果`toString()` 返回的是引用类型的话, 就往`valueOf()`方法上面找.
可以说和`Number()`的完全相反,但是也符合情理 .

通过重写`toString()`和`valueOf()`的方法来了解内部的运行规则是一种很好的方式.

如果不重写的话,`Object.prototype.toString.call(对象)`, 返回值参看`Number()`部分的内容.

```js
console.log(String({})); // [object Object]
```

#### Array.prototype.toString

这个记忆上没啥好说的, 直接把外面的[]给拆了就行.

```js
console.log(String([1])); // '1'
console.log(String([1, 2])); // '1, 2'
console.log(Array.prototype.toString.call([1])); // '1'
console.log(Array.prototype.toString.call([1, 2])); // '1, 2'
```

## 二、隐式转化触发规则

前面说了显示转化的规律. 下面是能够触发隐式转化的规则.

和运算符规则是和[[运算符的优先级]],在这里不提,可自行查阅.

### 布尔的隐式转化

当出现判断的时候,会出现隐式转化.

```js
if,
switch,
while,
for(; ;),
&&,
||,
!,
!!,
? : 三元
```

### number 的隐式转化

只要有小学的知识都知道运算符,它是用于数字之间的计算的.在 JavaScript 中也是基本是一样的.

`+ - * % == ~~ & | ~ ^ << <<<` 等, 位运算符 、算术运算符

### 隐式转化最难的情况

> == !== >= <= < >

如下例子, 也是面试的高频题目,背下来之余,还是要知道得到这样结果的过程.

```js
console.log([] == ![]); // true
```

个人觉得隐式转化最复杂的就是这个例子了.再复杂大不了加上优先级.
回到这个例子中, 看似比较的是两个数组,或者说两个特殊对象.其实不全是.来解析这个例子:

1. 看到 等号 这个比较运算法就应该明白 等号 两边都要转化成 Number 类型
2. 从左到右的话,`Number([])`, `[]` 是引用类型,无法直接拿到原始值
3. `valueOf`拿不到值,就走`Array.prototype.toString.call([])`.从上面可以知道, 它返回的是去掉[],即字符串`''`.
4. 此时左边为`Number('')`. 所以左边返回的自然是`0`.

此时这个题目为`0 == ![]`. 接下来右边的转化,这就简单了.

1.  在`Boolean()`一节当中,就可以知道,除了`falsey`之外,其他都是 ture.而此时在!的加持下,`[]`会进行`Boolean()`
2.  此时右边为`true`. `!true`就为 false
3.  `Number(false)`的结果为 0

由上而得出 `0 == 0` 的结果为`true`.运用上面的知识点可以很好的解析问题,下面的这个例子就更加简单了.

```js
console.log({} == {}); // false
console.log({} != {});
```

如果按照一样的分析方式来解释的话:

1. 两边都`Number()`包裹住.
2. `toString()`之后都是`[obejct Object]`
3. `Number('[obejct Object]')` 为`NaN`
4. 所以最后转化为`console.log(NaN == NaN)`的比较

> NaN 和任何一个值比较都不想等

题目不难,但是综合的东西还是有一点的. 这两题解决了,隐式转化的问题也就到头了

## 三、特殊情况

最容易记住的就是`字符串运算符`.

```js
console.log(1 + "2" + "2"); // '122'
console.log(1 + +"2" + "2"); // '32'
console.log("A" - "B" + "2"); // 'NaN2'
console.log("A" - "B" + 2); // NaN
```

> js 字符串和任何数据类型想加都转化为字符串么?可以这么说,处理`symbol`类型直接报错之外.

```js
console.log(typeof +"2"); // number
```

还有下面`undfined`和`null`的特殊情况

```js
console.log(undefined == null); // true
console.log(NaN == NaN); // fasle
```

- `NaN`的语意是`not a number`,很明显了,指的就不是一个数字
- `NaN`在`typeof`中是`number`类型,但是它和任何数都不想.
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[数组API]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/数组API</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/数组API</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[数组 API  1. Array.prototype.copyWithin  1.1 基本形式 Arrauy.prototype.copyWithin(target, (start, end]) > target 是指从什么位置开始 js const arr = [1, 2, 3, 4, 5]; const newArr = arr.copyWithin(1, 0, 3); console.log(newArr); // 1, 1, 2, 3, 5 > start 旁边的(符号代表闭区间,end 旁边的]开区间 从上面的例子可以直接知道.target 代表从数组的第几位开始覆盖. start ...]]></description>
            <content:encoded><![CDATA[# 数组 API

## 1. Array.prototype.copyWithin

### 1.1 基本形式 Arrauy.prototype.copyWithin(target, (start, end])

> target 是指从什么位置开始

```js
const arr = [1, 2, 3, 4, 5];
const newArr = arr.copyWithin(1, 0, 3);
console.log(newArr); // 1, 1, 2, 3, 5
```

> start 旁边的(符号代表闭区间,end 旁边的]开区间

从上面的例子可以直接知道.target 代表从数组的第几位开始覆盖. start 和 end 代表将另外一段替换上 arr 上面.

### 1.2 end 超过原数组最长长度的时候

```js
const newArr = arr.copyWithin(1, 0, 13);
console.log(newArr); // 1, 1, 2, 3, 5
```

end 超出数组最大长度的时候,就默认到头. 在这个数组中为 4.

### 1.3 end 大于 start 的时候

```js
const newArr = arr.copyWithin(1, 3, 1);
console.log(newArr); // 1, 2, 3, 4, 5
```

如果 start 大与 end 的话, 出来的结果没有变化.

### 1.4 end 不存在的时候

```js
const newArr = arr.copyWithin(1, 3);
console.log(newArr); // 1, 4, 3, 4, 5
```

当没有第三个数字的时候, 会默认和第二个数字一致. `arr.copyWithin(1, 3, 3)`

### 1.5 start 和 end 都不存在的时候

```js
const newArr = arr.copyWithin(3);
console.log(newArr); // 1, 2, 3, 1, 5
```

如果 start 和 end 都没有的话. 就默认是 0, 0

### 1.6 start 和 end 为负数, start > end

```js
const newArr = arr.copyWithin(3, -1, -3);
console.log(newArr); // 1, 2, 3, 4, 5
```

没有效果.

### 1.7 start 和 end 为负数, start < end

```js
const newArr = arr.copyWithin(3, -3, -1);
console.log(newArr); // [ 1, 2, 3, 3, 4 ]
```

-1 是最后一个数组, 倒数第二对应的是-2. 如果超过数组长度,默认为第一个,及 0.

### 1.8 start 和 end 为负数, start < end, start < arr.length - 1

```js
const newArr = arr.copyWithin(3, -13, -1);
console.log(newArr); // [ 1, 2, 3, 1, 2 ]
```

如上所说. start 的绝对值大于数组最长长度的时候,默认为 0

### 1.9 start 和 end 为负数, end = null

```js
const newArr = arr.copyWithin(3, -1);
console.log(newArra); // 1, 2, 3, 5, 5
```

同正数的一样.

### 1.10 start 和 end, start < 0, end > 0

```js
const newArr = arr.copyWithin(3, -1, 0);
console.log(newArra); // 1, 2, 3, 4, 5
```

无效

## 2. Array.prototype.entries

使用这个的前置知识[[generator和iterator]]

## 3. Array.prototype.fill

使用方法和`copyWithin`类似.
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[正则基础]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/正则基础</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/正则基础</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[正则基础 要学习正则内置对象的话,需要了解一下 js 中[[转义符]]的概念.它是学习正则表达式的前置知识。  一、转义符 使用转义符的场景如下如下： js const a = '我就蹭蹭，绝不'进去'哦' console.log(a) 我们的目的是要打印我就蹭蹭，绝不'进去'. 但是事与愿违，这样写会直接报错。 Uncaught SyntaxError: Unexpected identifier. 这是因为 JS 引擎把这串代码分成 了前后两部，进去被识别成了变量，这个时候报错说的是你应该要在进入的两边加上+号。 如果加上了加号的话，const a = '我就蹭蹭，绝不'+ 进去 + '哦...]]></description>
            <content:encoded><![CDATA[# 正则基础

要学习正则内置对象的话,需要了解一下 js 中[[转义符]]的概念.它是学习正则表达式的前置知识。

## 一、转义符

使用转义符的场景如下如下：

```js
const a = '我就蹭蹭，绝不'进去'哦'
console.log(a)
```

我们的目的是要打印`我就蹭蹭，绝不'进去'`. 但是事与愿违，这样写会直接报错。
`Uncaught SyntaxError: Unexpected identifier`. 这是因为 JS 引擎把这串代码分成 了前后两部，`进去`被识别成了变量，这个时候报错说的是你应该要在`进入`的两边加上`+`号。

如果加上了加号的话，`const a = '我就蹭蹭，绝不'+ 进去 + '哦'`. 会接着报错：

```js
Uncaught ReferenceError: 进去 is not defined
```

面对这样的情况，我们可以让里面的单引号变成双引号，这是一种解决的办法。除此之外，我们还可以借助转义符来解决。

```js
const a = "我就蹭蹭，绝不'进去'哦";
```

转义符 = 改变这个符号本来的意义。

转义符`\`的意义也可以被自己给转移

```js
const a = "我是好人\\真的\\啊";
console.log(a); // '我是好人\真的\啊'
```

> 转义符转义自己，让 console.log 成功打印出自己

### 转义字符

也叫转义符的特殊功能

`\n`: 换行
`\r` : 回车
`\t`: 制表符，也就是键盘上的`tab`按键

这些转义字符存在我么的每一个编辑器当中，但凡是有换行功能的， 制表符的，都在每一个编辑器当中，只不过一般来说是隐藏的罢了。

所以想要 console.log()的内容也出现换行的话，就需要手动的添加这些转义字符。

## 二、创建正则表达式

**RegExp = regular expression**

和对象、数组、字符串这些一样。正则表达式也是有两种创建的方式。

```js
// 构造函数法
const reg = new RegExp("test");

// 直接声明对象，对象字面量, 对象直接量
const reg = /test/;
```

两种创建方法基本是一样的，第二种比第一种简洁一些。但是第一种可以放变量为主体；

```js
const testData = "test";
const reg = new RegExp(testData);
const reg = /testData/; // 报错
```

对象直面量直接的报错了。

### 2.1 正则变量比较的过程

类似于冒泡的过程，一旦匹配之后，就不会再拿该字符来进行下一轮的匹配了。

```js
const str = "abcde";
const reg = /[abc][cde]/gi;

console.log(str.match(reg));
```

匹配的过程如下图所示：

![[Pasted image 20220118184635.png|300]]

图上面只有一个交叉点，即 b.这是因为正则的匹配模式就是根据你的主体内容返回的数字来一格格右移的。一旦匹配成功，就把前面比较过的抛出去，从用全新的字符串来作为 start

### 2.2 正则表达式的参数

```js
// 构造方法
const reg = new RegExp('test', gim)

// 字面对象
cosnt reg = /test/gim
```

> 之后都使用字面量表达式来代替构造方法

第一个参数就是我们正则的主体判断了，第二参数可以称呼之**装饰符**, 或者叫正则属性。如图所示的三个字母，每一个字母都代表一个含义。

- i: 忽略大小写,不写的话，默认是 I，即区分大小写。
- g: 全局匹配
- m multi-line 多行匹配

### 2.3 表达式

```js
const str = "12345";
const reg = /[123][321]/;
```

[]代表在匹配 123 中的一个，上面是要匹配两个字符。连续的两个。

如果想要写区间的话，

```JS
const reg = /[0-9][a-zA-Z]/
```

0 到 9 的整 k 数

a 到 z, 大写 A 到大写 Z

- ^ 非得意思: 一定要在[]表达式中，如果是在外面的话，表示的是是否以 0 开头

  ```js
  const reg = /[^0]/;
  ```

  不是零任何字符串

- | 或

### 2.4 元字符

可以看做内置的常用变量

1.  \w: 0-9A-z\_ 和 **\W**: [^\w]

```js
const reg1 = /[0-9A-z_][1]/;
const reg2 = /\w/;
```

上面两者相等。

2. **\d**: [0-9] && **\D**: [^\d]

3. - \s: [/r/n/t/v/f]

     \v: 垂直换行符;
     \f: 换页符

   - \S: [^\s]

4. \b 单词边界 && \B: 非单词边界

#### 元字符下的全匹配

```js
const reg = /[\w|\W]/;
```

### 2.4 量表达式

量，量词。

- n+ => {1, 正无穷}
- n\* => {0, 正无穷}
  - 贪婪模式
-

## 三、对于两种创建正则方法的讨论

```js
const reg1 = /test/;
const newReg = RegExp(reg1);
const newReg1 = new RegExp(reg1);

reg1.a = 10;
console.log(newReg.a); // 10
console.log(newReg1.a); // undefinedzz
```

```js
// 贪婪模式：先多后面少
// n+ => {1,正无穷}. 就是说至少存在一个符合n的字符串就算，
// n* => {0,正无穷}. 就算是零也会挨卵
// n? => {0,1}. 就是存在和不存在的问题了
// n{x,y} => {1,正无穷} - n+ 、 {0,正无穷} - n*、{0,1} -n?
// const reg = /1[1345789][\d]{9}$/g
// (?=n). 匹配任何其后紧接着制定字符串N的字符串
// \1\1\2. 匹配叠字字符串
// const reg = /(\w)\1(\w)\1/g
```

## 四、正向预查

这个是一种查询方式的总结。

```JS
const str = '1sff1234',
	  reg = /1(?=s)/g
```

我们要匹配的是有条件的 1, 后面必须要跟着 s,不然就不算匹配成功.这种方法就叫做`正向预查`

## 五、贪婪模式和非贪婪模式

> . 这个点,是除了换行符和结束符,其他都匹配.

*贪婪模式*是正则默认的模式,但凡能够匹配多也不会匹配少.和它对应的自然就是*非贪婪模式*.

```js
const str = "safs{{name}} 史蒂夫123{{age}}123",
  reg = /{{.*}}/g;
console.log(str.match(reg)); // {{name}} 史蒂夫123{{age}}
```

正应了那句话,正则表达式的默认形式就是贪婪模式.在 name 后面就有了一个}},但是它并不满足,它会遍历到最后, 发现 age}}这里的也匹配规则,虽然结果就是取这么长一块.

如果这时候我们需要的是只要出现在这样的就抛出呢?那么我们就不需要贪婪模式了,需要使用非贪婪模式.

```js
const reg = /{{.*?}}/g;
```

只要在后面加上`?`号,JS 引擎就可以识别该正则表达式是非贪婪模式了.

打印的结果就是:

```js
console.log(str.match(reg)); // ['{{name}}', '{{age}}']
```

而非贪婪模式就是我们字符串模版匹配的基础.

## 六、replace

这个字符串方法有两点值得注意的:

1.  如果不使用正则的话,只能匹配一次就返回

    ```js
    const str = "123bs123";
    const reg = /123/g;
    console.log(str.replace("123", "替换")); // '替换bs123'
    console.log(str.replace(reg, "替换")); // '替换bs替换'
    ```

2.  replace 的第二个参数可以是一个回调函数

    ```js
    const str = "我叫{{name}}, 今年{{age}}岁";
    const Vue = function (params) {
      this.str = params.str;
      this.targetStr = null;
      this.name = params.name;
      this.age = params.age;
    };
    Vue.prototype = {
      reg() {
        return /{{(.*?)}}/g;
      },

      build() {
        const that = this;
        this.targetStr = this.str.replace(this.reg(), function (node, key) {
          return that[key];
        });
      },

      getStr() {
        this.build();
        return this.targetStr;
      },
    };

    const a = new Vue({
      str,
      name: "吴雨村",
      age: "18",
    });

    console.log(a.getStr());
    ```

## 七、子表达式的运用

```JS
// xxyycc => XxYyCc
const str = 'xxyycc'
	  reg = /(\w)\1(\w)\2(\w)\3/g
```

### {{}}的的变量替换实例

就是模板替换的具体实现

和上面的`replace`的例子一致

## 八、捕获分组和不捕获分组

不捕获分组:

```js
const str = "abcabc1",
  reg = /(ab)(?:c)/g;
console.log(str.repalce(reg, "$1$2")); // ab$2ab$21
```

捕获分组:

```js
const str = "abcabc1",
  reg = /(ab)(c)/g;
console.log(str.repalce(reg, "$1$2")); // abcabc1
```

捕获不捕获是相对于 replace 这个返回的回调函数而言的. 如果在()中前面加上`?:`的话,就代表在回调函数上面没有这个对应的形参.

## 九、exec 方法

手操式 g.

```js
const str = "123123aaaabbaabsdfasdf123ac";
const reg = /\d/g;

// console.log(str.match(reg))
console.log(reg.exec(str));
console.log(reg.exec(str));
console.log(reg.exec(str));
console.log(reg.exec(str));
console.log(reg.exec(str));
console.log(reg.exec(str));
```

有点像迭代器的操作
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[用函数调用的方式来分析this]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/用函数调用的方式来分析this</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/用函数调用的方式来分析this</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[用函数调用的方式来分析 this > 每个函数都有一个隐式的 this 形参。将函数作为方法调用时，这个参数会被设置为用于访问该方法的对象。这和大多数面向对象语言中的 this（或 self）含义相同。但是 JavaScript 在「关联到对象的方法」与「独立函数」这两者之间，使用了单一的定义形式。这使 \\this\\ 导致了许多程序员的困惑和 bug。 ——————Brendan Eich(JS 之父) this 指向到问题是公认的！创造 JS 的人都这么说它。所谓的灵活指向不过是缝合怪。 所以说，对于 this 的强限制是非常有必要的，比如 ES6 的发布。 现在面试还在考查 this ...]]></description>
            <content:encoded><![CDATA[# 用函数调用的方式来分析 this

> 每个函数都有一个隐式的 `this` 形参。将函数作为方法调用时，这个参数会被设置为用于访问该方法的对象。这和大多数[面向对象语言](https://www.zhihu.com/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%221539325572%22%7D)中的 `this`（或 `self`）含义相同。但是 JavaScript 在「关联到对象的方法」与「独立函数」这两者之间，使用了单一的定义形式。**这使 \*\***`this`\***\* 导致了许多程序员的困惑和 bug。 ——————Brendan Eich(JS 之父)**

this 指向到问题是公认的！创造 JS 的人都这么说它。所谓的灵活指向不过是缝合怪。

所以说，对于 `this` 的强限制是非常有必要的，比如 ES6 的发布。

现在面试还在考查 `this` 的使用作为主要晒人的手段是不理智不合理的，**希望各位面试官能提升自己的修养！**

当然，现在依旧有大量的老项目充斥着各种 `this` 。面对这样的项目，我建议面试者另选公司，建议面试官早日理智。

> 如果在现在的市场有其他更好的选择的话

## 它所谓的灵活是什么？

new 关键字让我在批量创造对象的时候省却了 4 个步骤；函数不用显性的写上 return,它自己会添加，并且 return undeinfed。在调用函数的时候，自然也会有有类似的操作。

我们想来看调用函数的四种方式：

- `fn(a, b)`
- `obj.fn(a,b)`
- `fn.call(Object, a, b)`
- `fn.apply(Object, [a, b])`

其中`apply`和`call` 的差别只是参数的类型不一样。它们的第一个参数`Object` 大多数的是直接传 this 进去。和`fn(a, b)` 和`obj.fn(a,b )` 有`this` 和`arguments` 两个隐式的参数不同，它们是显式的！

那是不是可以说 `fn(a, b)` 和`obj.fn(a, b)` 以及`fn.apply(Object, [a. b])` 都是 `fn.call(Object, a, b)` 的语法糖！！！

- **fn(a, b) ⇒ fn.call(undefine, a, b)**
- **obj.fn(a, b) ⇒ fn.call(obj, a, b)**
- **fn.apply(Object, [a, b]) ⇒ fn.call(Object, a, b)**

也就是说，其实我们调用函数的时候，只有一种方式，就是`fn.call(Object, a, b)` ！

在这个前提之下， 我们来看看下面的这个经典面试题：

```
const obj = {
  foo: function() {
    console.log(this)
  }
}

const myObj = obj.foo
myObj() // window
obj.foo() // function foo() {}
```

```
myObj(undefined)
obj.foo(obj)
```

我们用上面的来定义一下：

`myObj()` ⇒ `myObj.call(undefined)`

`obj.foo()` ⇒ `obj.foo.call(obj)`

所以说，obj.foo()答应出来的就是 _function foo() {_ }。由于在浏览器当中，当传入的 Object 是`undefined` 或者 `null` 的时候，它默认指向`windows` 。

基于这样的现象，我们可以引用《你不知道的 JavaScript》中对于 `this` 的概括：

1.  上下文是在函数被调用的时候创建的
1.  上下文中包括了 `this`

换一句话说就是： **`this`\*\*** 的行为是在运行时决定的！\*\*

造成它们的打印的结果的不同，就是函数的运行的时候创建的上下文不同，在这里，我们完全可以把上下文这个概念等同于 `this`。

myObj 运行的时候，foo 函数已经挂载到了上下文全局中，所以它的 `this` 打印的结果是 window。而 obj.foo 运行时，foo 函数挂载在对象内部，所以 this 打印是函数自己。

> 上面例子说明的 Object 就是上下文，一般写作 context。

## 它带来了什么灾难

当它和事件循环机制在一起的时候，如下题：

```
const object = {
  message: 'Hello, World!',

  logMessage() {
    console.log(this.message); // => ?
  }
};

setTimeout(object.logMessage, 1000);
```

按照说明的分析，既然是方法的调用，那么这里打印的是不是 object 的属性呢 ？

结果很遗憾， 是 window。setTimeout 属于宏任务，它会等待微任务在执行栈中执行完毕再将`object.logMessage` 放入执行栈当中。可是此时它已经变成了函数的调用,因为 object 对象已经被销毁，所以是`object.logMessage.call(undefined)` 。

所以我们在 ES6 中迎来了箭头函数！

它没有`this` 这个隐式的参数。也就意味着，如果它会延着作用域链一直忘找 `this` 这个参数的存在。纯粹得太多了。善莫大焉！

## 总结

- 只有一种调用函数的方式，`fn.call(Object, a, b)`
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[立即执行函数]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/立即执行函数</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/立即执行函数</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[立即执行函数  一、是什么 立即执行函数又名[[IIFE]]，具体对于它的介绍可以看我之前的文章。 和它相对应的是[[具名函数表达式]]，是相对的。先来看看具名函数表达式： js function foo() {   console.log("橘子哥"); } 而 IIFE 的典型例子如下： js (function () {   console.log("橘子哥"); })(); 有三个不同： 1. [[IIFE]]没有函数名，具名函数有，可以通过 console.log(foo.name)打印出来 2. [[IIFE]]直接调用，这就是它立即的由来，而具名需要添加foo()才能够运行 3....]]></description>
            <content:encoded><![CDATA[# 立即执行函数

## 一、是什么

立即执行函数又名[[IIFE]]，具体对于它的介绍可以看我之前的文章。

和它相对应的是[[具名函数表达式]]，是相对的。先来看看具名函数表达式：

```js
function foo() {
  console.log("橘子哥");
}
```

而 IIFE 的典型例子如下：

```js
(function () {
  console.log("橘子哥");
})();
```

有三个不同：

1. [[IIFE]]没有函数名，具名函数有，可以通过 console.log(`foo.name`)打印出来
2. [[IIFE]]直接调用，这就是它立即的由来，而具名需要添加`foo()`才能够运行
3. [[IIFE]]第一个字符是`;`

## 二、IIFE 给出我们带来了什么

1. 戳破了形成[[闭包]]需要函数嵌套的谣言

创建一个独立的作用域，让我知道函数嵌套函数的目的是什么，详见上一篇文章

2. 解决了循环打印的问题

经典面试题：

```js
for (var i = 0; i < 5; i++) {
  setTimout(function () {
    console.log(i); // 为啥打印出来额都是5呀，而不是0 ,1 ,2 ,3, 4
  });
}
```

或者

```js
var lis = ul.querySelector("li");
for (var i = 0; i < 6; i++) {
  lis[i].onclick = function () {
    console.log(i); // 为啥打印出来额都是5呀，而不是0 ,1 ,2 ,3, 4
  };
}
```

两个例子都是一个问题。i 相对于函数是全局变量，所以不管循环多少个函数，里面的`i`指向的都是同一个内存，而这个内存中放的值只有一个。所以它们打印出来的值自然都是一样的。

要解决这个问题，自然就是让这些函数能够执行不同的`i`。所以函数作用域就能够办到这件事情。

```js
for (var i = 0; i < 5; i++) {
  !(function foo(j) {
    setTimout(function () {
      console.log(j); // 为啥打印出来额都是5呀，而不是0 ,1 ,2 ,3, 4
    });
  })(j);
}
var lis = ul.querySelector("li");
for (var i = 0; i < 6; i++) {
  !(function foo(j) {
    lis[j].onclick = function () {
      console.log(j); // 为啥打印出来额都是5呀，而不是0 ,1 ,2 ,3, 4
    };
  })(j);
}
```

> ES6 之前 JS 原生又不提供块级作用域，所以只能用[[函数作用域]]模拟了。现在处理这样的问题，[[let]]显然是更加方便的。

总结一下：

1. 改变变量的作用域（创建一个独立的作用域)

2. 封装临时变量。

## 三、一些少为人知的技巧

**写上函数名**, 两个作用：

第一个，辅助定位 BUG。有小面这串代码：

```js
!(function () {
  a;
  console.log(11);
})();
```

明显看出其中 a 没有定义，会在控制台把如下错误。

![[截屏2023-02-07 23.54.31.png]]

如果我们给它添加上函数名，会有什么不一样的么？

```js
!(function foo() {
  a;
  console.log(11);
})();
```

报错信息就会出现`foo`函数名。这就是为啥说它可以辅助定位 BUG。

![[截屏2023-02-07 23.58.41.png]]

第二个，老一代框架写法, 比如说 JQ：

```js
(function JQ(g) {
  g(window);
})(function g(window) {
  // code
});
```

了解一下即可。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[让 a == 1 && a == 2 && a == 3 成立]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/让 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 成立</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/让 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 成立</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[让 a == 1 && a == 2 && a == 3 成立 JavaScript if (a == 1 && a == 2 && a == 3) {   console.log('Win') } 如何打印除Win 看到题目的第一眼,我是蒙蔽的.怎么可能会有如此矛盾的情况发生呢?就相当于一个人怎么可能即是小孩,又是成年人,还是老年人呢? 冷静下来,发现一些端倪.它并不是让 a 同时等于 1 2 3, 而且 js 是单线程运行的. 及时它们写在了一行,那也是从左到右执行的. 所以它们可以不是同一时期的东西.既然不是同一时期的东西,那么一个人当然可以是过小孩子,是过成年人,是过老年人了. 回到题...]]></description>
            <content:encoded><![CDATA[# 让 a == 1 && a == 2 && a == 3 成立

```JavaScript
if (a == 1 && a == 2 && a == 3) {
  console.log('Win')
}
```

如何打印除`Win`

看到题目的第一眼,我是蒙蔽的.怎么可能会有如此矛盾的情况发生呢?就相当于一个人怎么可能即是小孩,又是成年人,还是老年人呢?

冷静下来,发现一些端倪.它并不是让 a 同时等于 1 2 3, 而且 js 是单线程运行的. 及时它们写在了一行,那也是从左到右执行的. 所以它们可以不是同一时期的东西.既然不是同一时期的东西,那么一个人当然可以是过小孩子,是过成年人,是过老年人了.

回到题目,那么我想要让这个条件成立,就需要 a 判断一次,就变化一次.

1. 第一种方法,利用判断过程中的[隐式转换](https://www.wolai.com/dTBSZGyCzvqZGSk3TLXsvw)的`toString`方法

   ```JavaScript
   const a = {
     _a: 0,
     toString: function() {
       return ++_a
     }
   }

   ```

   运行一次,就给\_a 加 1,然后返回.

   因为 toString 是`Object.prototype`上面默认的方法,所以这个办法相当于把正常的[隐式转换](https://www.wolai.com/dTBSZGyCzvqZGSk3TLXsvw)中`toString` 方法给拦截了.

   问题是可以解决了,但是带来了新的问题.如果题目把双等变成三个等怎么办.这里的 toString 已经默认把对象转化为字符串了.使用`toStirng`的话,结果就不成立了.

2. 第二种方法,对象的数据拦截法

   ```JavaScript
   Object.defineProperties(window, {
     _a: {
       value: 0,
       writable: true
     },
     a: {
       get: function() {
         return  ++_a
       }
     }
   })
   ```

   对象的访问器相关内容可以查看[对于 JavaScript 面向对象的思考](https://www.wolai.com/gHrKSm75derryDEym74Rr3)
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[原型和原型链]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/原型和原型链</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/原型和原型链</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[原型和原型链 (当前个人理解,仅仅供参考)  一、函数的调用方式 要知道原型和原型链是什么.首先是需要知道函数的调用方式,所有知识点都不应该是孤立存在的,有了对于函数调用全盘的了解才能够明白原型链产生的过程发生了啥.这里简单做一些表述.  1.1 直接调用方式 JavaScript function fn() {} fn() const a = {   name: '妈咋',   fn: function() {     console.log(this.name)   } } a.fn() // 妈咋 这种方式是绝大多数人学习函数第一个学会的.但是我在看 B 站某个老师的视频上面有说到,函数...]]></description>
            <content:encoded><![CDATA[# 原型和原型链

(当前个人理解,仅仅供参考)

## 一、函数的调用方式

要知道原型和原型链是什么.首先是需要知道[函数](https://www.wolai.com/7S5VgfT6P6JEncbtktMzyf)的调用方式,所有知识点都不应该是孤立存在的,有了对于函数调用全盘的了解才能够明白原型链产生的过程发生了啥.这里简单做一些表述.

### 1.1 直接调用方式

```JavaScript
function fn() {}
fn()

const a = {
  name: '妈咋',
  fn: function() {
    console.log(this.name)
  }
}
a.fn() // 妈咋
```

这种方式是绝大多数人学习函数第一个学会的.但是我在看 B 站某个老师的视频上面有说到,函数直接调用方法,其实默认是`fn.apply(null)` 来进行调用的.只是隐藏了`.apply(null)`.

但是我自己没有在 MDN 上面找到答案,不知道是否如此,仅供参考.

> 在对象中的函数约定俗成也可以叫做方法.

直接调用函数的话, 默认是不用显性的 return 一个值的.它会默认给你返回一个[基础类型](https://www.wolai.com/cfEZbQMfHqb7T5GubTAxT)`undefined`.

[This](https://www.wolai.com/hJTA6d16NfXCuFNdoGsKcf)指向 windows 全局

### 1.2 call 和 apply

```js
function Test1() {
  this.name = "蚂蚱精";
}

function Test2() {
  Test1.apply(this);
}

const test = new Test2();
console.log(test); // 蚂蚱精
```

直接作用于 this 的指向`call`和 apply 的差别,在于,它后面跟着的是数组形式.

```js
function Test1(name, color) {
  this.name = name;
  this.color = color;
}

function Test2() {
  Test1.apply(this, "蚂蚱", "red");
  Test1.call(this, ["蚂蚱", "red"]);
}
```

有传闻,call 调用方式效率比 apply 高, 下面是别人实践的结果,

[call 和 apply 的性能对比 · Issue #6 · noneven/\_\_ (github.com)](https://github.com/noneven/__/issues/6)

### 1.3 构造调用方式

这个方式就是我们形成原型链的调用方式,[构造函数](https://www.wolai.com/5qkoS6CjH5i942b1ftD82C)的过程: 内部函数顶部创建 this,然后返回它.

**由上面四种方式可以知道,它们主要的不同在于** [This](https://www.wolai.com/hJTA6d16NfXCuFNdoGsKcf)**指向.排除这一点的话, ** [函数](https://www.wolai.com/7S5VgfT6P6JEncbtktMzyf)**的调用应该只有一种方式.**

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fb7e03c65f3415cba37eb13aaa36c59~tplv-k3u1fbpfcp-watermark.image?)

## 二、原型

要学习原型和原型链的话,还需要接触到这几个名词:

`prototype、__proto__、constructor`

- prototype: **构造函数实例化** 返回的属性,** 属于构造函数实例化,而不是构造函数的**
- **protp**: 构造函数实例化过程中,return 的 this 中的一个属性,这个属性的值是 `.prototype`, 它就相当于一个指针名,可以叫做 a、b、bb;在浏览器的控制器中打开现实是`[[prototype]]`.
- constructor: 指向构造函数本身,重点是该属性可以更改

![image_1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/294107b6d34840efb808ee7513414791~tplv-k3u1fbpfcp-watermark.image?)

```JavaScript
function Person() {
  this.name = '羊羊'
}
Person.prototype = {
  age: 26
}
const girl = new Person()

console.log(girl.age) // 26

```

其中`prototype` 就叫做原型. 它是一个对象.所以[引用类型](https://www.wolai.com/3zW26q3aThgyXGYhsCjdLe)有的特性它都有.

成功打印出`age` 这个属性的值. 实现的过程和之前说过的[构造函数](https://www.wolai.com/5qkoS6CjH5i942b1ftD82C)不能说一模一样,只能说是相差无几. `.prototype` 也是通过了某种神秘的方法, 在构造函数实例化中挂在在了 this 上面.

> 这种神秘的方法, 前端可以不用了解

```JavaScript
function Person() {
  var this = {
    name: '羊羊',
    __proto__: Person.prototype
  }
  return this
}

const girl = new Person()
```

Person 构造函数中, this 是在实例化过程中产生的.

如果在.age 在 this.第一层找不到的时候,会通过某种不需要前端知道的方法,进而去到**proto**上面找.

> 不知道从什么时候开始很多教材和视频说原型的例子,控制台打印的都是**proto**,但是我现在打印的都是`[[prototype]]`.

有一个很重要的一点, 就是`原型是挂载在实例上面的,而不是构造函数上面的`

```JavaScript
fucntino Car() {}
Car.prototype = {
  color: 'white'
}

cons a = new car()
console.log(a.color) // 'white'

car.prototype.color = 'red;
console.log(a.color) // 'red'
```

直接改变原型上面的值,是会引起实例属性的变化的, 毕竟你只是修改值.

但是下面这种情况就会出现问题了

```JavaScript
functino Car() {}
Car.prototype = {
  color: 'white'
}
const a = new Car()
Car.prototype = {
  color: 'red'
}
console.log(a.color) // white
```

### 原型赋值的混淆点

上面的例子直接的指出了对象 a 上面的[[prototype]]的值是原型. 重要的是这个过程不是一个**复制** 的过程.

而是一个关联的过程.在创建过程中,或者说是 new 的过程中,a 和内部的**proto**都会关联到 Car.prototype 上面.

这一知识点出自[《你不知道的 Javascript》上卷](https://www.wolai.com/9TQGZUcH6ZQfPw4RtTT8vs)5.2.3

正是因为如此,下面的代码才会成立:

```JavaScript
function Car() {
  this.color = 'red'
}

Car.prototype = {
  age: 18,
  constructor: Motorcycle
}

let car = new Car()
car.__proto__.age = 30
console.log(car) // [[prototype]]中的age 为30

```

原型上面的`age` 被改变了. 进而也导致了同样实例化`Car` 的变量也跟着改变.

```JavaScript
let car2 = new Car()
console.log(car2.age) // 30
```

这不是儿子打老子,小儿子跟着受罪么?

![image_2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96368f4d241b4c76b6729d63d527e315~tplv-k3u1fbpfcp-watermark.image?)

有人说,原型的存在就是为了继承.所以我们必须要屏蔽掉原型的**共享属性** 的副作用.

## 三、原型链

```javaScript
function Car() {
  this.name = 'one'
}
Car.prototype = {
  color = 'red'
}
const car = new Car()
```

![image_3.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0874101b3f446cba1e379650c4288b1~tplv-k3u1fbpfcp-watermark.image?)

左边一路下来的就是原型链了.

```js
console.log(car.color); // 'red'
```

在对象上面找不到的属性,会找到上一个原型上面继续找,知道找到位置,不然就是`undefined`.

从上面的图片也可以知道,car 上面有 Object.prototype,就是说,Object.prototype 上面有啥属性,car 都可以使用.

![截屏2021-12-25 22.31.59.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/346023b9f12445f3beda468d1a0070c0~tplv-k3u1fbpfcp-watermark.image?)

> ****proto** **是 [[Prototype]] 的具体表现属性. 所以图中的[[Prototype]] 就是代表**proto**

情况似乎有点不对.上面这么没有`Function` 构造函数呀...

这是因为实例化生成的是一个对象,所以原型链上面自然没有`Functino`才对,直接指向`Object`.正确的原型链图应该如下:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eb895ff2d894dce976eb7b78bb22b5a~tplv-k3u1fbpfcp-watermark.image?)

所以下面这题就能够理解了.

```
var F = function() {};

Object.prototype.a = function() {
  console.log('a');
};

Function.prototype.b = function() {
  console.log('b');
}

var f = new F();

f.a(); // 'a'
f.b(); // 报错, b 为定义

F.a(); // 'a'
F.b(); // 'b'
```
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[块级作用域与嵌套、let、暂时性死区]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/块级作用域与嵌套、let、暂时性死区</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/块级作用域与嵌套、let、暂时性死区</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[块级作用域与嵌套、let、暂时性死区 别以为你稳了, Don't get comfortable  let 都 2022 年了,let 和 const、以及 var 的区别有太多的文章作出了解析. 甚至于,如果不用兼容 ie11, 现在的项目都可以不用使用[[babel]]来进行转译.白白生成那么多多余的代码. 下面这些题都能够毫无压力的做出来,那么证明这个知识点你已经完全掌握了. 一共十二道题. js // 1 var b = 0 let b 10 console.log(b) - 结果   报错 js // 2 function test(a) {   let a = 19;   cons...]]></description>
            <content:encoded><![CDATA[# 块级作用域与嵌套、let、暂时性死区

别以为你稳了,
Don't get comfortable

## let

都 2022 年了,let 和 const、以及 var 的区别有太多的文章作出了解析.
甚至于,如果不用兼容 ie11, 现在的项目都可以不用使用[[babel]]来进行转译.白白生成那么多多余的代码.

下面这些题都能够毫无压力的做出来,那么证明这个知识点你已经完全掌握了. 一共十二道题.

```js
// 1
var b = 0
let b 10
console.log(b)
```

- 结果
  报错

```js
// 2
function test(a) {
  let a = 19;
  console.log(a);
}
test();
```

- 结果
  报错

```js
// 3
function test(a) {
  {
    let a = 10;
    console.log(a);
  }
  console.log(a);
}
```

- 结果
  10, undefined

```js
// 4
console.log(a);
let a = 10;

var a = a;
console.log(a);

let a = a;
console.log(a);
```

- 结果
  报错、undefined、报错

```js
// 5
function test(x = y, y = 2) {
  console.log(x, y);
}
test();
```

- 结果
  报错

```js
// 6
console.log(typeof a);
let a;
```

- 结果
  报错

```js
// 7
if (true) {
  let a = 1;
}

console.log(a);
```

- 结果
  报错

```js
// 8
for (; 1; ) {
  let a = 1;
}
console.log(a);
```

- 结果
  没动静

```js
// 9
{
  let a = 1;
  {
    let a = "a";
    console.log(a);
  }
  console.log(a);
}

for (let i = 0; i < 10; i++) {
  var i = "a";
  console.log(i);
}
```

- 结果
  'a'、1
  报错

```js
// 10
let i = 11;
for (let i = 0; i < 10; i++) {
  let i = 5;
  console.log(i);
}
console.log(a);

if (1) {
  let a = 1;
  {
    let a = 10;
    console.log(a);
  }
  console.log(a);
}
```

- 结果
  10 个 5、11、10、1

```js
// 11
var arr = [];
for (var i = 0; i < 10; i++) {
  arr[i] = function () {
    console.log(i);
  };
}
for (var i = 0; i < 10; i++) {
  arr[i]();
}
```

- 结果
  0、1、2、3、4、5、6、7、8、9

```js
// 12
for (var i = 0; i < 10; i++) {
  i = "a";
  console.log(i);
}

for (let i = 0; i < 10; i++) {
  i = "a";
  console.log(i);
}
```

- 结果
  'a'、'a'

var 时代,容易产生全局变量污染的问题. 在 es5 年代,通常来使用[[IIFE]]来解决一定问题. 但是在函数内部还是会出现这样的问题.这个时候我们就需要坚持一个原则来,[[KISS]]原则. keep it simple, stupid.

直接抛出 let 的带来的特点

1.  不可以重复定义
2.  变量不会提升,存在暂时性死区
3.  只能够在当前作用域下生效

上面的 12 道题目都可以套用这三个特点.

**- 从根本上来说,let 的带来为 js 带来了块级作用域.**

第十一题中, 就很隐蔽的出现了重复定义的问题. 第二次 for 循环中的 i 改变了 arr[i]中要打印出来的值. 在 es5 时代,对于这个问题,我们一般使用的[[IIFE]]形成的闭包的特性来进行解决.
如果第二个 for 循环换成 let

```js
for (let i = 0; i < 10; i++) {
  arr[i]();
}
```

打印的结果就是 10 个 10. let 不能够重复定义,也没有变量提升.此时的 i 和 arr 中的 i 看似命名一样.但是在栈内存中存储的位置是完全不同的.

第八题中,出现了无限循环,所以自然是不会运行到下面的.所以肯定是不会出现报错的.js 都没有运行到下面.

题目都很简单.let 的含义也很简单.毕竟都用了这么多年了.网上有大佬说,var、let、const 看情况来使用.但是我在业务中,没有找到 var 使用的任何场景,能用 const 就用 const,其余都是用 let.

## const

const 和 let 基本一致.除了对于基础类型变量的改变.

```js
const a = 0;
a = 10;
```

这样是会报错的.

```js
const a
```

这样还是会报错 `Missing initializer in const declaration`

但是下面这样就没有没有问题:

```js
const a = undefined;
```

所以说 const 是必须要初始化数据.

如果是引用类型的话,const 就不起作用了

```js
const a = {
  number: 1,
};
a.number++;
```

如果想要能够连对象都能够限制的话.就需要`Object.freeze()`上场了.
即便如此,const 变量依旧能够解决很多问题.对于 const、var、let 的使用,我们应该遵守这样的原则:

    尽量用let代替var,尽量用const代替let

一眼就能看到那些值是需要变化的,哪些不需要.

完
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[对象的属性描述符]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/对象的属性描述符</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/对象的属性描述符</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[对象的属性描述符  配置 definePropertye 之后,除了 value,其他值不显型的写出的话,默认是 false  js var o = { a: 1 }; Object.defineProperty(o, "b", {   value: 2,   writable: false,   enumerable: false,   configurable: true, });   - value: 基本属性值 - writable: 是否可以改,如果为 false 的话,在 es5 严格模式下面就会报错了 - enumberable: 是否可以枚举 ...]]></description>
            <content:encoded><![CDATA[# 对象的属性描述符

**配置 definePropertye 之后,除了 value,其他值不显型的写出的话,默认是 false**

```js
var o = { a: 1 };
Object.defineProperty(o, "b", {
  value: 2,
  writable: false,
  enumerable: false,
  configurable: true,
});
```

- value: 基本属性值
- writable: 是否可以改,如果为 false 的话,在 es5 严格模式下面就会报错了
- enumberable: 是否可以枚举
  设置为 false 的话,for in 就出不来这个属性
- configurable: 是否可以配置

  ```js
  const obj = {
    value: 6,
  };
  Object.defineProperty(obj, "value", {
    value: 2,
    writable: true,
    enumerable: true,
    configurable: false,
  });

  Object.defineProperty(obj, "value", {
    value: 4,
    writable: true,
    enumerable: true,
    configurable: true,
  });
  ```

  第二次 defineProperty 直接报错!!!!

```js
const person = {
  sex: "男",
};
Object.defineProperties(person, {
  name: {
    value: "wuyucun",
    writable: true,
    enumerable: true,
    configurable: true,
  },
  _age: {
    value: 20,
  },
  age: {
    get: function () {
      return this._age;
    },
    set: function (newVal) {
      this._age = newVal;
    },
  },
});
```
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[对象继承]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/对象继承</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/对象继承</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[对象继承  面向对象中必须要知道的继承 身为一个靠 js 吃饭的程序员.我们必须明白一点. JavaScript 是最纯正的面向对象的语言 JS 中没有类这个玩意儿,我们在 ES6 看到的 Class 是基于原型来模拟的.也称呼为[[模拟类]]. 比爪哇,C 什么加都要纯的多!!!🐶  我们为什么需要继承 js const kitty = {   say: function () {     console.log("喵喵喵");   }, }; const tiger = {   say: function (value) {     console.log("呼呼呼");   }, };...]]></description>
            <content:encoded><![CDATA[# 对象继承

# 面向对象中必须要知道的继承

身为一个靠 js 吃饭的程序员.我们必须明白一点.

**JavaScript 是最纯正的面向对象的语言**

JS 中没有类这个玩意儿,我们在 ES6 看到的 Class 是基于原型来模拟的.也称呼为[[模拟类]].
比爪哇,C 什么加都要纯的多!!!🐶

## 我们为什么需要继承

```js
const kitty = {
  say: function () {
    console.log("喵喵喵");
  },
};

const tiger = {
  say: function (value) {
    console.log("呼呼呼");
  },
};

const lion = {
  say: function (value) {
    console.log("嗷嗷嗷");
  },
};
```

上面每个对象中都有一个 say 的属性, 写了三遍.这个时候,如果我们都需要在 say 中添加一些判断的话,就需要在每个对象中添加一遍.那就是三遍了. 所以说我们需要一个办法,把三个对象都能够引用同一样一个方法.实现*代码的复用*.

```js
const Felidae = function ({ value }) {
  this.value = value;
  this.say = function () {
    console.log(this.value);
  };
};
const kitty = new Felidae({ value: "喵喵喵" });
const tiget = new Felidae({ value: "呼呼呼" });
const lion = new Felidae({ value: "嗷嗷嗷" });
```

这样子我们就不用给每个对象都写一遍 say 的方法了.

这个时候我需要让 Felidae 也能够有一些其他科的共同的方法应该怎么做呢?

```js
const Animal = function () {};
animal.prototype.run = function () {
  console.log("I can run");
};

const Felidae = function () {};
Felidae.prototype = new Animal();

const Kitty = new Felidae();
conosle.log(kitty.run()); // 'I can run'
```

通过[[原型]] 的赋值就可以达到要求.

## Kitty.run()的时候发生了什么

`Kitty`对象身上时不存在`run` 这个方法的.但是我们却能够直接调用它,这个过程中发生了什么呢?
要了解这个过程的话,我们需要一定的前置知识,[[对象的访问器属性]]和[[对象的属性描述符]]的相关知识.

**几乎**所有对象在创建之际,都会存在一个隐藏的属性,它就是原型[[prototype]]. 当我们在 Kitty.run()的过程中. 就是默认的[[Get]]的过程,它会先寻找自身的属性,如果没有的话,就往[[prototype]]上面找.直到找到为止,或者说知道`Object.prototye`为止.

> [[原型链]]的尽头就是 Object.prototype

> 几乎这个词很准确,应该通过 Object.create(null)创建的对象就很'干净'. 可以试着在控制器中打印出来看看.

[[Get]]的默认过程是这样,[[Put]]的过程呢?

## Kitty.color = 'white' 发生的屏蔽属性概念

接前面的代码,给 Kittiy 对象赋值 color.

```js
Kitty.color = "white";
console.log(Kitty.color); // 'white'
```

给 Kittiy 赋予 color 属性的过程中, 依旧会执行[[Get]]操作, 如果自身存在这个属性,就直接赋值就行.如果不存在,往[[原型链]]上面找.如果还是没有的话,会直接赋值 color 这个舒服给 Kitty.但是如果原型链上存在 color 属性的话,默认情况下就会发生`屏蔽属性`.

所以`屏蔽属性`,就是最下层的属性名和[[原型链]]上面的属性有重名的情况下,底层的这个属性会把[[原型链]]上面给屏蔽了,双方都存在.打印的话,会直接打印出底层的这个属性的值.

但是这个是默认的情况下,如果出现如下代码中的情况的话,就有得说了.

```js
const Felidae = function () {};
Object.defineProperties(Felidae.prototype, {
  color: {
    value: "black",
  },
});

const Kitty = new Felidae();
Kitty.color = "white";
console.log(Kitty.color); // 'black'
```

> 显性的使用[[对象的属性描述符]]的话,除了 value,其他不配置的话,默认都为 false

上面的代码没有产生屏蔽属性,也没有改变 color 的值.意不意外.
还有下面这种,也不会产生屏蔽属性:

```js
const Felidae = function () {};
Object.defineProperties(Felidae.prototype, {
  color: {
    set: function () {},
  },
});

const Kitty = new Felidae();
Kitty.color = "white";
console.log(Kitty.color); // undefined
```

由此我们可以总结出,当我们给一个对象赋值的时候,会出现的三种情况(出自[[你不知道的JavaScript上]]):

1. 如果在[[prototype]]链上层存在名为 color 的普通数据访问属性,并且没有被标记为只读(writable: false),那就回直接给 Kitty 添加一个 color 属性,它是`屏蔽属性`.
2. 如果在[[prototype]]链上存在 color,但是它被标记为(writable: true,). 那么无法修改已有属性或者在 Kitty 上面创建屏蔽属性. 在 ES5 严格模式下甚至会直接报错.
3. 如果[[prototype]]链上面存在 color,且有 set. 那就一定会调用 set.color 不会添加到 Kitty 中,也不会重新定义 color 这个 setter.

## 依托于原型的继承

开头就说了 JS 不存在类, 而是基于原型的继承,也称之为原型继承. 在传统意义中的继承中,继承意味着复制的操作.所以很多人都称 JS 的对象继承就像现实中父与子的关系, DNA 继承的关系等. 这样的说法不能说是完全不对,可以说是狗屁不通.

Js 中的继承不存在复制的操作,而是对两个对象之间产生一定的关联,它们不是父与子的关系.在[[你不知道的JavaScript上]]中称呼它们之间的关系用了`委托` 一词. 更像是一用雇佣的关系,可以说是平级的关系.

### 改变 this 的指向来实现继承

```js
function Animate() {
  this.color = "red"; // this可以当做隐藏的参数，所有下面通过apply调用函数的时候，this实际是Kitty作用域中的this。当new Kitty()的时候，就是它新创建的空对象，然后把这个兑现添加color,赋值为'red'
}

function Kitty() {
  Animate.apply(this);
}
const kitty = new Kitty();
console.log(kitty.color); // 'red'
```

Kitty 拥有了 Animate 构造函数的属性. nice. 似乎是完成了继承.可是这样有一个致命的问题, Kitty 没有办法继承 Animate 的原型。 因为 Animate 上面的原型没有集成 this, new 的时候，他们是组合的关系。但是在 Kitty 函数中，并没有 new Animate()

```js
function Animate() {
  this.color = "red";
}
Animate.prototype = {
  brand: "benz",
};

function Kitty() {
  Animate.apply(this);
}
const kitty = new Kitty();
console.log(kitty.color); // 'red'
console.log(kitty.brand); // undefiend
```

### 原型关联 new 一个构造函数实现继承

我们通过下面的代码得出图中所示:

```js
const Felidae = function () {};
Felidae.prototype = {
  run: function () {
    console.log("I can run");
  },
};

const Kitty = new Felidae();
conosle.log(kitty.run()); // 'I can run'
const lion = new Felidae();

const FelineSubfamily = function () {};
FelineSubfamily.prototype = new Felidae();

const tiger = new FelineSubfamily();
```

![[IMG_0069.jpg]]

kitty 和 lion 以及 tiger 看似没有直接的关系,但是都间接的有指向 Felidae.prototype. 和 Java 或者 dart 这些的继承不一样.它们在通过 new 之后,或者说是实例化之后,都是独立的个体.相互之间没有关系.

而 JS 的原型继承和 Java 背道而驰. JS 中‘实例化’的实例甚至能够更改[[prototype]]上面的属性.

```js
const Felidae = function () {
  this.option = {
    color: "white",
  };
};

const FelineSubfamily = function () {};
FelineSubfamily.prototype = new Felidae();

const Kitty = new FelineSubfamily();
Kitty.option.color = "妈咋";

const Lino = new FelineSubfamily();

console.log(Kitty.option.color); // ‘妈咋’
console.log(Lino.option.color); // '妈咋'
```

这个例子太典型了 , 所谓的'子级'改变了‘父级’的属性. 而且还连累了'兄弟'.
改变的是[[引用类型]].原始类型是否可以改变呢?

```js
const Felidae = function () {
  this.number = 1;
};

const FelineSubfamily = function () {};
FelineSubfamily.prototype = new Felidae();

const Kitty = new FelineSubfamily();
Kitty.number++;
const Lino = new FelineSubfamily();

console.log(Kitty.number); // 2
console.log(Lino.number); // 1
```

结果显示没有变化的. 这里面发生了什么呢?
解释这个过程呢,需要回到[[#Kitty run 的时候发生了什么]]中. 拆解一下`Kitty.number++`的过程:
kitty.number = Kitty.number + 1
这里直接给 Kitty 上赋予了一个 number 的属性.赋值操作是从右到左的.Kitty.number 在[[Get]]过程中,找到了原型链上面的 number,值为 1,所以 1 + 1,返回 2.而此时原型链上面 number 是默认的[[对象的属性描述符]].非只读状态. 所以是直接给`Kitty`上面赋予了 `number`的属性.

由此可以知道 JS 如此继承的隐患太大了. 也更加明确了对象的继承不是复制的操作. 为了减少这样的隐患.我们一般都将属性赋值到[[prototype]]上面:

```js
const Felidae = function () {};
Felidae.prototype = {
  color: "red",
};

const FelineSubfamily = function () {};
FelineSubfamily.prototype = new Felidae();

const Kitty = new FelineSubfamily();
Kitty.color = "white";

const Lino = new FelineSubfamily();

console.log(Kitty.color); // ‘white’
console.log(Lino.color); // 'red'
```

如此就可以消除,实例化对象直接通过访问成员属性来修改构造函数上面的属性. '兄弟级'也没有发生了意外的改变.
这样看起来,似乎对象的继承已经很安全了.其实不然, 这样依旧是不够安全;

```js
functino Car() {
  this.brand = 'benz'
}
Car.prototype = {
  brand: 'Mazda',
  intro: function() {
    console.log(this.brand)
  }
}

car.intro() // 'benz'
car.__proto__.intor() // 'Mazda'
```

> 这例子,同时也有对于[[This指向问题]]的解释

我们通过`__proto__`k 依旧能够访问到原型对象.
依旧可以通过**proto**去修改原型链上的东西.

```js
function Test() {}
Test.prototype = {
  color: "red",
};

function A() {}
A.prototype = new Test();

const a = new A();

a.__proto__.color = "green";
console.log(a.color); // 'green'

const b = new A();
console.log(b.color); // 'green'
```

### 创造一个中间构造函数来实现继承(企业级的做法)

```js
function Test() {}
Test.prototype = {
  color: "red",
};

function Buffer() {}
Buffer.prototype = Test.prototype;
const buffer = new Buffer();

function A() {}
A.prototype = buffer;
A.prototype.color = "green";

const a = new A();
console.log(a.color); // 'green'

const b = new Test();
console.log(b.color); // 'red'
```

通过一个中间的`Buffer` 就轻松的解决了来继承的对象改变 Test 原型上面的属性.

每次都创建一个`Buffer` 的话会很麻烦,可以封装一下

```js
function inherit(Target, Origin) {
  function Buffer() {}
  Buffer.prototype = Origin.prototye;
  Target.prototype = new Buffer();
  // 规范构造函数的数据
  Target.prototype.constructor = Target;
  Target.prototype.super_class = Origin;
}
```

自此.对象的原型继承相对稳定了. 其实就算加了一个缓冲的函数,子级依旧可以修改父级的属性.`通过obj.__proto__.__proto__.xxx` 还是能够把任何想要改的原型链上的东西.

还需要配合[[对象的属性描述符]]才可以更稳定.让原型链上的属性都配置上只读不可配置.

对象的原型继承如此的别扭,这不行那不行的.更不用说还有传统面向对象中,基于类的多态的概念.费劲.
所以说,react 推出了 hook, vue 推出了 3.0. 都提供了一定的函数式编程的概念.通过函数的组合来代替对象的继承.
 🤓
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[js让人诟病的这些feature]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/js让人诟病的这些feature</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/js让人诟病的这些feature</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[![](https://img2.baidu.com/it/u=139382954,2115973602&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500k)  js 让人诟病的这些 feature  1.前言 - 是糟粕还是feature?这要取决于对于它的认识和使用.用的好就是 feature,用得不好,可能就不单单是糟粕,还会要留在公司加班的.所以为了更加好的利用隐式转化,今天我们要好好的认识它. - 而大部分的觉得 js 混乱的原因,也是由于它的想对于静态语言的不确定性. - 下面我就一一来解析这些让人疑惑的问题. > Thanks for inve...]]></description>
            <content:encoded><![CDATA[![](https://img2.baidu.com/it/u=139382954,2115973602&fm=253&fmt=auto&app=120&f=JPEG?w=889&h=500k)

# js 让人诟病的这些 feature

## 1.前言

- 是糟粕还是`feature`?这要取决于对于它的认识和使用.用的好就是 feature,用得不好,可能就不单单是糟粕,还会要留在公司加班的.所以为了更加好的利用隐式转化,今天我们要好好的认识它.

- 而大部分的觉得 js 混乱的原因,也是由于它的想对于静态语言的不确定性.

- 下面我就一一来解析这些让人疑惑的问题.

> Thanks for inventing JavaScript!!!!

## 2. 0.1 + 0.2 == 0.3

### 分析

- 输出结果是`false`
- 老问题了, 这个不单单是在 Javascript 中存在,在被的语言中都存在浮点数精度的问题. 高级语言中看到的数字背地里都是需要转化成二进制来计算的.而问题就恰好出在转化成二进制过程中产生的误差.

  1.  简单的说,在 0.1 + 0.2 计算过程中,经过两次误差的计算.第一次, 经过第一次转化为双精度二进制浮点数的时候,二进制浮点数小数位只能存储 52 位,导致 52 位之后的数字进去的取舍.
  2.  第二次,发生已经转化为二进制时候的 0.1 和 0.2 相加的操作, 又超出了位数的范围.

- 两次的误差导致了 0.1 + 0.2 == 0.3 为 `false` .

> 在业务开发中,一般会影响到价格的计算. 所以为了避规这个问题,后台返回为前端的通常都是乘以 100 之后的单位,保证都是整数.

### 解决办法

- 情况已经是这么个情况,但是如果还是遇到了这样的应用场景的话.也不是没有办法解决.

  1.  先乘以 1000 再去掉

      ```js
      (0.1 * 1000 + 0.2 * 1000) / 1000 == 0.3;
      ```

  2.  使用 ES6 的`Number.EPSILON`方式
      ```js
      console.log(Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);
      ```
  3.  用`math.js` 这个库, 听说对于某些数字还是有问题,精准计算还是对给后台吧 🤔
  4.  使用`Math.round` 和`Math.pow`的方法结合

## 3. typeof 容易忘记的三个点

- `typeof [[target]]` 返回的是一个字符串

- typeof null

  ```js
  console.log(typeof null); // 'object'
  ```

  这玩意儿截止到现在都还没有改,现在记住就行,就是一个坑

- typeof NaN
  ```js
  // 'number'
  ```
- NaN 的全称是`not a number`, 但是 typeof 出来的却是`number`.
- 太瞎了,还有更加瞎的

  ```js
  NaN == Nan; // false
  Number.Nan == NaN; // false
  NaN === NaN; // fasle
  Number.NaN === NaN; // false

  Object.is(NaN, NaN); // false
  ```

- 自己永远不等于自己.

## 4. 9999999999999999

```js
console.log(9999999999999999); // 10000000000000000
```

- 还是 js 精度 w 问题,超过 53 位就没有精准度而言

## 5. 隐式转化

### 5.1 相加还是相减少

```js
 1 + {} === ?
 {} + 1 === ?
 1 + [] === ?
 1 + '2' === ?
```

- 上面题目的结果
  1[object object], [object object]1, 1, 12
- 空对象被`Object.prototype.toString.call({})`
- 空数组转化为了 0

```js
1 + '1' => 11
1 - '1' => 0
```

- 这里的结果表示了,字符串碰到 + 号, 把两者弄着字符串,然后连起来
- 但是如果是 - 号的话, 就把字符串转化为 Number 类型,相减

```js
const a = [];
if (a) {
  console.log("1");
}

if (a == true) {
  console.log("2");
}
```

- 结果:
  打印出 1

- 单个空数组的话, typeof a === 'object', 所以能够打印出 1
- 和 bealoon 进行比较的话会先 Number(a) == Number(ture) => 0 == 1 => false. 所以 2 没有打印出来

```js
console.log(new String("abc") == true);
console.log({} == ture);
console.log(([] = ![]));
```

- 结果
  fasle, false, true
- 是不是有和你想得不一样的,在没有深入总结 js 隐式转化之前,我没次看到都会有错.全称靠猜,这种没有掌握规律的感觉很难受.

### 5.2 乱七八糟的转化

- 上面的例子中,没有一个正常进行运算的,都在背地里面做了某个方式的转化. 果然十天就弄出来的东西,一切都朝着简单的来. 现在 TS 大行其道是必然.😢
- 求求了,团队都用上 TS 吧!
- 为什么要想不开,要在项目中将不同类型的玩意儿进行运算呢?

- 但是面试的时候考啊, 那么通过穷举法来找找规律看看

#### +号规律

```js
// number, string, boolean, null, undefined, 排除symbol和bigInt
console.log(1 + "1"); //  '11'
console.log(1 + true); // 2
console.log(1 + 1); // 2
console.log(1 + null); // 1
console.log(1 + undefined); // NaN
console.log(1 + []); // 1
console.log(1 + {}); // 1[object Object]

// 字符串
console.log("1" + "1"); // '11'
console.log("1" + true); // '1true'
console.log("1" + null); // '1null'
console.log("1" + undefined); // '1undefined'
console.log("1" + []); // '1'
console.log("1" + {}); // '1[object Object]'

// boolean
console.log(true + true); // 2
console.log(true + null); // 1
console.log(true + undefined); // NaN
console.log(true + []); // true
console.log(true + {}); // true[object Object]

// null
console.log(null + null); // 0
console.log(null + undefined); // NaN
console.log(null + []); // null
console.log(null + {}); // null[object object]

//
console.log(undefined + undefined); // NaN
console.log({} + {}); // '[object Object][object Object]'
console.log({} + []); // '[object Object]'
console.log([] + []); // empty
```

从上面可以知道这么一些规律:

1. 空数组在加号中表达的是 empty, 就是空,和它一起相加不管是什么都返回它本身, 包括它的类型.
2. 加号两边有字符串相加的话,会有将和字符串相加先转化为字符串,和第一点是不冲突.空数组专为空字符串
3. 补充第二点, 相加的是对象的话,**无所谓是不是空对象**.都会转化为字符串
4. 除此之外都优先讲变量转化为中数字.

#### -号规律

```js
console.log(1 - "1"); //  0
console.log(1 - true); // 0
console.log(1 - 1); // 0
console.log(1 - null); // 1
console.log(1 - undefined); // NaN
console.log(1 - []); // 1
console.log(1 - { name: "我有值" }); // NaN

console.log("--------------");

console.log("1" - "1"); // 0
console.log("1" - true); // 0
console.log("1" - null); // 1
console.log("1" - undefined); // NaN
console.log("1" - []); // 1
console.log("1" - {}); // NaN

console.log("--------------");

console.log(true - true); // 0
console.log(true - null); // 1
console.log(true - undefined); // NaN
console.log(true - []); // 1
console.log(true - {}); // NaN

console.log("--------------");

console.log(null - null); // 0
console.log(null - undefined); // NaN
console.log(null - []); // 0
console.log(null - {}); // NaN

console.log("--------------");

console.log(undefined - undefined); // NaN
console.log({} - {}); // NaN
console.log({} - []); // NaN
console.log([] - []); // 0
```

- 减法就要单纯得多,只要将双方都 Number 之后再相减就行了
- NaN 和任何类型相减都是 NaN
- [] - [] 是一个例外, 不是 NaN, 我不理解.我在网上也没有找到对应的答案 也可能是我搜索关键字有问题. 问题只要是处在`Number([])` 和`Number([1, 2])`已经`Number([1])`上面.为什么它会这么骚气的为 0 , NaN, 1.

```js
console.log(Array.prototype.toString.call([])); // ''
console.log(Array.prototype.toString.call([1])); // '1'
console.log(Array.prototype.toString.call([1, 2])); // '1, 2'
```

#### !的转化规则

```js
let b;
const a = !!b;
```

- 双感叹号强制转化类型为 boolean

| 数据类型  | 转化 true               | 转化为 false |
| --------- | ----------------------- | ------------ |
| Boolean   | true                    | false        |
| Number    | 任何非零数字,包括无穷大 | 0 和 NaN     |
| String    | 任何非空字符串          | ''           |
| Object    | 任何对象                | null         |
| undefined |                         | undefined    |

#### ==的转化规则

- 不用 TS,你起码要用===吧.😂, 为什么还要使用==这么漏野的玩意儿呢?
- 同类型的直接比较,除了引用类型
- **其他的如果不是下面的情况,两边都是转化为 number**

1. 引用类型和数字/字符串的比较

   ```js
   const a = {};
   console.log(a == 1); // fasle
   console.log(a == "1"); // fasle
   ```

   - 在 jbs 引擎中进行如下的操作:
     - a.valueOf()获取到是不是基本类型
     - 如果不是的会调用 toString().得到`[object Object]`
     - `[object Object]` 自然和 1 不想等了.

```js
const a = new String(123)
cosnole.log(a == 123) // true

cosnt b = new String('aaa')
cosnole.log(b == 'aaa') // true
```

- 调用 valueOf() 直接就得到了基础数据类型.

2. 引用类型和引用类型的比较

```js
console.log([] == []) // false
console.log([] == {}) // false
console.log({} == {})j'j // false
```

- 两边都是引用类型的话,直接比较的是指向的地址的. 地址自然不可能不一样, 除非下面这样的操作
  ```js
  const a = {};
  const b = a;
  console.log(a == b); // true
  ```

3. null、undefined、NaN 和 String Number Boolean Object 比较的时候,比较的结果字节是 false

4. [] == ![] 为 true 不是特例
   - 这个要结合[[运算符的优先级]]来思考的.
   - !的优先级大于==
   - 所以![] 为 false, []是引用类型 toString()为`[object Object]`.
   - 此时[] == fasle,两边都转化为 number,
   - 0 == 0, 为真

#### 大于小于号规则

- 这个问题有一个典型的案例.

  ```js
  const a = [1, 23, 12];
  cosnole.log(a.sort()); // [1, 43, 5]
  ```

  我们都知道,这个是由于 sort 它排序的方法就是把数组中的数字变为字符串,然后比较 ASCII 码.

  ```js
  function sortNumber(pre, next) {
    return pre - next;
  }
  console.log(a.sort(sortNumber())); // [1, 5, 43]
  ```

  只有自己添加这样的函数才可以真正的实现你想要的排序.这个是 es 规定给你的两个 pre, next 值. 如果返回的是真就说面前一个值大于后面一个值,两个就互换位置,反之亦然.这个就是[[数据结构]]中[[冒泡排序]]的简单实用

  〉 return pre - next 是升序, 降序反过来就行了

- 所以说,下面的为 false

```js
console.log("23" > "3");
```

## 6. 隐式转化另外一种记忆的方法

隐式转化无非就是在处理数据的过程中,发生了装包和拆包.使用了 JS 核心库中的一些包装类来封装.
所以我们在记忆包装类的结果之后,再结合各种运算符会出发的包装. 从逻辑上面更加的容易记忆.

### 6.1 Number

| 操作              | 结果      |
| ----------------- | --------- |
| Number(undefined) | NaN       |
| Number(null)      | 0         |
| Number('')        | 0         |
| Number(infintity) | Infintity |

> null 是特例,强行记住就行 😮‍💨

### 6.2 Boolean

- 虚值(false): undefined、null、0、NaN、false, ''
- 其他类型都是 true, 除了上面的虚值
- 引用类型都是 true

  | Boolean([]) | Boolean({}) | Boolean(/d/) | Boolean(new Error()) | Boolean(Symbol()) |
  | ----------- | ----------- | ------------ | -------------------- | ----------------- |

## 7. 祝世界和平,祝愿所愿的团队都早日用上 TS,开心过好每一天
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[new 的时候都干了什么]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/new 的时候都干了什么</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/new 的时候都干了什么</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[new 的时候都干了什么  为什么要有 new 我认为了解一个 api 怎么用之前，更重要的是要知道这个 api 为什么因何而诞生的！ JS 的诞生就是为了快速的解决问题的。所以它的语法很多时候都是为了让用户省心而设计的，比如弱语法，比如这个 new。 <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36b0879f8da6456c93b5f93f7ff93855tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="30%" /> 在我平时写的业务中，其实没有创造...]]></description>
            <content:encoded><![CDATA[# new 的时候都干了什么

## 为什么要有 new

**我认为了解一个 api 怎么用之前，更重要的是要知道这个 api 为什么因何而诞生的！**

JS 的诞生就是为了快速的解决问题的。**所以它的语法很多时候都是为了让用户省心而设计的，比如弱语法，比如这个 new。**

<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36b0879f8da6456c93b5f93f7ff93855~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="30%" />

在我平时写的业务中，其实没有创造大量对象的场景。所以这里以游戏的业务为例子。我记得微信小游戏的 DEMO 就是飞机大战，现在我们给敌机设计它的属性。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a39bf557f998426d9c1a3b915c49614f~tplv-k3u1fbpfcp-zoom-1.image)

对于敌机而言，它有不同的机种，不同的血量，可以发送子弹，可以向屏幕下方移动。在代码中如下：

```js
const 敌机 = {
  key: 0001, // 唯一ID
  机种: 'a', // 非boss
  攻击范围: 1000,
  发射: function() {
    // 发射子弹
  }，
  向下移动: function() {
    // 冲向我方
  }
}
```

这是一辆飞机的对象。但是在飞机大战当中，敌机可是满屏都有的。所以我们需要很多辆这样的飞机：

```js
const 敌机s = []

for (let i = 0; i< 50; i++) {
  let 敌机 = {
    key: '敌机' + i, // 唯一ID
    机种: '歼20', // 非boss
    攻击范围: 1000,
    发射: function() {
      // 发射子弹
    }，
    向下移动: function() {
      // 冲向我方
    }
  }
  敌机s.push(敌机)
}
```

上面对象数组中的发射和向下移动是完全一样的函数 ，但是被创造了 50 遍。机种和攻击范围是固定，只有 key 值各不相同。

所以我们可以有如下的改造：

```js
const 敌机原型 = {
  兵种: "歼20",
  攻击范围: 1000,
  发射: function() {
    // 发射子弹
  }，
  向下移动: function() {
    // 冲向我方
  }
}

const 敌机s = []
for(let i = 0; i < 50; i++) {
  let 敌机 = {
    key: '敌机' + i,
  }

  敌机.[[proto]] = 敌机原型

  敌机s.push(敌机)
}
```

是不是有点‘构造’函数那个味了？循环里面我们做了两件事情，创建对象，以及处理对象，干了两件事情，敌机的对象也分开来了。有了更好的复用，我们可以使用函数来封装：

```js
function 敌机(key){
  var 临时对象 = {}

  临时对象.[[proto]] = 敌机.原型

  临时对象.key = '敌机' + key

  return 临时对象
}

敌机.原型 = {
  兵种: "歼20",
  攻击范围: 1000,
  发射: function() {
    // 发射子弹
  }，
  向下移动: function() {
    // 冲向我方
  }
}
```

随后在创建敌机们的时候，可以直接调用上面的函数：

```js
const 敌机s = [];
for (let i = 0; i < 100; i++) {
  敌机s.push(敌机(i));
}
```

回到我说的第一句话，**它的语法很多时候都是为了让用户省心而设计的。**

它的这个省心体现在哪里呢？

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dc2424447964368be1c666e4b8e4e9f~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32e551505a4f40289d238881d8b2fd33~tplv-k3u1fbpfcp-zoom-1.image)

悄悄这位慈祥的老人。他为了让我更快的创建对象，通过一个 `new` 关键字为我们省略了四个步骤！

## 当函数 return 不同类型的时候

通俗的知道了 new 的意义，我们再来看它在这个过程中做了什么就容易很多了。

回想一开始学习 JS 的时候，好好的函数，非要弄一个构造函数的称呼出来。

我第一次看到构造函数的时候，郁闷了好久，为什么函数还分这么类型，匿名函数、立即执行函数、构造函数。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29546be3880048188b817968dde9421d~tplv-k3u1fbpfcp-zoom-1.image" alt="" width="30%" />

给我造成了多年的记忆负担！函数就是函数，不能因为运行函数的时身边的关键字不一样就给它瞎起名字。

所以就应该是 new 一个函数，而不是 new 一个构造函数。

在 new 的过程中主要就是分为两种情况，根据函数 return 的是基础类型还是引用类型，返回不同的结果。

## return 基础类型

当使用`new`关键字调用一个函数时，函数中 return 的是一个基础类型。JavaScript 引擎将执行以下步骤：

1.  创建一个新的空对象。
1.  将新创建的对象的原型指向构造函数的原型对象。
1.  将构造函数的 this 关键字绑定到新创建的对象上。
1.  执行构造函数中的代码，将属性和方法添加到新的对象中。
1.  如果构造函数返回一个对象，则返回该对象，否则返回新创建的对象。

下面是一个简单的例子，演示了使用`new`关键字创建对象实例的过程：

```
// 定义一个构造函数
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// 在Person的原型对象上添加一个方法
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
}

// 使用new关键字创建对象实例
const person1 = new Person('John', 30);

person1.sayHello(); // 输出: Hello, my name is John and I am 30 years old.
```

在上面的例子中，我们定义了一个`Person`构造函数，它有两个参数：`name`和`age`。然后，我们在`Person`的原型对象上添加了一个`sayHello`方法，该方法输出一个字符串，包含对象的`name`和`age`属性。最后，我们使用`new`关键字调用`Person`构造函数，并将结果赋值给`person1`变量。最后，我们调用`person1`对象的`sayHello`方法，输出一个字符串。

通过这个例子，我们可以看到，使用`new`关键字创建对象实例时，JavaScript 引擎会将新创建的对象的原型指向构造函数的原型对象，因此我们可以在构造函数的原型对象上定义方法，并在新创建的对象上使用这些方法。

> 众所周知，函数不写 return 的时候，它返回的是 undefined, 也是基础类型

## return 引用类型

return 引用类型就简单很多，return 的对象会直接'覆盖'JS 引擎内部生成的 "this" 对象。如下代码片段：

```js
function Person(name) {
  this.name = name;
  return {
    name: "Greg",
  };
}
Person.prototype.say = function () {
  console.log("yoran");
};

const p = new Person("John");
console.log(p.name); // Greg
```

## 总结一下

- new 一个对象的过程

  1.  创建一个空对象
  1.  给这个空对象添加`__proto__`属性,并指向`prototype`原型对象
  1.  将 this 的属性绑定到这个对象当中
  1.  然后`return`这个对象给实例化对象

- `return`的是基本类型和对象会带来不同的效果

  - `return`的是数字的话, 不会有什么变化,直接走以前的
  - `return`的是对象的话, 会直接覆盖你上面的那一连串骚操作

## 手写一个 new 方法

```js
function targetFn(name) {
  this.name = name;
}
targetFn.prototype = {
  aget: 18,
};

function myNew(fn, ...rest) {
  const newObj = Object.create(fn.prototype);

  const returnResult = fn.apply(newObj, rest);

  return isObject(returnResult) ? returnResult : newObj;
}

function isObject(obj) {
  const target = "[object Object]";
  return Object.prototype.toString.call(obj) === target;
}
```
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[parseInt总结]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/parseInt总结</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/parseInt总结</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[parseInt 使用总结 parseInt('012', 16)和 parseInt(012, 16)相等吗？ ["10", "10", "10", "10", "10"].map(parseInt)的结果是什么？ 先来一起复习一下parseInt()的基本用法。  1 parseInt()的使用说明 使用参数说明：paraseInt(value: string, radix?: number) > parseInt()是对 Number()很好的补充  1.1 解析数字和字母的混合字符串 当Number()返回的都是NaN的时候，parseInt()有不一样的解析结果。parseInt 会...]]></description>
            <content:encoded><![CDATA[# parseInt 使用总结

**parseInt('012', 16)和 parseInt(012, 16)相等吗？**

**["10", "10", "10", "10", "10"].map(parseInt)的结果是什么？**

先来一起复习一下`parseInt()`的基本用法。

## 1 parseInt()的使用说明

使用参数说明：**paraseInt(value: string, radix?: number)**

> parseInt()是对 Number()很好的补充

### 1.1 解析数字和字母的混合字符串

当`Number()`返回的都是`NaN`的时候，`parseInt()`有不一样的解析结果。parseInt 会忽略无效字符，如果第一个字符串元素就非数字，那么就返回`NaN`。

```js
Number("123abc"); // NaN
Number("123asd1"); // NaN
Number("ad123"); // NaN
// -------
parseInt("123abc"); // 123
parseInt("123asd1"); // 123
parseInt("123---8979$$$"); // 123
parseInt("ad123"); // NaN
```

### 1.2 用于浮点数的取整:

```js
console.log(parseInt(11.22)); // 11
console.log(Number(11.22)); // 11.22
```

### 1.3 将其他的进制转化为十进制

- 标准格式: **`parseInt(string, radix)`**
- `radix`: 表示字符串的基数，取值范围是从 2 到 36。16 就表示被解析值是十六进制数。
- 计算方法：**基数 \* (radix ^ (当前位数 - 1)) 然后依次相加**

如下例子:

```js
console.log(parseInt(101, 2)); // 5
console.log(parseInt(123, 5)); // 38
parseInt("6axxx", 16); // 106
```

> parseInt('6axxx', 16), 16 进制能够识别 6a，到 x 为止。

其转化的过程如下：

$1\times( 2 ^ 2 ) + 0 \times (2 ^ 1) + 1 \times (2 ^ 0) = 4 + 0 + 1 = 5$

$1 \times (5 ^ 2) + 2 \times (5 ^ 1) + 3 \times (5 ^ 0) = 25 + 10 + 8 = 38$

需要注意的是：

- `radix`的默认值不一定是 10，如果字符串 string 以其它任何值开头，则基数才是 10 (十进制)。

这玩意儿很智能.输入的如果是标准的 16 进制或者 8 进制的话,就可以把`radix`初始化为对应的进制的值。比如说`parseInt(0xfff)` 的结果是 4096，不用放入`radix`值。

但是如果，你后面非要加非 16 进制的制位的话，那还是会按照对应的`radix`来计算。比如`parseInt(012, 3)`是 3 而不是 8。

### 1.4 parseInt 中的隐式转化

parseInt('012', 16)和 parseInt(012, 16)的结果是否一致呢？

我们打印结构如下：

![截屏2023-02-11 00.34.18.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90be49c2fde944bbba3ef86f3cfd1c4a~tplv-k3u1fbpfcp-watermark.image?)

**前者是 18，后者是 16！**， why?

很简单，其实通过我这个小标题也能够知道原因。因为 parseInt(012, 16)发生了隐式转化。第一参数是`string`类型，而它是`number`类型，构成了隐式转化的条件，触发了`toString()`的规则。

`012.toString()`结果为 10.

所以说，**parseInt(012, 16) = parseInt('10', 16).**

$$
1 \times(16^1)+0\times(16^0)=16
$$

## 2. **可以用来取整**

```JavaScript
console.log(parseInt(1213.22)) // 1213
console.log(parseInt('1213.22')) // 1213
console.log(parseInt('-1213.22')) // -1213
```

上面的过程会经过如下:

1. isNaN 判断他是否是数字,不同的是 isNaN 在如果是数字或者**以数字开头**的字符串的话返回的是`boolean` 类型`true`. 而在 parseInt 中是返回了数字或者到出现除数字之外的字符位置.
   ```JavaScript
   console.log(parseInt('123add')) // 123
   console.log(parseInt('1123.22')) // 1123
   ```
   间接的达到了取整数的作用.
2. 转化为`String`类型.

## 3.**设置当前的的\*\***`String`\***\* 是多少进制的. **

parseInt 标准格式

parseInt(_string_, _radix_);

radix 默认为 10,即 10 进制.

取值范围是从 `2` 到 `36`，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，

**10 不是默认值！**

```JavaScript
parseInt('1011', 2) // 11
parseInt('123', 5) // 38
```

其他进制转化为十进制的公式

最高位数 _ (radix ^ (当前位置 - 1)) ..... + 最后一位数 _ (radix ^ 0)

从而可以得出

```JavaScript
1 * (5 ^ 2) + 2 * (5 ^ 1) + 3 * (5 ^ 0) = 38
```

## 4. 当然也存在不需要填写 radix 就可以得出它是多少进制的情况

```JavaScript
parseInt('0xfff') // 3095
```

如上所示,如果输入的是标准的 16 进制的表示法,后面的 radix 是可以省略的.

这也印证了 10 不是默认值！

## 5. 通过经典面试题检查对于它的理解

下面的输出结果是什么？

```js
["10", "10", "10", "10", "10"].map(parseInt);
```

我们需要有这么一个认知：

- map 是一个函数
- map 的的参数有两个，一个函数`callbackFn`，一个可选对象`thisArg`，用于执行前者用作`this`值。
- map 的的参数函数有三个参数：`currentValue`、`index`、`array`
- `parseInt`就是一个函数

所以说，什么的题目等于下面代码片段：

```js
["10", "10", "10", "10", "10"].map((item, index) => {
  return parseInt(item, index);
});
```

由此可得：

```js
parseInt("10", 0); // 10
parseInt("10", 1); // NaN
parseInt("10", 2); // 2
parseInt("10", 3); // 3
parseInt("10", 4); // 4
```

那么我们根据上面的描述，就可以很自然得出`[1, 2, 3, 4].map(parseInt)`的结果。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[再次理解闭包]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/再次理解闭包</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/再次理解闭包</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[再次理解闭包  一、为什么重复写闭包 之前也写过关于闭包的文章。使用到了上下文，使用到了[[立即执行函数]]，使用到了 AO、GO，甚至还使用到了[[堆内存]]这一大堆名词来进行解释。 一个月过去之后，自己看都愣半天。啥是堆内存了？AO 和 GO 又是什么玩意儿？ !image.png 用了一些更高深莫测的词汇来解释一个概念，而这些词汇的知识点甚至比当前要解释的概念更复杂。在当前 AI 大行其道的时代，或许写这种基础知识的文章更多的是为了悦己，为的是加深自己对于某个知识点的，而不是装逼的。 通俗易懂才是最重要的。 之前写得还是太复杂了，随着自己的理解加深，重现更新，加深自己的认知。  二、闭包...]]></description>
            <content:encoded><![CDATA[# 再次理解闭包

## 一、为什么重复写闭包

之前也写过关于闭包的文章。使用到了上下文，使用到了[[立即执行函数]]，使用到了 AO、GO，甚至还使用到了[[堆内存]]这一大堆名词来进行解释。
一个月过去之后，自己看都愣半天。啥是堆内存了？AO 和 GO 又是什么玩意儿？
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d17f26cce084569a01c679c8a854c2b~tplv-k3u1fbpfcp-watermark.image?)
用了一些更高深莫测的词汇来解释一个概念，而这些词汇的知识点甚至比当前要解释的概念更复杂。在当前 AI 大行其道的时代，或许写这种基础知识的文章更多的是为了悦己，为的是加深自己对于某个知识点的，而不是装逼的。

**通俗易懂才是最重要的。**

之前写得还是太复杂了，随着自己的理解加深，重现更新，加深自己的认知。

## 二、闭包是什么

闭包由 closure 翻译而来。

<img width="300" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c03e70ce92e4d64a23c105b48502da3~tplv-k3u1fbpfcp-watermark.image?"/>

它的含义更多的是闭，而不是包。为什么要提及这一点呢？因为这词语更加准确的翻译应该是**闭合性**，我们在讨论 JS 的闭包的时候，其实是在讨论 JS 中如何实现函数的闭合性的？

换一句话来说，**就是 JS 如何让变量在函数外边如何被调用的**。这个本质依旧是在说[[函数作用域]]。只需要让目标变量的作用域不被销毁，那么你就可以在任何地方访问这个变量。如下图，fn1 想要访问 fn2 内的 a 变量：

![[Pasted image 20250410193451.png]]

> 这里提到的这个变量，一般来说指的不是变量的指，而是这个变量的内存位置。

那么，闭合性在 JS 中是如何表现的呢？实践是唯一真理，直接看下面的闭包的例子，从中总结规律。

**1. 第一段代码，常见的闭包,直接返回一个函数：**

```js
function foo() {
  let local = 1;
  return function () {
    local++;
    console.log(local);
  };
}

const fn = foo();
fn(); // 2
fn(); // 3
```

**2. 第二段代码，循环赋值 + IIFE:**

```js
for (var i = 0; i < 10; i++) {
  (function () {
    setTimeout(function () {
      console.log(i); // 10, 10, 10, 10, 10
    }, 1000);
  })();
}
```

**3. 第三段代码，全局应用函数:**

```js
function foo() {
  let local = 1;
  window.addLocal = function () {
    local++;
    console.log(local);
  };
}
addLocal(); // 2
addLocal(); // 3
```

**4. 第四段代码，函数返回对象函数：**

```js
function foo() {
  let local = 1;
  function too() {
    local++;
    console.log(local);
  }
  function eoo() {
    local++;
    console.log(local);
  }
  return [too, eoo];
}

const a = foo();
a[0](); // 2
a[0](); // 3
a[1](); // 4
```

上面段代码都体现了 JS 中函数对于闭合性的实现。局部变量在函数外部依旧可以访问到。通过这四个代码片段，我们找到它们的共性，得出 JS 实现闭合性的最小单位如下：

```js
let local = 1;
function foo() {
  console.log(local);
}
```

但是这样看不出它是局部变量，那么我们给它添加上 IIFE：

```js
(function () {
  let local = 1;
  function foo() {
    console.log(local);
  }
})();
```

由此我们还可以给出一些关于 JS 实现函数闭合性的问题：

1. 不是一定需要 return 一个函数，代码片段 3 和 4 中都没有返回一个函数。
2. 不是一定需要函数嵌套函数，代码片段 2 中。

## 三、闭包实现的原理

**闭包是 JS 函数作用域的副产品**,所以《高程》上面说了解闭包就要先理解什么是函数作用域。它是 由**函数**和*这个函数可以访问到的变量*这两者构成的。

上面的说到的作用域和垃圾回收机制在其中又有什么作用的呢？

- ​**​[[作用域]]（词法环境）​**​：  
   JavaScript 闭包的核心机制是 ​**​ 词法作用域 ​**​（Lexical Scope）。当一个函数内部定义了另一个函数，且内部函数引用了外部函数的变量时，内部函数会“记住”它被定义时的词法环境（即外部函数的作用域），即使外部函数已经执行完毕。这是闭包实现的基础。
- ​**​[[垃圾回收机制​]]**​：  
   JavaScript 的垃圾回收机制（Garbage Collection）会回收不再被引用的内存。闭包中，如果内部函数仍然持有对外部函数变量的引用，这些变量就不会被回收（即使外部函数已执行完），从而形成闭包。因此，垃圾回收机制间接支持了闭包的存在。

两者缺一不可。

结论：JS 对于函数闭合性的实现是基于作用域和垃圾回收机制相互作用的一个现象。

## 四、在平时工作的时候我们如何应用到闭包

为了能够访问一个变量，我们可以直接让这个变量位于的全局作用域中。我们平时工作中还需要直接使用闭包吗？

答案是需要的。**闭包在我们业务开发中最大的作用就是为了隐藏变量！**，尤其在 vue3 hook 写法的时候，闭包出现的场景更加多，而且也足够安全。

### 场景一：结合 ref 实现 vue hook

​**​1. 实现一个带闭包的 Hook​**​

```ts
// useCounter.ts
import { ref } from "vue";

export function useCounter(
  initialValue: number,
  options: { min?: number; max?: number }
) {
  const { min = -Infinity, max = Infinity } = options;

  // 闭包内部的私有状态（通过 ref 转为响应式）
  const count = ref(initialValue);

  // 闭包内部方法（直接操作闭包中的 count）
  const increment = () => {
    if (count.value < max) count.value++;
  };

  const decrement = () => {
    if (count.value > min) count.value--;
  };

  const reset = () => {
    count.value = initialValue;
  };

  // 暴露响应式变量和方法
  return { count, increment, decrement, reset };
}
```

**2. 在组件中使用 Hook**

```vue
<template>
  <div>
    <button @click="decrement">-</button>
    <span>{{ count }}</span>
    <button @click="increment">+</button>
    <button @click="reset">Reset</button>
  </div>
</template>

<script setup>
import { useCounter } from "./useCounter";

// 每次调用 useCounter 会创建一个新的闭包，独立维护 count 状态
const { count, increment, decrement, reset } = useCounter(0, {
  min: 0,
  max: 10,
});
</script>
```

### 场景二：非 ref 本地变量的使用

前端对于接口响应的数据进行缓存：

```ts
export function useCache<T>() {
  // 闭包中缓存计算结果
  let cache: T | null = null;

  const calculate = (data: T) => {
    if (cache !== null) {
      console.log("返回缓存结果");
      return cache;
    }

    console.log("首次请求");
    cache = result as T;
    return result;
  };

  const clearCache = () => {
    cache = null;
  };

  return { calculate, clearCache };
}
```

### **总结 ​**​

在 Vue3 的 Hook 写法中，闭包的核心价值：

1. ​**​ 隔离作用域 ​**​：每个 Hook 实例独立维护状态。
2. ​**​ 封装私有逻辑 ​**​：隐藏内部实现细节，只暴露必要接口。
3. ​**​ 性能优化 ​**​：通过缓存、防抖/节流等模式减少重复计算或操作。

## 五、为什么都说需要谨慎的使用闭包

百度一下，也不知道谁抄的谁，太多一模一样的文章。而我也是长期这么认为的。

![截屏2023-02-07 00.17.30.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85910b12a9fd4aa896b5c787b01cb0c7~tplv-k3u1fbpfcp-watermark.image?)

根据我之前写的闭包的文章，闭包长期存在于 GO 当中，自然可能会占用内存，如果数量过多了，不就导致内存泄漏了么？

看起来挺有道理的，这是因为我不懂啥啥叫[[内存泄漏]]而差产生的误解。所以我上网搜索到了如下的回答：

<img width="500" src='https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9739800df634a3595c75dc227179daa~tplv-k3u1fbpfcp-watermark.image?'/>

<img width="500" src='https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be8aed0b360d41e1a2a13bf144047e04~tplv-k3u1fbpfcp-watermark.image?'/>

也就是说，对于闭包而言，造成内存泄漏的不是闭包本身，而是 IE 浏览器。

也就是说，只要我在使用闭包的时候，只有主要及时的销毁作用域就可以了。拿 vue3 来举例的话，我们平时都是在 tsx 或者在.vue 组件中引入闭包，那么它就会随着这个组件的销毁而销毁，一般来说是不会产生闭包长期存在于 GO 的现象。

所以平时该用就用，不需要顾虑那么多。
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[IIFE]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/IIFE</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/IIFE</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[IIFE JavaScript ; (function test() {   var a = 1,     b = 2     console.log(a + b) })() console.log(test) // test 报错,立即执行函数执行完毕之后马上就进行了销毁. const b = (function(){   return 5 }()) // w3c的规范写法, 但是上面那种在写代码过程更加的常用,只要是容易识别 console.log(b) // 函数表达式才能够使用立即执行函数o function test1() {    console.log(1) }() // 报语法...]]></description>
            <content:encoded><![CDATA[# IIFE

```JavaScript

; (function test() {
  var a = 1,
    b = 2
    console.log(a + b)
})()

console.log(test) // test 报错,立即执行函数执行完毕之后马上就进行了销毁.

const b = (function(){
  return 5
}()) // w3c的规范写法, 但是上面那种在写代码过程更加的常用,只要是容易识别

console.log(b)

// 函数表达式才能够使用立即执行函数o
function test1() {
   console.log(1)
}() // 报语法错误

const c = function test2() {
  console.log(2)
 }()

 +function test3() {
   console.log(3)
 }()

 1 && function test3() {
   console.log(3)
 }()

 undefined || function test3() {
   console.log(3)
 }()
```

就如《JavaScript 忍者秘籍》中对于`IIFE`的描述一样, 函数表达式 + () = 立即函数.

所以有如下:

```JavaScript
const a = 1 + function() {return 3} () // 4
```

**w3c 的推荐写法：**

```JavaScript
(function(){}())
```

别的常用的写法：

```JavaScript
(function(){})()
```

以及在函数前面加上! && || - + 等符号也可以把函数声明变为函数表达式

利用立即执行函数来解决因为闭包产生的相关问题。

如闭包和循环中的图 1 中：

```JavaScript
function test() {
  var arr = []

  for(var i = 0; i < 10; i++) {
    (function(j){
      console.log(j) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
    })(i)
  }

}
```

理解执行函数带来的作用域的问题

```JavaScript
(function fun() {
    fun = 2
    console.log(fun) // [Function fun]
})()

```

> 据说这个的考点不是变量提升
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[JavaScript中运算符优先级]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/JavaScript中运算符优先级</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/JavaScript中运算符优先级</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[- Metadata   - Author:   - Link:   - Publisher   - Date: [[2022-01-06]]   - Status: waiting   - Tag: - content   - JavaScript 中运算符优先级的问题？   - 优先级 是 结合的优先级，不是说谁的优先级高就先给谁求值。   - 结合是什么意思呢？可以理解成是加一个括号     <img src="https://pica.zhimg.com/50/v2-b2c09744a0088336494e8d9400d42065720w.jpg?source=1940ef5c" da...]]></description>
            <content:encoded><![CDATA[- Metadata
  - Author:
  - Link:
  - Publisher
  - Date: [[2022-01-06]]
  - Status: #waiting
  - Tag:
- content

  - JavaScript 中运算符优先级的问题？
  - 优先级 是 结合的优先级，不是说谁的优先级高就先给谁求值。

  - 结合是什么意思呢？可以理解成是加一个括号

    <img src="https://pica.zhimg.com/50/v2-b2c09744a0088336494e8d9400d42065_720w.jpg?source=1940ef5c" data-rawwidth="294" data-rawheight="60" class="content_image" width="294"/>

    上面的这条表达式，在执行的时候，可以看做是下面这样的，加个括号就很容易理解了吧

    <img src="https://pic2.zhimg.com/50/v2-4ec5ec1989d20449e25b0850be0ea68e_720w.jpg?source=1940ef5c" data-rawwidth="313" data-rawheight="57" class="content_image" width="313"/>

  - 可是你不能说加了括号就要先给你求值啊，还是要按照基本法！！！从左往右

  - 这里还有个短路计算的概念， || 操作符左边的是 true 的话，这个表达式的结果就是 true，不管右边的值是 false 还是 true，所以它就不会去求右边的值；&& 正好反过来，详细看文档：

  [ 逻辑运算符 - JavaScript](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Logical_Operators)

  - 如果 fn01() 算出的结果是 true，那整个

    [表达式](https://www.zhihu.com/search?q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A129171248%7D)的结果就是 false，根本不会去求其他的值。

    `false || false && true || true === false || (false && true) || true`

  - 优先级是结合的优先级，不是说谁的优先级高就先给谁求值！！！

  - 再通俗一点，看到谁的优先级高就给它加一个括号，就像这样：
  - `1 + 2 * 3 === 1 + (2 * 3)`

- Metadata
  - Author: RednaxelaFX
  - Link:[(2 条消息) JavaScript 中运算符优先级的问题？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/52116922)
  - Publisher: [[知乎]]
  - Date: [[2022-01-06]]
  - Status: #waiting
  - Tag:
- content

  - 前面的回答都说得挺好了。那我还是来放传送门：
  - [虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩](https://link.zhihu.com/?target=http%3A//rednaxelafx.iteye.com/blog/492667)
  - 题主要注意区分优先级、结合性、
  - [求值顺序](https://www.zhihu.com/search?q=%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A129426603%7D)三者的区别。
  - 这三个是不同的概念，却经常被混淆。通过 AST 来看就很容易理解：（假设源码是从左到右输入的）
  - 所谓优先级，就是不同操作相邻出现时，
  - [AST 节点](https://www.zhihu.com/search?q=AST%E8%8A%82%E7%82%B9&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A129426603%7D)与根的距离的关系。优先级高的操作会更远离根，优先级低的操作会更接近根。为什么？因为整棵 AST 是以后序遍历求值的，显然节点离根越远就越早被求值。
  - 所谓结合性，就是当同类操作相邻出现时，操作的先后顺序同 AST 节点与根的距离的关系。如果是左结合，则先出现的操作对应的 AST 节点比后出现的操作的节点离根更远；换句话说，先出现的节点会是后出现节点的子节点。
  - 所谓求值顺序，就是在遍历子节点时的顺序。对二元运算对应的节点来说，先遍历
  - [左子节点](https://www.zhihu.com/search?q=%E5%B7%A6%E5%AD%90%E8%8A%82%E7%82%B9&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A129426603%7D)再遍历右子节点就是从左到右的求值顺序，反之则是从右到左的求值顺序。
  - 这三个概念与运算的联系都很紧密，但实际描述的是不同的关系。前两者是
  - [解析器](https://www.zhihu.com/search?q=%E8%A7%A3%E6%9E%90%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A129426603%7D)根据语法生成 AST 时就已经决定好的，后者则是解释执行或者生成代码而去遍历 AST 时决定的。
  - 在没有副作用的环境中，给定优先级与结合性，则无论求值顺序是怎样的都能得到同样的结果；而在有副作用的环境中，求值顺序会影响结果。
  - 题主可以看看您的代码对应的 AST 长啥样：
  - [Esprima: Parser](https://link.zhihu.com/?target=http%3A//esprima.org/demo/parse.html)
  - ，对照上面传送门所说的看看。
  - 或者这个：
  - [AST Visualization on browser](https://link.zhihu.com/?target=http%3A//nhiro.org/learn_language/AST-Visualization-on-browser.html)
  - 对应 console.log(fn01() || fn02() && fn03())，AST 是：
  - 具体到题主有疑问的那个地方，AST 是这样的：` || / \ fn01() && / \ fn02() fn03()`
  - 表达式层面上，代码的执行就是后序遍历这棵 AST 而已。
  - 优先级：在相邻的两个运算符 || 与 && 中，&& 比 || 离 AST 的根更远所以优先级更高
  - 结合性：这里没有相邻的同优先级运算符所以展现不出 || 与 && 的结合性，虽然它们都是左结合的
  - 求值顺序：JavaScript 的求值顺序就是从左向右的。对这棵 AST 来说就是在后序遍历时，每个节点的求值过程是先遍历左子树，再遍历右子树，然后对自己求值。
  - 外加 || 与 && 的短路求值语义，如果左操作数已经足以求出结果则不会对右操作数求值
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[generator和iterator]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/generator和iterator</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/JavaScriptCore/generator和iterator</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[generator 和 iterator  前言 最近重新现在看红宝书，总算知道为什么迭代器和生成器这两个概念为什么那么难理解了，根本原因是平时直接使用到的机会确实是非常的少，其次就是书上面为了介绍这两个概念使用了非常多的专业的名词来描述，而且相互穿插，能把人看睡着了都。下面简单的描述一下书中的介绍这两个概念的思路。  迭代器导读 在迭代器中，先介绍了迭代，在 ES6 之前 for 和 forEach 两个循环的问题，引出了迭代器模式。接下来就自然的介绍迭代器模式，它包含两个概念： 1. 第一个是可迭代协议，介绍了它具备的能力，以及实现它的必要条件，最后介绍了当前内置的类型都有那些实现了这个可...]]></description>
            <content:encoded><![CDATA[# generator 和 iterator

## 前言

最近重新现在看红宝书，总算知道为什么迭代器和生成器这两个概念为什么那么难理解了，根本原因是平时直接使用到的机会确实是非常的少，其次就是书上面为了介绍这两个概念使用了非常多的专业的名词来描述，而且相互穿插，能把人看睡着了都。下面简单的描述一下书中的介绍这两个概念的思路。

### 迭代器导读

在迭代器中，先介绍了迭代，在 ES6 之前 for 和 forEach 两个循环的问题，引出了迭代器模式。接下来就自然的介绍迭代器模式，它包含两个概念：

1. 第一个是可迭代协议，介绍了它具备的能力，以及实现它的必要条件，最后介绍了当前内置的类型都有那些实现了这个可迭代协议，并且可以接受这些内置类型的原生语言特使包括那些。
2. 第二个是迭代器协议，介绍了它的基本概念和基本使用方法。了解了了迭代器的协议之后，也可以称呼它们为迭代器的接口，就介绍了自定义迭代器如何实现和一些细则。

但是关于两个协议的关系和职责范围没有总结出来，导致了我对于他们的关系一直很模糊，经常混淆在一起。总结一下：

| **协议类型 ​**​    | ​**​ 可迭代协议（Iterable Protocol）​**​        | ​**​ 迭代器协议（Iterator Protocol）​**​   |
| ------------------ | ----------------------------------------------- | ------------------------------------------ |
| ​**​ 目的 ​**​     | 定义对象如何被迭代（如 `for...of` 遍历）        | 定义如何按顺序访问元素（如 `next()` 方法） |
| ​**​ 实现方法 ​**​ | 对象需实现 `[Symbol.iterator]()` 方法           | 对象需实现 `next()` 方法                   |
| ​**​ 返回值 ​**​   | 返回一个 ​**​ 迭代器对象 ​**​（符合迭代器协议） | 返回 `{ value: T, done: boolean }` 对象    |
| ​**​ 核心作用 ​**​ | ​**​ 声明对象可被迭代 ​**​                      | ​**​ 实际执行迭代过程 ​**​                 |

### 生成器导读

在生成器中，先介绍了生成器的写法，包含的元素和生命周期，存在暂停状态，存在`next()`方法，该方法返回的对象也是包含 done 属性和 value 属性。接下来介绍生成器最重要的组成部分：`yield`，被称为生成器最有用的地方。包括如下内容：

1. 中断执行，异步变为同步的关键
2.

**生成器和迭代器的关系如下**：

生成器是一种特殊的函数结构，它返回的对象是一个迭代器。生成器函数本质上是 JavaScript 语法规范提供的一种**用户自定义的迭代器工厂函数**。

> 生成器（Generator）**不是基于 ES5 的语法糖**，而是 **ES6（ECMAScript 2015）引入的基础语言规范**，需要 JavaScript 引擎在底层实现支持。

## 资料

- [(1 封私信 / 9 条消息) es6 generator 到底有什么用？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/55810122/answer/1988210728)
- [Rx.js 思想入门（讲义） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/34481617)
  - generator 是 ES 对迭代器的实现，迭代器源于设计模式。(这个事关 generator 怎么来的)，我们想知道 generator 有什么的本质其实是了解迭代器有什么作用。

# generator 和 iterator

![[截屏2022-01-30 02.22.26.png]]
这句感觉啥都没有说. 怎么写法就复杂了,怎么就枯燥了. 复杂体现在哪里?枯燥体现在哪里?如何手抖产生 bug 的.现在的人出教程都这么随意的么?

这个例子出自于《JavaScript 高级程序设计》第五版，是为了说明在迭代器这个规范出来之前 ES 处理迭代的一个历史，有两个阶段，一个如图中使用到 for 循环，另外一个就是 forEach 更加函数式的写法。

for 循环的凡事得出的结论也不是图中的两点，而是：

1. 迭代之前需要事先知道如何使用数据结构。
2. 遍历顺序并不是数据结构固有的。

## 1.总结一下在此之前的 7 组遍历的方法

- forEach -> 普通的数组遍历
- map -> 映射, 每一次遍历,返回 bool.来决定当前元素是否纳入新的数组
- filter -> 过滤, 每一次遍历,返回 bool,来决定当前元素是否纳入新的数组
- reduce -> 归纳, 每一次遍历,将挡元素收归到容器中
- reduceRight -> reduce 的反向操作
- every -> 判定是否所有元素都符合一个条件
- some -> 判定是否有某一个或多个符合一个条件

> async 是 Generator 的语法糖，在 Generator 基础上封装的

## 2. 手写 iterator

```js
const arr = ["姓名: 小野", "年龄: 28", "爱好: 我爱JavaScript"];
function getIterator(arr) {
  let i = 0;
  return {
    next() {
      return {
        value: arr[i++],
        done: i > arr.length,
      };
    },
  };
}

const iterator = getIterator(arr);
console.log(iterator.next()); // {value: 姓名: 小野, done: false}
console.log(iterator.next()); // {value: 年龄: 28, done: false}
console.log(iterator.next()); // {value: 爱好: 我爱JavaScript, done: false}
console.log(iterator.next()); // {value: undefined, done: true}
```

## 3. ES6 提供的 Generator 方法

```js
function* createIterator(arr) {
  for (let i = 0; i < arr.length; i++) {
    yield arr[i];
  }
}

const iterator1 = createIterator(arr);
console.log(iterator.next()); // {value: 姓名: 小野, done: false}
console.log(iterator.next()); // {value: 年龄: 28, done: false}
console.log(iterator.next()); // {value: 爱好: 我爱JavaScript, done: false}
console.log(iterator.next()); // {value: undefined, done: true}
```

**基本构成就是\* 加上 yield.**

## 4. Generator 实现 async 的写法

大佬写的文章还是不错的 https://juejin.cn/post/6844903599529541645
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
        <item>
            <title><![CDATA[Java 学习路线-前端功利性]]></title>
            <link>https://wyc7758775.github.io/yoran-secret//posts/Java/Java 学习路线-前端功利性</link>
            <guid isPermaLink="false">https://wyc7758775.github.io/yoran-secret//posts/Java/Java 学习路线-前端功利性</guid>
            <pubDate>Mon, 25 Aug 2025 15:59:54 GMT</pubDate>
            <description><![CDATA[Java 学习路线-前端功利性  符号表 可以通过路线知识点前的表情字符，根据自己的实际情况选择学习： - 🌕 必须学习！！！ - 🌖 非常急着找工作，才可不学；目标大厂，必须学习！ - 🌗 急着找工作的话，可不学；目标大厂，建议学习 - 🌘 时间充足的话，再去学 - ⭐ 表示推荐资源  前言 首先呢，我们要了解 Java 的应用场景和就业方向，看看和自己的学习目的是否一致。 目前，Java 由于其优秀的特性以及火爆的生态，岗位需求量大，是后台开发、安卓开发、大数据开发的主流编程语言，因此学习资源也很丰富，值得学习！  阶段 1：编程语言基础  目标 培养兴趣、快速上手，能运行和编写简...]]></description>
            <content:encoded><![CDATA[# Java 学习路线-前端功利性

## 符号表

可以通过路线知识点前的表情字符，根据自己的实际情况选择学习：

- 🌕 必须学习！！！
- 🌖 非常急着找工作，才可不学；目标大厂，必须学习！
- 🌗 急着找工作的话，可不学；目标大厂，建议学习
- 🌘 时间充足的话，再去学
- ⭐ 表示推荐资源

## 前言

首先呢，我们要了解 Java 的应用场景和就业方向，看看和自己的学习目的是否一致。

目前，Java 由于其优秀的特性以及火爆的生态，岗位需求量大，是后台开发、安卓开发、大数据开发的主流编程语言，因此学习资源也很丰富，值得学习！

## 阶段 1：编程语言基础

### 目标

培养兴趣、快速上手，能运行和编写简单的 Java 程序。

学完本阶段后，可以试着用 Java 解决一些数学计算问题、编写图书管理系统等桌面端 GUI 程序，甚至是五子棋之类的小游戏。

### 🌕 Java 编程基础（45 天）

#### 知识

- Java 特点（看不懂没事，别背！）
- 环境搭建
- IDEA 开发工具
  - 新建项目
  - 运行调试
  - 界面配置
  - 插件管理
- **Java 基础语法**
  - 数据类型
  - 流程控制
- 数组
- **面向对象**
  - 方法
  - 重载
  - 封装
  - 继承
  - 多态
- 抽象类
- 接口
- 枚举
- 常用类
  - String
  - 日期时间
- 集合类
- 泛型
- 注解
- 异常处理
- 多线程
- IO 流
- 反射

#### 学习建议

<font style="background-color:#FBDE28;">1）坚持：初学一门语言时，一定要持续学习，不能中断！</font>

2）实践：想要学好编程，一定要多敲代码！建议先跟着书上的例子敲一遍代码，然后试着自主编写代码，并完成课后练习。

3）万事开头难：不理解代码也没关系，可以学习 Debug 后，一行一行地打断点执行，查看程序的执行过程。千万不要觉得麻烦，养成习惯后真的能节省很多重复学习的时间。

#### 经典面试题

1. 为什么重写 equals 还要重写 hashcode？
2. == 和 equals 比较的区别
3. 为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？
4. final 关键字的作用
5. 介绍 Java 的集合类
6. ArrayList 和 LinkedList 的区别

#### 资源

- 视频
  - ⭐ 韩顺平 - 零基础 30 天学会 Java：[https://www.bilibili.com/video/BV1fh411y7R8](https://www.bilibili.com/video/BV1fh411y7R8) （900 多集，顺序安排很合理，每个知识真正的打碎了，通俗、有示例、有实战、有思想）
- 文档
  - ⭐ 菜鸟教程：[https://www.runoob.com/java/java-tutorial.html](https://www.runoob.com/java/java-tutorial.html) （可以在线练习）
  - 廖雪峰 Java 教程：[https://www.liaoxuefeng.com/wiki/1252599548343744](https://www.liaoxuefeng.com/wiki/1252599548343744)
  - IDEA 中文教程：[https://github.com/judasn/IntelliJ-IDEA-Tutorial](https://github.com/judasn/IntelliJ-IDEA-Tutorial) （可以作为课外书来看）
  - IDEA Mac 快捷键指南，地址：[https://www.jianshu.com/p/454c71172c46](https://www.jianshu.com/p/454c71172c46)
  - IDEA Win 常用快捷键，地址：[https://www.jianshu.com/p/5de7cca0fefc](https://www.jianshu.com/p/5de7cca0fefc)
- 书籍
  - 《Head First Java》
- 在线游戏
  - Codegym：[https://codegym.cc/zh](https://codegym.cc/zh) （玩玩前几关培养兴趣不错，但后面收费了，不太建议用）

### 🌖 Java 8（3 天）

#### 知识

- Stream API
- Lambda 表达式
- 新日期时间 API
- 接口默认方法

#### 学习建议

Java 8 是如今企业开发中最主流的 Java 稳定版本，在这个版本出现了很多实用的新特性，虽然面试考点不多，但能够提升编程效率，建议学习。

此外，很多同学不怎么在简历上写自己会 Java 8，因此如果你把 Java 8 的知识点写在简历上，会大大加分的。

#### 经典面试题

1. Java 8 有哪些新特性？
2. HashMap 在 jdk 1.7 和 1.8 的区别？

#### 资源

- 视频
  - ⭐ 宋红康 - 全网最全 Java 零基础入门教程：[https://www.bilibili.com/video/BV1Kb411W75N](https://www.bilibili.com/video/BV1Kb411W75N) （只看 Java 8 部分即可）
- 文档
  - ⭐ 菜鸟教程：[https://www.runoob.com/java/java8-new-features.html](https://www.runoob.com/java/java8-new-features.html)
- 书籍
  - 《Java 8 实战》：[https://book.douban.com/subject/26772632/](https://book.douban.com/subject/26772632/)
- 工具
  - ⭐ 在线编写运行  Java 8：[https://www.tutorialspoint.com/compile_java8_online.php](https://www.tutorialspoint.com/compile_java8_online.php)
- 其他
  - Java 8 小代码片段：[https://github.com/biezhi/30-seconds-of-java8](https://github.com/biezhi/30-seconds-of-java8)

### 练手项目

- Java 实现简单计算器：[https://www.lanqiao.cn/courses/185](https://www.lanqiao.cn/courses/185)
- Eclipse 实现 Java 编辑器：[https://www.lanqiao.cn/courses/287](https://www.lanqiao.cn/courses/287)
- 一本糊涂账：[https://how2j.cn/module/104.html](https://how2j.cn/module/104.html)
- Java 五子棋：[https://blog.csdn.net/cnlht/article/details/8176130](https://blog.csdn.net/cnlht/article/details/8176130)
- Java 中国象棋：[https://blog.csdn.net/cnlht/article/details/8205733](https://blog.csdn.net/cnlht/article/details/8205733)
- JAVA GUI 图书馆管理系统：[https://github.com/uboger/LibraryManager](https://github.com/uboger/LibraryManager)
- JAVA 坦克大战小游戏：[https://github.com/wangzhengyi/TankWar](https://github.com/wangzhengyi/TankWar)
- Swing 编写的俄罗斯方块：[https://github.com/HelloClyde/Tetris-Swing](https://github.com/HelloClyde/Tetris-Swing)
- 小小记账本：[https://github.com/xenv/SmallAccount](https://github.com/xenv/SmallAccount) （适合了解数据库的同学）

### 尾声

学完了 Java 基础后，有些同学会感到迷茫了啊，感觉好像啥也做不出来，不知道下一步做什么，我这一身的本领该如何施展啊？

不要慌，也不要急着去学新技术，接下来我们要多用 Java 来写代码了，巩固基础，但是写什么呢？

当然是数据结构和算法！

## 阶段 2：巩固基础

注意！如果你时间不够（比如只有 6 个月左右），只是想快速找到工作，那么本章节甚至可以完全跳过，先去学习开发框架做项目，后面再慢慢弥补基础即可。

### 目标

想学好编程，计算机基础知识要学好。

比如算法，是程序员的灵魂。学好算法有助于我们理解程序、开拓思路，因此也是很多公司面试时考察的关键，在找工作前，还是要刷个上百道算法题目的。

我们这个阶段的目标是：熟练使用 Java 语言来编写程序，巩固 Java 基础。（那直接用 Java 来写算法题目，一举两得，岂不美哉？）

此外，建议大家利用零碎时间多去了解 **计算机基础知识** ，比如操作系统、计算机网络等，对你后面学习开发框架之类的知识都有帮助。

### Java 基础（30 天）

#### 学习建议

建议大家去阅读 《Java 核心技术卷 1》，这本书堪称经典，是帮助你复习巩固  Java 的不二之选，其中图形界面章节可以选择不看。

之后可以刷网上免费的 Java 练习题，检验自己的水平，我当时刷了两遍 1000 题（每天 30 题，1 个月也就刷完了，二刷会更快！）。虽然都是选择题，但能学到很多 Java 语言的特性、避免写代码时容易犯的错误。

#### 资源

- 书籍
  - ⭐《Java 核心技术卷 1》：[https://www.aliyundrive.com/s/SNdB6gr1Xz4](https://www.aliyundrive.com/s/SNdB6gr1Xz4) 提取码: u74e

### 🌖 数据结构与算法

请参考学习路线：[数据结构和算法学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789191067892948993?type=)

### 🌘 计算机导论

详情请参考：[计算机基础学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789191099081793538?type=)

#### 知识

- 计算机发展历史
- 计算机应用领域
- 计算机发展方向
- 计算机基本组成
- 二进制
- 编程语言发展

#### 学习建议

大学计算机专业的同学一般刚开学就会上这门课，虽说学习它并不会直接提高你的编程技能，但能够让你更了解计算机和编程，从而在一定程度上帮助你培养学习兴趣、确定学习方向。

自学的话，不用刻意去学习计算机导论，而是可以通过看视频、阅读课外读物的方式慢慢地了解计算机的故事。

#### 资源

- 视频
  - 《计算机科学速成课》：[https://www.bilibili.com/video/BV1EW411u7th](https://www.bilibili.com/video/BV1EW411u7th) （从底层到上层的计算机知识科普，强烈推荐）
- 书籍
  - 《半小时漫画计算机》：[https://book.douban.com/subject/35619441/](https://book.douban.com/subject/35619441/)

### 🌖 操作系统

详情请参考学习路线：[操作系统学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789190984099143681?type=)

#### 知识

- 操作系统的组成
- 进程、线程
- 进程 / 线程间通讯方式
- 进程调度算法
- 进程 / 线程同步方式
- 进程 / 线程状态
- 死锁
- 内存管理
- 局部性原理

#### 学习建议

说实话，操作系统这一块知识挺枯燥的。你说说我现在项目都不会做，你又让我看这些理论，是不是想让我头秃？

我的建议是，可以先利用课余时间看一些网课或者有趣的课外书，对一些操作系统的概念先有个大致的印象，比如进程、线程、死锁，等后面有时间了再系统学习、等到找工作了再去背相关八股文。

还在校园就跟着学校的进度学习就成，自学的话可以看下《清华操作系统原理》视频，有实力的小伙伴，能看懂大黑书就更好了，但如果看不懂也别担心，这并不影响你后续知识的学习。

#### 经典面试题

1. 什么是死锁？死锁产生的条件？
2. 线程有哪几种状态？
3. 有哪些进程调度算法？
4. 什么是缓冲区溢出？

#### 资源

- 视频
  - 《清华操作系统原理》：[https://www.bilibili.com/video/BV1uW411f72n](https://www.bilibili.com/video/BV1uW411f72n)
- 书籍
  - 《编码》
  - 《30 天自制操作系统》
  - 《现代操作系统》（难度较大，不推荐新手看）
  - 《深入理解计算机系统》（难度较大，不推荐新手看）
  - 《 自己动手写操作系统》（国产好书，网上可以下载）
- 大学课件
  - 浙大操作系统：[https://github.com/QSCTech/zju-icicles](https://github.com/QSCTech/zju-icicles)

### 🌖 计算机网络

详情请参考学习路线：[计算机网络学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789191030769164289?type=)

#### 知识

- 网络分层模型
- 网络传输过程
- IP、端口
- HTTP / HTTPS 协议
- UDP / TCP 协议
- ARP 地址解析协议
- 网络安全
- DNS 域名解析

#### 学习建议

很多学习 Java 开发的同学最后都是从事 **后端开发** 的工作，而计算机网络知识是后端开发的重点。

和操作系统一样，自学网络可能会很枯燥，建议先看有趣的课外书，比如《图解 HTTP》；或者有趣的视频，比如《计算机网络微课堂》。后面要找工作面试前，再重点去背一些八股文就好了。还在学校的同学好好上课一般就没问题。

学习基础能帮助自己今后发展更稳定，且更容易接受新知识，所以请不要相信基础无用论。

#### 经典面试题

1. 计算机网络各层有哪些协议？
2. TCP 和 UDP 协议的区别？
3. TCP 为什么需要三次握手和四次挥手？
4. HTTP 和 HTTPS 协议的区别？

#### 资源

- 视频
  - 《计算机网络微课堂》：[https://www.bilibili.com/video/BV1c4411d7jb](https://www.bilibili.com/video/BV1c4411d7jb)
- 书籍
  - ⭐《图解 HTTP》
  - 《网络是怎样连接的》
  - ⭐《图解 TCP / IP》
- 大学课件
  - 浙大计算机网络基础：[https://github.com/QSCTech/zju-icicles](https://github.com/QSCTech/zju-icicles)

### 尾声

巩固基础要花至少 1 个月的时间，当你读完《Java 核心技术卷 1》并且不用查询文档也能熟练地用 Java 做题时，就可以接着往下了。

## 阶段 3：企业开发基础

### 目标

面向薪资编程，学习实际后台开发工作要用的基础技术和框架，并能 **独立** 做出一个具有完整功能的 Java Web 项目。

学完这个阶段后，你应该已经能独立开发出大多数常见的后台系统了，比如各种管理系统、商城系统等。

### 🌕 MySQL 数据库（7 天）

详情请参考学习路线：[数据库学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789190581420793858?type=)

企业中大部分业务数据都是用关系型数据库存储的，因此数据库是后台开发同学的必备技能，其中 MySQL 数据库是目前的主流，也是面试时的重点。

#### 知识

- 基本概念
- MySQL 搭建
- SQL 语句编写
- 约束
- 索引
- 事务
- 锁机制
- 设计数据库表
- 性能优化

#### 学习建议

其中，**SQL 语句编写** 和 **设计数据库表** 这两个能力一定要有！

比如让你做一个学生管理系统，你要能想到需要哪些表，比如学生表、班级表；每个表需要哪些字段、字段类型。

这就要求大家多写 SQL、多根据实际的业务场景去练习设计能力。

#### 经典面试题

1. MySQL 索引的最左原则
2. InnoDB 和 MyIsam 引擎的区别？
3. 有哪些优化数据库性能的方法？
4. 如何定位慢查询？
5. MySQL 支持行锁还是表锁？分别有哪些优缺点？

#### 资源

- 视频
  - ⭐ 2022 黑马 MySQL 教程：[https://www.bilibili.com/video/BV1Kr4y1i7ru](https://www.bilibili.com/video/BV1Kr4y1i7ru)（倾向于速成，初学只看完 P57 节前的基础篇即可，后面可以再来补进阶知识）
  - 老杜 - mysql 入门基础 + 数据库实战：[https://www.bilibili.com/video/BV1Vy4y1z7EX](https://www.bilibili.com/video/BV1Vy4y1z7EX) （内容相对精炼，有习题）
  - 尚硅谷 - MySQL 基础教程：[https://www.bilibili.com/video/BV1xW411u7ax](https://www.bilibili.com/video/BV1xW411u7ax) （小姐姐讲课，但感觉音质一般）
- 在线练习
  - ⭐ 鱼皮的闯关式 SQL 自学网：[http://sqlmother.yupi.icu/](http://sqlmother.yupi.icu/)
  - ⭐ SQL 在线运行：[https://www.bejson.com/runcode/sql/](https://www.bejson.com/runcode/sql/)
- 文档
  - SQL - 菜鸟教程：[https://www.runoob.com/sql/sql-tutorial.html](https://www.runoob.com/sql/sql-tutorial.html)
  - MySQL - 菜鸟教程：[https://www.runoob.com/mysql/mysql-tutorial.html](https://www.runoob.com/mysql/mysql-tutorial.html)
- 网站
  - [数据库大全](https://www.codefather.cn/rd/?rid=b00064a76012546b016e274a3724c5f0)：果创云收录的各种数据库表设计

### 🌕 开发框架（60 天）

Java 之所以能成为主流的企业开发语言，很大一部分原因是它完善的框架生态，用好框架，不仅能够大大提升开发效率，还能提高项目的稳定性、减少维护成本。

开发框架是后台开发工作中不可或缺的，也是面试考察的重点，一定要好好学！

不知道 Java 能做什么的朋友们，学完开发框架，就会有答案啦。

下面给大家推荐的都是企业中应用最多的主流开发框架，知识点比较零碎，就放在一起讲了。

#### 知识

##### 🌕 Java Web

- 描述：Java 网页应用开发基础
- 一丢丢前端基础
- XML
- JSON
- Servlet
- Filter
- Listener
- JSP
- JSTL
- Cookie
- Session

##### 🌕 Spring 5

- 描述：Java 轻量级应用框架
- IOC
- AOP
- 事务

##### 🌕 SpringMVC

- 描述：Java 轻量级 web 开发框架
- 什么是 MVC？
- 请求与响应
- Restful API
- 拦截器
- 配置
- 执行过程

##### 🌕 MyBatis

- 描述：数据访问框架，操作数据库进行增删改查等操作
- 增删改查
- 全局配置
- 动态 SQL
- 缓存
- 和其他框架的整合
- 逆向工程

##### 🌗 MyBatis Plus

- 描述：Mybatis 的增强工具，能够简化开发、提高效率
- 引入
- 通用 CRUD
- 条件构造器
- 代码生成器
- 插件扩展
- 自定义全局操作

##### 🌕 SpringBoot 2

- 描述：简化 Spring 应用的初始搭建以及开发过程，提高效率
- 常用注解
- 资源整合
- 高级特性
- 本地热部署

##### 🌗 Spring Security

- 描述：Spring 的安全管理框架
- 用户认证
- 权限管理
- 相关技术：Shiro

##### 🌗 Maven / Gradle

- 描述：项目管理工具
- 构建
- 依赖管理
- 插件
- 配置
- 子父工程
- 多模块打包构建
- Nexus 私服搭建

#### 学习建议

由于技术较多，且框架之间存在一定的联系，因此建议大家看同一系列的视频教程（尚硅谷、狂神说等等都可以），以保证学习内容的连续以及体验上的一致。

学这些技术的时候，**千万不能懒** ！一定要多记笔记，并且跟着老师写代码。原理部分不要太过纠结，先以能跟着敲出代码、写出可运行的项目为主，有些东西做出来也能帮助你更好地理解理论。

学习顺序挺重要的，建议按我推荐的顺序学，不要一上手就学 Spring Boot。只有先学习下自己整合框架的方法，才能帮你理解 SpringBoot 解决的问题，感受到它的方便和高效。

Maven / Gradle 当成工具用就好，面试基本不问，跟着框架教程去用就行了，急着找工作的话，先不用花太多时间去深入学。大厂面试问这个的也不多。

#### 经典面试题

1. Spring 的 IOC 和 AOP 是什么，有哪些优点？
2. Spring 框架用到了哪些设计模式？
3. 介绍 Spring Bean 的生命周期
4. MyBatis 如何实现延迟加载？
5. 介绍 MyBatis 的多级缓存机制

#### 资源

已下资源分为两大类，希望快速做出项目、快速就业的同学请看【速成视频】。

- 速成视频（按顺序看，同类视频任意选择 1 个即可）
  - ⭐ 2023 黑马 JavaWeb：[https://www.bilibili.com/video/BV1m84y1w7Tb](https://www.bilibili.com/video/BV1m84y1w7Tb)（包含了前端、MySQL 数据库、Java Web、MyBatis、Spring MVC、Spring、Spring Boot、Maven 等知识）
  - 2022 尚硅谷 SSM + MyBatis Plus 整合学习：[https://www.bilibili.com/video/BV1Ya411S7aT](https://www.bilibili.com/video/BV1Ya411S7aT)
  - 2022 黑马 SSM + MyBatis Plus 整合学习：[https://www.bilibili.com/video/BV1Fi4y1S7ix](https://www.bilibili.com/video/BV1Fi4y1S7ix)
  - 黑马 Spring Boot 2：[https://www.bilibili.com/video/BV15b4y1a7yG](https://www.bilibili.com/video/BV15b4y1a7yG)（较新）
  - 尚硅谷 Spring Boot 2：[https://www.bilibili.com/video/BV19K4y1L7MT](https://www.bilibili.com/video/BV19K4y1L7MT)
- 非速成视频（按顺序看）
  - ⭐ 尚硅谷 JavaWeb 全套教程：[https://www.bilibili.com/video/BV1Y7411K7zz](https://www.bilibili.com/video/BV1Y7411K7zz) （前端部分最好也看下）
  - ⭐ 尚硅谷 - Spring 5 框架最新版教程（idea 版）：[https://www.bilibili.com/video/BV1Vf4y127N5](https://www.bilibili.com/video/BV1Vf4y127N5)
  - ⭐ 尚硅谷 - SpringMVC 2021 最新教程：[https://www.bilibili.com/video/BV1Ry4y1574R](https://www.bilibili.com/video/BV1Ry4y1574R)
  - ⭐ 尚硅谷 - MyBatis 实战教程全套完整版：[https://www.bilibili.com/video/BV1mW411M737](https://www.bilibili.com/video/BV1mW411M737)
  - ⭐ 尚硅谷 - MyBatisPlus 教程：[https://www.bilibili.com/video/BV1Ds411E76Y](https://www.bilibili.com/video/BV1Ds411E76Y)
  - Maven 零基础入门教程：[https://www.bilibili.com/video/BV1TW411g7hP](https://www.bilibili.com/video/BV1TW411g7hP) （搞不懂 Maven 可以看看）
  - ⭐ 雷丰阳 2021 版 SpringBoot2 零基础入门：[https://www.bilibili.com/video/BV19K4y1L7MT](https://www.bilibili.com/video/BV19K4y1L7MT)
  - 尚硅谷 - SpringSecurity 框架教程：[https://www.bilibili.com/video/BV15a411A7kP](https://www.bilibili.com/video/BV15a411A7kP)

学习完框架后，即可跟着鱼皮的原创项目教程系列边学边做项目。用项目驱动学习，更快地掌握后端必学技术，并直接写在简历上：[项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 。

### 🌘 开发规范（3 天）

开发不规范，同事两行泪。

开发规范是团队开发中必须遵守的，有利于提高项目的开发效率、降低维护成本。

#### 知识

- 代码规范
  - 代码风格
  - 命名
  - 其他规则
- 代码校验（CheckStyle）
- 提交规范

#### 学习建议

有时间的话，简单过一遍大厂团队的代码规范手册就好了，以后做项目的时候能想起来的话就去使用，或者从书中、网上查规范文档，再去遵守。

项目做得多了，自然会养成好的习惯，不用刻意去记（毕竟每个团队规范也不完全相同，背了也没用）。也可以直接利用开发工具自带的一些代码检查插件，帮忙养成好的编码习惯。

#### 资源

- 书籍
  - ⭐ 阿里巴巴 Java 开发手册：[https://developer.aliyun.com/graph/java](https://developer.aliyun.com/graph/java) （搜索《Java 开发手册》）
- 视频
  - 华山版《Java 开发手册》独家讲解：[https://developer.aliyun.com/live/1201](https://developer.aliyun.com/live/1201)
- 文档
  - Google Java Style Guide：[https://google.github.io/styleguide/javaguide.html](https://google.github.io/styleguide/javaguide.html) （谷歌 Java 代码规范）

### 🌕 Git（3 天）

详情请参考学习路线：[Git & GitHub 学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789190804671012866?type=)

此前大家可能听说过 GitHub，一流的代码开源托管平台。

Git 和它可不一样，是一个版本控制工具，可以更好地管理和共享项目代码，比如把自己的代码传到 GitHub 上、或者从远程下载。

无论自己做项目、还是团队开发，Git 都是现在不可或缺的神器。

#### 知识

- 区分 Git 和 GitHub
- 工作区
- 分支
- 代码提交、推送、拉取、回退、重置
- 分支操作
- 代码合并、解决冲突
- 标签
- cherry-pick
- Git Flow
- 相关技术：SVN（比较老）

#### 学习建议

每个命令跟着敲一遍，有个大致的印象，会用即可。

建议平时大家可以多把自己的代码使用 Git 命令上传到 GitHub 上，用的多了自然就熟悉了。

#### 经典面试题

1. 如何解决提交冲突？
2. 提交不小心出现误操作，如何撤销？
3. 什么是 Git Flow，它有什么好处？

#### 资源

- 视频
  - ⭐【尚硅谷】5h 打通 Git 全套教程丨 2021 最新 IDEA 版 [https://www.bilibili.com/video/BV1vy4y1s7k6](https://www.bilibili.com/video/BV1vy4y1s7k6)
- 书籍
  - 猴子都能懂的 Git 入门 [https://backlog.com/git-tutorial/cn/](https://backlog.com/git-tutorial/cn/)
  - ⭐ GitHub 漫游指南 [https://github.phodal.com/](https://github.phodal.com/)
- 文档
  - GitHub 官方文档：[https://docs.github.com/cn](https://docs.github.com/cn)
- 游戏
  - Learning Git Branching：[https://learngitbranching.js.org/?locale=zh_CN](https://learngitbranching.js.org/?locale=zh_CN)

### 🌖 Linux（10 天）

详情请参考学习路线：[Linux 学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789190769740849154?type=)

企业中的很多前后台项目都是部署在 Linux 服务器上的，因此很有必要熟悉 Linux 的操作和脚本的编写。

后面学微服务、学架构都是在多台服务器操作，如果你不熟悉 Linux，会有点吃力。

#### 知识

- Linux 系统安装
- 环境变量
- 文件管理
- 用户管理
- 内存管理
- 磁盘管理
- 进程管理
- 网络管理
- 软件包管理
- 服务管理
- 日志管理
- Linux 内核
- **常用命令**
- **常用环境搭建**
- **Shell 脚本编程**
- **VIM 的使用**

#### 学习建议

多动手实践，建议自己购买一台云服务器，并且在本地搭建 Linux 虚拟机环境。

一定要自己从 0 开始手敲命令安装软件、部署服务，熟悉整个项目的上线流程。

每个命令至少要跟着敲一遍，了解它们的作用，并通过自然地练习，熟悉常用的 Linux 命令。

记不住没关系，用文档查就行了。

先会用，再理解。一般面试问的 Linux 题目也不会很难，面试前去背一下八股文就没什么问题，感兴趣的话可以去看看 Linux 内核设计。

#### 经典面试题

1. 如何查看某个进程的运行状态？
2. 如何在 Linux 上查看 2 G 的大文件？
3. Linux 软链接和硬链接的区别

#### 资源

- 视频
  - ⭐ 2021 韩顺平 一周学会 Linux [https://www.bilibili.com/video/BV1Sv411r7vd](https://www.bilibili.com/video/BV1Sv411r7vd) （基于 CentOS 7.6 版本较新）
- 书籍
  - 《鸟哥的 Linux 私房菜 —— 基础篇》[http://cn.linux.vbird.org/linux_basic/linux_basic.php](http://cn.linux.vbird.org/linux_basic/linux_basic.php) （经典）
- 文档
  - Linux 工具快速教程：[https://linuxtools-rst.readthedocs.io](https://linuxtools-rst.readthedocs.io) （基础、工具进阶、工具参考）
- 实战
  - ⭐ 蓝桥云课 Linux 基础入门：[https://www.lanqiao.cn/courses/1](https://www.lanqiao.cn/courses/1)
  - 腾讯云动手实验室：[https://cloud.tencent.com/developer/labs](https://cloud.tencent.com/developer/labs)
  - 阿里云体验实验室：[https://developer.aliyun.com/adc/labs/](https://developer.aliyun.com/adc/labs/)
  - 阿里云知行实验室：[https://start.aliyun.com/](https://start.aliyun.com/)
  - 华为云沙箱实验室：[https://lab.huaweicloud.com/](https://lab.huaweicloud.com/)
- 社区
  - Linux 中国：[https://linux.cn/](https://linux.cn/)
- 工具
  - ⭐ Linux 命令搜索：[https://wangchujiang.com/linux-command](https://wangchujiang.com/linux-command)
  - Linux 命令大全手册：[https://www.linuxcool.com/](https://www.linuxcool.com/)
  - Linux 命令示例：[http://linux-commands-examples.com/](http://linux-commands-examples.com/)
  - 宝塔 Linux 面板：[https://www.bt.cn/](https://www.bt.cn/)

### 🌘 前端基础（14 天）

详情请参考鱼皮原创的前端学习路线：[https://mp.weixin.qq.com/s/HbzLEt6NOP9Is9F3GOnbUQ](https://mp.weixin.qq.com/s/HbzLEt6NOP9Is9F3GOnbUQ)

虽然 Java 程序员面试时基本不会出现前端相关问题，但是在企业中，往往需要前后端程序员配合完成工作。会一些前端，不仅可以提高你们的协作效率，还能提高自己对整个项目的了解和掌控力，甚至能独立开发出一个完整项目！这点也是能给面试加分的。

#### 知识

- HTML
- CSS
- JavaScript
  - Ajax
- Vue

#### 学习建议

不需要学习太多的前端技术，熟悉下基础的前端三件套，了解前端是如何向后端发送请求来做数据交互的一般就够了。有时间的话可以学下 Vue ，是比较容易上手的主流前端开发框架，Vue + SpringBoot 还是很香的。

### 练手项目

推荐跟着鱼皮的原创项目教程系列边学边做项目，每个项目都是前端 + 后端的全栈项目。用项目驱动学习，更快掌握前端基础和后端必学技术，并直接写在简历上：[项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 。

- HotelSystem：[https://github.com/misterchaos/HotelSystem](https://github.com/misterchaos/HotelSystem) （酒店管理系统 Java,tomcat,mysql,servlet,jsp 实现，没有使用任何框架）
- 超市管理系统：[https://github.com/zhanglei-workspace/shopping-management-system](https://github.com/zhanglei-workspace/shopping-management-system)
- Mall4j：[https://github.com/gz-yami/mall4j](https://github.com/gz-yami/mall4j) （Spring Boot 电商系统）
- newbee-mall：[https://github.com/newbee-ltd/newbee-mall](https://github.com/newbee-ltd/newbee-mall) （基于 Spring Boot 2.X 的全栈电商系统）
- litemall：[https://github.com/linlinjava/litemall](https://github.com/linlinjava/litemall) （小商城系统，Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端）
- forum-java：[https://github.com/Qbian61/forum-java](https://github.com/Qbian61/forum-java) （一款用 Java Spring Boot 实现的现代化社区系统）

### 尾声

学完这个阶段的知识后，一定要再串起来回忆一遍，必须自己独立开发一个 Java Web 项目（量级可以不大，但你学过的技术尽可能地用上），能发布到 Linux 服务器上让其他小伙伴访问就更好了~

如果你只是对 Java 感兴趣、或者只是想试着自己开发后台，并不是想靠 Java 找工作的话，学到这里就可以了。可以把更多时间投入到你主方向的学习中。

但如果你是想找 Java 方向的工作，尤其是想进大厂的话，一定要继续努力，用心学习下个阶段的企业开发进阶知识。

## 阶段 4：企业开发进阶

### 目标

学习更多企业级开发技术和编程思想，能够结合多种技术，独立开发出架构合理的完整系统，**解决实际问题** 。

要了解为什么需要这个技术？什么时候用这个技术？某个需求该用哪些技术？

当然，这个阶段的内容有些过于丰富，不是所有的东西都要学，大家可以根据自己的实际情况（时间），有选择地学习。

### 🌘 软件工程

详情请参考学习路线：[软件工程学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789190653197918210?type=)

软件开发和管理的一些概念、原则、技术、方法、工具和经验。

#### 知识

- 软件的本质
- 软件特性
- 软件过程
- 软件开发原则
  - 开闭原则
  - 里氏替换原则
  - 依赖倒置原则
  - 单一职责原则
  - 接口隔离原则
  - 迪米特法则
- 软件过程模型
- 敏捷开发
- 软件开发模型
- 需求建模
- 软件设计
- UML
- 体系结构设计
- 设计模式
- 软件质量管理
- 评审
- 软件质量保证
- 软件测试
  - 单元测试
  - 集成测试
  - 系统测试
  - 压力测试
  - 部署测试
- 软件配置管理
- 软件项目管理
- 软件项目估算
- 项目进度安排
- 风险管理
- 软件过程改进
  - 成熟度模型

#### 学习建议

大学软件专业的必修课，偏理论，能学到很多企业软件开发的方法，也是对软件开发同学综合能力的提升，有时间的话可以了解下。但对想要快速找工作的同学来说，忽略即可，面试基本不会问。

#### 资源

- 书籍
  - 《软件工程：实践者的研究方法》：[https://book.douban.com/subject/6047742/](https://book.douban.com/subject/6047742/) （经典大黑书，讲的非常全面，但同样完整读下来还是有些难度的）
  - 《软件开发的 201 个原则》：[https://book.douban.com/subject/35628886/](https://book.douban.com/subject/35628886/) （工具书，看一遍挺好的）
- 视频
  - 清华大学软件工程：[https://www.bilibili.com/video/BV1eE411V7Cr](https://www.bilibili.com/video/BV1eE411V7Cr)
  - 北京大学软件工程：[https://www.bilibili.com/video/BV1Vt411V72G](https://www.bilibili.com/video/BV1Vt411V72G)
  - 大连工业大学软件工程：[https://www.bilibili.com/video/BV1Ns41177VM](https://www.bilibili.com/video/BV1Ns41177VM)
- 大学课件
  - 浙大计算机软件工程：[https://github.com/QSCTech/zju-icicles](https://github.com/QSCTech/zju-icicles)

### 🌖 设计模式（21 天）

详情请参考学习路线：[设计模式学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789190698894860290?type=)

设计模式是软件开发中解决一类问题的通用方法。

使用设计模式能让你写出更优雅、可维护的代码，也正因如此，很多框架源码都用到了设计模式，你不学很难看懂。

此外，鱼皮改了几百份简历，基本上没有同学把设计模式写在项目经历中。因此学好设计模式并写在简历上是很加分的！

#### 知识

- 创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程
  - 单例模式
  - 工厂方法模式
  - 抽象工厂
  - 建造者模式
  - 原型模式
- 结构型模式：把类或对象结合在一起形成一个更大的结构
  - 适配器模式
  - 组合模式
  - 装饰器模式
  - 代理模式
  - 享元模式
  - 外观模式
  - 桥接模式
- 行为型模式：类和对象如何交互，及划分责任和算法
  - 迭代器模式
  - 模板方法模式
  - 策略模式
  - 命令模式
  - 状态模式
  - 责任链模式
  - 备忘录模式
  - 观察者模式
  - 访问者模式
  - 中介者模式
  - 解释器模式

#### 学习建议

先理解概念，了解每个设计模式的特点和应用场景，再多加练习，运用到实际项目。

#### 经典面试题

1. 单例模式有哪些实现方式？有哪些优缺点？请手写其中一种
2. 你用过哪些设计模式，为什么用它？

#### 资源

- 项目
  - [项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 中的聚合搜索项目、OJ 项目都运用了大量的设计模式，推荐学习
- 书籍
  - ⭐《图解设计模式》（强烈推荐这本书，正是用 Java 语言实现，图多、有示例代码、有习题和答案，很不错）
  - 《Head First 设计模式》
  - 《大话设计模式》
  - 《设计模式：可复用面向对象软件的基础》（大黑书，有能力的话也可以去读）
- 视频
  - 尚硅谷图解 Java 设计模式：[https://www.bilibili.com/video/BV1G4411c7N4](https://www.bilibili.com/video/BV1G4411c7N4)
- 文档
  - 菜鸟教程：[https://www.runoob.com/design-pattern/design-pattern-tutorial.html](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
  - 图说设计模式：[https://design-patterns.readthedocs.io/zh_CN/latest/](https://design-patterns.readthedocs.io/zh_CN/latest/)

### 🌕 Redis（14 天）

详情请参考学习路线：[Redis 学习路线](https://www.codefather.cn/course/1789189862986850306/section/1789190541746872321?type=)

缓存是高并发系统不可或缺的技术，可以提高系统的性能和并发，而 Redis 是实现缓存的最主流技术，因此它是后台开发必学的知识点，也是面试重点。

#### 知识

- Redis 基础
- 什么是缓存？
- 本地缓存
  - Caffeine 库
- 多级缓存
- Redis 分布式缓存
  - 数据类型
  - 常用操作
  - Java 操作 Redis
    - Spring Boot Redis Template
    - Redisson
  - 主从模型搭建
  - 哨兵集群搭建
  - 日志持久化
- 缓存（Redis）应用场景
  - 数据共享
  - 单点登录
  - 计数器
  - 限流
  - 点赞
  - 实时排行榜
  - 分布式锁
- 缓存常见问题
  - 缓存雪崩
  - 缓存击穿
  - 缓存穿透
  - 缓存更新一致性
- 相关技术：Memcached、Ehcache

#### 学习建议

学会如何简单地使用缓存并不难，和数据库类似，无非就是调用 API 对数据进行增删改查。

因此，建议先能够独立使用它，了解缓存的应用场景；再学习如何在 Java 中操作缓存中间件，并尝试和项目相结合，提高系统的性能。

跟着视频教程实操一遍即可，可以等到面试前再去深入了解原理和高级特性。

#### 经典面试题

1. Redis 为什么快？
2. Redis 有哪些常用的数据结构？
3. Redis RDB 和 AOF 持久化的区别，如何选择？
4. 如何解决缓存击穿、缓存穿透、雪崩问题？
5. 如何用 Redis 实现点赞功能，怎么设计 Key / Value？

#### 资源

- 项目
  - [项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 中的伙伴匹配系统、智能 BI 项目都运用了 Redis 解决实际问题，推荐学习
- 视频
  - ⭐ 2022 黑马 Redis 从基础到原理：[https://www.bilibili.com/video/BV1cr4y1671t](https://www.bilibili.com/video/BV1cr4y1671t)（结合项目去讲，强烈推荐）
  - 尚硅谷 - 2021 最新 Redis 6 入门到精通教程：[https://www.bilibili.com/video/BV1Rv41177Af](https://www.bilibili.com/video/BV1Rv41177Af) （基于 Redis 6 的，推荐）
- 文档
  - Redis 命令参考：[http://redisdoc.com/](http://redisdoc.com/)
  - Redis 面试题整理：[https://github.com/lokles/Web-Development-Interview-With-Java/blob/main/Redis 问题.md](https://github.com/lokles/Web-Development-Interview-With-Java/blob/main/Redis%E9%97%AE%E9%A2%98.md)
- 书籍
  - 《Redis 实战》（经典）
- 工具
  - ⭐ Redis 在线练习：[https://try.redis.io/](https://try.redis.io/) （强烈推荐）

### 🌖 消息队列（14 天）

消息队列是用于传输和保存消息的容器，也是大型分布式系统中常用的技术，主要解决应用耦合、异步消息、流量削锋等问题。后台开发必学，也是面试重点。

#### 知识

- 消息队列的作用
- RabbitMQ 消息队列
  - 生产消费模型
  - 交换机模型
  - 死信队列
  - 延迟队列
  - 消息持久化
  - Java 操作
  - 集群搭建
- 相关技术：Kafka、ActiveMQ、TubeMQ、RocketMQ

#### 学习建议

和缓存一样，学会如何使用消息队列并不难，无非就是调用 API 去生产、转发和消费消息。

因此，建议先能够独立使用它，了解消息队列的应用场景；再学习如何在 Java 中操作消息队列中间件，并尝试和项目相结合，感受消息队列带来的好处。

这里我建议初学者先学习 RabbitMQ，比 Kafka 要好理解一些。跟着视频教程实操一遍即可，可以等到面试前再去深入了解原理和高级特性。

#### 经典面试题

1. 使用消息队列有哪些优缺点？
2. 如何保证消息消费的幂等性？
3. 消息队列有哪些路由模型？
4. 你是否用过消息队列，解决过什么问题？

#### 资源

- 项目
  - [项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 中的智能 BI 项目、在线判题系统都运用了消息队列解决实际问题，推荐学习
- 视频
  - ⭐️ 2023 黑马 RabbitMQ 消息队列教程：[https://www.bilibili.com/video/BV1Xm4y1i7HP](https://www.bilibili.com/video/BV1Xm4y1i7HP)（适合快速入门）
  - ⭐ 尚硅谷 - 2021 最新 RabbitMQ 教程：[https://www.bilibili.com/video/BV1cb4y1o7zz](https://www.bilibili.com/video/BV1cb4y1o7zz) （更加全面）
- 文档
  - RabbitMQ 中文文档：[http://rabbitmq.mr-ping.com/](http://rabbitmq.mr-ping.com/)
- 书籍
  - ⭐️ 编程导航原创 Rocket MQ 消息队列专栏：[https://yuyuanweb.feishu.cn/wiki/R5mbwIMwCi9xkmkrpyOcp1pzn9b](https://yuyuanweb.feishu.cn/wiki/R5mbwIMwCi9xkmkrpyOcp1pzn9b)
  - 《RabbitMQ 实战：高效部署分布式消息队列》（经典）
- 工具
  - ⭐ RabbitMQ 在线模拟器：[http://tryrabbitmq.com/](http://tryrabbitmq.com/)

### 🌖 Nginx（14 天）

Nginx 是主流的、开源的、高性能的 HTTP 和反向代理 web 服务器，可以用于挂载网站、请求转发、负载均衡、网关路由等。前后端开发同学都需要学习，在后端开发的面试中有时会考到。

#### 知识

- Nginx 作用
- 正向代理
- 反向代理（负载均衡）
- 常用命令
- 配置
- 动静分离（网站部署）
- 集群搭建
- 相关技术：HAProxy、Apache

#### 学习建议

Nginx 的基本使用非常简单，甚至不需要看任何的视频，跟着一篇文章就能够用它来提供网站访问能力、实现反向代理。

但是在企业中，Nginx 的使用往往没那么简单，作为负载均衡、请求转发的重要组件，往往需要针对实际场景去写一些特定的配置。因此建议有时间的话，实践下 Nginx 的配置方法，了解 Nginx 基本的设计思想，对今后自己设计系统时也有帮助。

#### 经典面试题

1. Nginx 有哪些作用？
2. Nginx 为什么支持高并发？
3. Nginx 有哪些负载均衡策略？
4. 什么是 Nginx 惊群问题，如何解决它？

#### 资源

- 视频
  - ⭐ 尚硅谷 - Nginx 教程由浅入深：[https://www.bilibili.com/video/BV1zJ411w7SV](https://www.bilibili.com/video/BV1zJ411w7SV) （讲的比较全面）
  - ⭐ Nginx 鱼皮 - 手把手带你从 0 搭建个人网站：[https://www.bilibili.com/video/BV1rU4y1J785/](https://www.bilibili.com/video/BV1rU4y1J785/) （简单演示 Nginx 部署网站）
- 文档
  - Nginx 中文文档：[https://www.nginx.cn/doc/index.html](https://www.nginx.cn/doc/index.html)
- 工具
  - Nginx 配置在线生成：[https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN](https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN)

### 🌗 Netty 网络编程（21 天）

开源的 Java 网络编程框架，用于开发高性能（事件驱动、异步非阻塞）、高可靠的网络服务器和客户端程序。

很多网络框架和服务器程序都用到了 Netty 作为底层，学好 Netty 不仅可以让我们自己实现高性能服务器，也能更好地理解其他的框架应用、阅读源码。

#### 知识

- IO 模型（BIO / NIO）
- Channel
- Buffer
- Seletor
- Netty 模型
- WebSocket 编程（动手做个聊天室）
- 相关技术：Vertx（中文文档：[http://vertxchina.github.io/vertx-translation-chinese/](http://vertxchina.github.io/vertx-translation-chinese/) ，比 Netty 简单多了，实在看不懂 Netty 也可以学习下这个）

#### 学习建议

不同于之前学的 SSM 框架，Netty 还是需要一定学习成本的，一方面是国内资源太缺乏，另一方面很多重要的概念（比如 NIO）还是要多动手写代码调试才能理解。

还是建议先从视频入门，并且不建议在 Netty 上花太多时间，面试的时候一般也就考察一些 Netty 背后的思想（比如 NIO）而非框架本身的语法细节。

#### 经典面试题

1. Netty 有哪些优点？
2. 什么是 NIO？
3. 介绍 Netty 的零拷贝机制

#### 资源

- 视频
  - ⭐ 尚硅谷 Netty 教程：[https://www.bilibili.com/video/BV1DJ411m7NR](https://www.bilibili.com/video/BV1DJ411m7NR)
  - Netty 技术演讲（中文字幕版）：[https://www.youtube.com/watch?v=I8yy2Cy7dDI](https://www.youtube.com/watch?v=I8yy2Cy7dDI)
- 文档
  - Netty 4 用户指南：[https://www.w3cschool.cn/netty_4_user_guide/](https://www.w3cschool.cn/netty_4_user_guide/)
- 书籍
  - 《Netty 实战》

### 🌖 微服务（60 天）

随着互联网的发展，项目越来越复杂，单机且庞大的巨石项目已无法满足开发、运维、并发、可靠性等需求。

因此，后台架构不断演进，可以将庞大的项目拆分成一个个职责明确、功能独立的细小模块，模块可以部署在多台服务器上，相互配合协作，提供完整的系统能力。

换言之，想做大型项目，这块儿一定要好好学！

#### 知识

##### Dubbo

- 架构演进
- RPC
- Zookeeper
- 服务提供者
- 服务消费者
- 项目搭建
- 相关技术：DubboX（对 Dubbo 的扩展）

##### 🌖 微服务

- 微服务概念
- Spring Cloud 框架
  - 子父工程
  - 服务注册与发现
  - 注册中心 Eureka、Zookeeper、Consul
  - Ribbon 负载均衡
  - Feign 服务调用
  - Hystrix 服务限流、降级、熔断
  - Resilience4j 服务容错
  - Gateway（Zuul）微服务网关
  - Config 分布式配置中心
  - 分布式服务总线
  - Sleuth + Zipkin 分布式链路追踪
- Spring Cloud Alibaba
  - Nacos 注册、配置中心
  - OpenFeign 服务调用
  - Sentinel 流控
  - Seata 分布式事务

##### 接口管理

- Swagger 接口文档
- Postman 接口测试
- 相关技术：YApi、ShowDoc

#### 学习建议

时间不急的话，建议先从 Dubbo 学起，对分布式、RPC、微服务有些基本的了解，再去食用 Spring Cloud 全家桶会更香。学完 Spring Cloud 全家桶后，再去学 Spring Cloud Alibaba 就很简单了。

这部分内容的学习，原理 + 实践都很重要，也不要被各种高大上的词汇唬住了，都是上层（应用层）的东西，基本没有什么算法，跟着视频教程学，其实还是很好理解的。

分布式相关知识非常多，但这里不用刻意去背，先通过视频教程实战使用一些微服务框架，也能对其中的概念有基本的了解。

大厂面试的时候很少问 Spring Cloud 框架的细节，更多的是微服务以及各组件的一些思想，比如网关的好处、消息总线的好处等。

#### 经典面试题

1. 什么是微服务，有哪些优缺点？
2. 什么是注册中心，能解决什么问题？

#### 资源

- 项目实战
  - [项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 中的 API 开放平台、在线判题系统都运用了微服务，推荐学习
- 视频
  - ⭐️ 黑马 Spring Cloud 视频教程：[https://www.bilibili.com/video/BV1kH4y1S7wz](https://www.bilibili.com/video/BV1kH4y1S7wz)（11 小时，非常凝练，适合快速入门）
  - ⭐️ 尚硅谷 Dubbo 教程：[https://www.bilibili.com/video/BV1ns411c7jV](https://www.bilibili.com/video/BV1ns411c7jV)
  - 尚硅谷 SpringCloud（H 版&alibaba）框架开发教程（微服务分布式架构）：[https://www.bilibili.com/video/BV18E411x7eT](https://www.bilibili.com/video/BV18E411x7eT) （把国外的 Spring Cloud 和国内的 Spring Cloud Alibaba 结合在一起对比着去讲，主流技术栈、知识点都讲到了，内容更全面）
- 文档
  - Apache Dubbo 官方文档：[https://dubbo.apache.org/zh/](https://dubbo.apache.org/zh/)
  - Spring Cloud Alibaba 官方文档：[https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md](https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md)
  - ⭐ Swagger 教学文档：[https://doc.xiaominfo.com/](https://doc.xiaominfo.com/) （跟着快速开始直接用就好了）

### 🌖 容器（7 天）

将应用和环境进行封装，相互隔离、独立部署、便于移植，提高安全性、提高开发和维护效率。

便于实现微服务、持续集成和交付。

#### 知识

- 🌖 Docker
  - 容器概念
  - 镜像
  - 部署服务
  - Dockerfile
  - Docker Compose
  - Docker Machine
  - Docker Swarm
  - 多阶段构建
- 🌘 K8S（Kubernetes）
  - K8S 架构
  - 工作负载
    - 资源类型
    - Pod
    - Pod 生命周期
    - Pod 安全策略
  - K8S 组件
  - K8S 对象
  - 部署应用
  - 服务
    - Ingress
  - Kubectl 命令行
  - 集群管理
- 相关技术：Apache Mesos、Mesosphere

#### 学习建议

业务上云是趋势，但是对于开发同学来说，会用 Docker / K8S 部署项目和服务就行。实际工作中，企业一般都有现成的平台直接用，面试考察的也不多，不用花太多时间。

#### 经典面试题

1. 什么是容器？
2. 使用  Docker 有哪些好处？
3. 如何快速启动多个 Docker 节点？

#### 资源

- 项目实战
  - [项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 中的在线判题项目运用了 Docker 解决实际问题，推荐学习
- 视频
  - ⭐【狂神说】Docker 最新超详细版教程通俗易懂：[https://www.bilibili.com/video/BV1og4y1q7M4](https://www.bilibili.com/video/BV1og4y1q7M4)
  - K8S 视频教程：[https://www.bilibili.com/video/BV1K5411N7j8](https://www.bilibili.com/video/BV1K5411N7j8)
- 书籍
  - 《深入浅出 Docker》：[https://www.zhihu.com/pub/reader/119632192](https://www.zhihu.com/pub/reader/119632192)
- 文档
  - Docker — 从入门到实践：[https://vuepress.mirror.docker-practice.com/](https://vuepress.mirror.docker-practice.com/)
  - 菜鸟教程 Docker：[https://www.runoob.com/docker/docker-tutorial.html](https://www.runoob.com/docker/docker-tutorial.html)
  - 国外 Docker 官方文档：[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
- 网站
  - Docker 中文社区：[https://www.docker.org.cn/](https://www.docker.org.cn/) （强烈推荐，有很多 Docker 技术文章和学习笔记）
  - Docker Blog：[https://www.docker.com/blog/](https://www.docker.com/blog/) （国外 Docker 技术博客）
- 镜像源
  - Docker Hub：[https://hub.docker.com](https://hub.docker.com)
  - 腾讯软件源：[http://mirrors.tencent.com/#/index](http://mirrors.tencent.com/#/index)
  - 阿里云 Docker 仓库：[https://cr.console.aliyun.com/](https://cr.console.aliyun.com/)

### 🌗 CI / CD（3 天）

持续集成 / 持续交付，贯穿整个研发到项目上线的过程，提高效率。

大公司一般都有自己的 CI / CD 平台。

#### 知识

- 什么是 CI / CD
- CI / CD 有什么好处
- 使用任一 CI / CD 平台
- 相关技术：Jenkins、GitLab、微信云托管

#### 学习建议

了解它是什么，并且实战使用任一 CI / CD 平台，感受它和传统开发运维到底有什么不同，就足够了。其实很简单，不要花太多时间。

真正要自己去搭建的时候，跟着官方文档来就行。

#### 资源

- 视频
  - ⭐【狂神说】CI/CD 到底是什么？十分钟理解企业级 DevOps：[https://www.bilibili.com/video/BV1zf4y127vu](https://www.bilibili.com/video/BV1zf4y127vu) （讲的非常棒！带你快速理解 CI / CD 的作用和部分原理）
  - 尚硅谷 - Jenkins 持续集成工具教程：[https://www.bilibili.com/video/BV1GW411w7pn](https://www.bilibili.com/video/BV1GW411w7pn) （实在要用到 Jenkins 再去学）
- 文档
  - Jenkins 官方文档：[https://www.jenkins.io/zh/](https://www.jenkins.io/zh/) （有很多案例，要用的时候查一下就行了）
- 实战平台
  - ⭐ 微信云托管：[https://cloud.weixin.qq.com/cloudrun](https://cloud.weixin.qq.com/cloudrun) （直播演示过，鱼皮后面会给大家出视频教程）
  - 前端托管 Webify：[https://cloud.tencent.com/product/webify](https://cloud.tencent.com/product/webify) （鱼皮给大家出过视频教程的 [https://www.bilibili.com/video/BV11V411p7vf/）](https://www.bilibili.com/video/BV11V411p7vf/）)

### 练手项目

学习完框架后，即可跟着鱼皮的原创项目教程系列边学边做项目。用项目驱动学习，更快地掌握后端必学技术，并直接写在简历上：[项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 。

- mall-learning：[https://github.com/macrozheng/mall-learningmall](https://github.com/macrozheng/mall-learningmall) （学习教程，架构、业务、技术要点全方位解析）
- miaosha：[https://github.com/qiurunze123/miaosha](https://github.com/qiurunze123/miaosha) （秒杀系统设计与实现）
- Mall：[https://github.com/macrozheng/mall](https://github.com/macrozheng/mall) （包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现）
- Spring-Cloud-Admin：[https://github.com/wxiaoqi/Spring-Cloud-AdminCloud-Admin](https://github.com/wxiaoqi/Spring-Cloud-AdminCloud-Admin) （基于 Spring Cloud 微服务化开发平台，具有统一授权、认证的后台管理系统）
- paascloud-master：[https://github.com/paascloud/paascloud-master](https://github.com/paascloud/paascloud-master) （基于 spring cloud + vue + oAuth2.0，前后端分离商城系统）
- mall-swarm：[https://github.com/macrozheng/mall-swarm](https://github.com/macrozheng/mall-swarm) （一套微服务商城系统，采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台方便快速搭建系统）
- SecKill：[https://github.com/hfbin/Seckill](https://github.com/hfbin/Seckill) （基于 SpringBoot+Mybatis+Redis+RabbitMQ 秒杀系统）
- jeecg-boot：[https://github.com/zhangdaiscott/jeecg-boot](https://github.com/zhangdaiscott/jeecg-boot) （低代码开发平台）
- PassJava-Platform：[https://github.com/Jackson0714/PassJava-Platform](https://github.com/Jackson0714/PassJava-Platform) （一款面试刷题的 Spring Cloud 开源系统）

### 尾声

看到这里，相信你已经感叹：编程语言一辈子学不完了！

但是，不用担心，通过对这么多知识点的学习，相信你已经有了一定的积累，也不知不觉地锻炼了自主学习能力、资源检索能力、代码阅读能力、问题解决能力，之后的学习会越来越轻松。

接下来，可以试着用你学到的技术来解决实际的问题，自主从 0 开始做一些项目，保持编程手感。

## 阶段 5：项目实战

### 目标

综合所学技术从 0 到 1 开发和上线一个全面、有特色的、可以写进简历的个人项目。

### 学习建议

其实在之前的框架学习视频中应该就做过几个项目了，但相对不够完整和体系化。

有想法的同学可以做任何自己想做的项目，推荐参加一些作品类竞赛，练手、拿奖、收获项目经历一举三得。

暂时没想法的朋友，建议先跟着专门带做项目的视频教程做 1 - 2 套 Java 完整项目，一定要从 0 到 1 自己手写！

有能力的朋友也可以试着用 GitHub 上的源码来学习啦~

做一个完整的项目的确很不容易，建议大家根据自己的 **时间、兴趣** 选择 **较新的**、**有配套源码的** 教程，保持耐心。

如何选择编程学习资源，可以看下我的原创文章：[https://mp.weixin.qq.com/s/mlMql9RJCd7THt6rpGb8UA](https://mp.weixin.qq.com/s/mlMql9RJCd7THt6rpGb8UA)

下面推荐一些优质的、较新的项目实战视频教程 + 50 套项目源码。

### 视频教程

[编程导航](https://yuyuanweb.feishu.cn/wiki/VC1qwmX9diCBK3kidyec74vFnde) 内部分享：

1. ⭐️ 鱼皮全程直播带做的保姆级全栈项目，带现成的简历写法和面试题：[项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd)。
2. [项目训练营（寻爱网项目）](https://www.codefather.cn/course/1806250609774997505)：学习从立项到上线的完整做项目流程 + 优化思路
3. [从 0 到 1 开发用户中心](https://www.codefather.cn/course/1790943469757837313)：保姆级前后端完整项目教程，适合刚学完框架的新手
4. [伙伴匹配系统](https://www.codefather.cn/course/1790950013153095682)：移动端网站，设计分布式和并发编程知识，适合已经做过一个小项目的同学练习
5. [Web 终端项目经验分享](https://www.codefather.cn/essay/1808581806845460481)：前后端技术选型 + 系统设计 + 源码解读 + 简历亮点全面分享
6. [面试刷题网站项目经验分享](https://www.codefather.cn/essay/1808582645974695938)：从 0 到 1 分享数万用户网站的创作过程和经验分享
7. [瑞吉外卖 - 外卖点餐系统](https://www.codefather.cn/post/1808581581993017346)：Java Spring Boot 入门级项目，适合刚学完框架的同学
8. [尚医通 - 在线预约挂号平台](https://www.codefather.cn/post/1808581478360154114)：业务功能完整的 Java Spring Cloud 微服务项目，适合刚学完微服务的同学
9. [硅谷课堂 - 在线学习平台](https://www.codefather.cn/post/1808581015011196930)：业务功能完整的 Java Spring Cloud 微服务项目，适合想学习第三方服务对接的同学
10. [黑马点评 - 类似大众点评的移动 APP](https://www.codefather.cn/post/1808580989170089985)：专门为学习 Redis 定制的单体项目，适合刚学完 Spring Boot、想系统学习 Redis 的同学

公开：

- 尚硅谷 - 谷粒学院 - 微服务 + 全栈 - 在线教育实战项目：[https://www.bilibili.com/video/BV1dQ4y1A75e](https://www.bilibili.com/video/BV1dQ4y1A75e) （全栈项目，前后端讲得都很全面）
- 尚硅谷 - 尚筹网 - Java 项目实战开发教程 - SSM 框架 + 微服务架构：[https://www.bilibili.com/video/BV1bE411T7oZ（500](https://www.bilibili.com/video/BV1bE411T7oZ（500) 多集，包含完整的用户权限管理，功能丰富、讲得很细致全面）
- 黑马 - 24 小时搞定 Java 毕设电商项目：[https://www.bilibili.com/video/BV13f4y1r7fS](https://www.bilibili.com/video/BV13f4y1r7fS)
- 黑马程序员 Java 项目《传智健康》，超完整的企业级医疗行业项目：[https://www.bilibili.com/video/BV1Bo4y117zV](https://www.bilibili.com/video/BV1Bo4y117zV)
- 黑马程序员 Java 项目《万信金融》企业级开发实战，互联网金融行业解决方案：[https://www.bilibili.com/video/BV1Ub4y1f7rk](https://www.bilibili.com/video/BV1Ub4y1f7rk)
- 黑马程序员 Java 项目 SaaS 移动办公完整版《iHRM 人力资源管理系统》，跨行业 SaaS 办公整合性解决方案：[https://www.bilibili.com/video/BV18A411L7UX](https://www.bilibili.com/video/BV18A411L7UX)
- 黑马程序员 Java 大型分布式微服务闪聚支付项目，Java 移动支付全生态系统：[https://www.bilibili.com/video/BV17v411V79c](https://www.bilibili.com/video/BV17v411V79c)
- 黑马程序员 Java 项目《好客租房》：[https://www.bilibili.com/video/BV1sZ4y1F7PD](https://www.bilibili.com/video/BV1sZ4y1F7PD)

### 常用类库

##### 工具

- Guava：谷歌开发的 Java 工具库（[https://github.com/google/guava](https://github.com/google/guava)）
- Apache Commons：各类工具库，比如 commons-lang、commons-io、commons-collections 等（[https://github.com/apache/commons-lang](https://github.com/apache/commons-lang)）
- Hutool：Java 工具集库（[https://github.com/looly/hutool](https://github.com/looly/hutool)）
- Lombok：Java 增强库（[https://github.com/projectlombok/lombok](https://github.com/projectlombok/lombok)）
- Apache HttpComponents Client：HTTP 客户端库（[https://github.com/apache/httpcomponents-client](https://github.com/apache/httpcomponents-client)）
- OkHttp：适用于 JVM、Android 等平台的 Http 客户端（[https://github.com/square/okhttp](https://github.com/square/okhttp)）
- Gson：谷歌的 JSON 处理库（[https://github.com/google/gson](https://github.com/google/gson)）
- Jcommander：Java 命令行参数解析框架（[https://github.com/cbeust/jcommander](https://github.com/cbeust/jcommander)）
- Apache PDFBox：PDF 操作库（[https://github.com/apache/pdfbox](https://github.com/apache/pdfbox)）
- EasyExcel：阿里的 Excel 处理库（[https://github.com/alibaba/easyexcel](https://github.com/alibaba/easyexcel)）
- Apache POI：表格文件处理库（[https://github.com/apache/poi](https://github.com/apache/poi)）

##### 测试

- JUnit：Java 测试框架（[https://github.com/junit-team/junit4](https://github.com/junit-team/junit4)）
- Mockito：Java 单元测试 Mock 框架（[https://github.com/mockito/mockito](https://github.com/mockito/mockito)）
- Selenium：浏览器自动化框架（[https://github.com/SeleniumHQ/selenium](https://github.com/SeleniumHQ/selenium)）
- htmlunit：Java 模拟浏览器（[https://github.com/HtmlUnit/htmlunit](https://github.com/HtmlUnit/htmlunit)）
- TestNG：Java 测试框架（[https://github.com/cbeust/testng](https://github.com/cbeust/testng)）
- Jacoco：Java 代码覆盖度库（[https://github.com/jacoco/jacoco](https://github.com/jacoco/jacoco)）

##### 其他

- cglib：字节码生成库（[https://github.com/cglib/cglib](https://github.com/cglib/cglib)）
- Arthas：Java 诊断工具（[https://github.com/alibaba/arthas](https://github.com/alibaba/arthas)）
- config：针对 JVM 的配置库（[https://github.com/lightbend/config](https://github.com/lightbend/config)）
- Quasar：Java 纤程库（[https://github.com/puniverse/quasar](https://github.com/puniverse/quasar)）
- drools：Java 规则引擎（[https://github.com/kiegroup/drools](https://github.com/kiegroup/drools)）
- Caffeine：Java 高性能缓存库（[https://github.com/ben-manes/caffeine](https://github.com/ben-manes/caffeine)）
- Disruptor：高性能线程间消息传递库（[https://github.com/LMAX-Exchange/disruptor](https://github.com/LMAX-Exchange/disruptor)）
- Knife4j：Swagger 文档增强（[https://doc.xiaominfo.com/](https://doc.xiaominfo.com/)）
- Thumbnailator：Java 缩略图生成库（[https://github.com/coobird/thumbnailator](https://github.com/coobird/thumbnailator)）
- Logback：Java 日志库（[https://github.com/qos-ch/logback](https://github.com/qos-ch/logback)）
- Apache Camel：消息传输集成框架（[https://github.com/apache/camel](https://github.com/apache/camel)）
- Quartz：定时任务调度库（[https://github.com/quartz-scheduler/quartz](https://github.com/quartz-scheduler/quartz)）
- Apache Mahout：机器学习库（[https://github.com/apache/mahout](https://github.com/apache/mahout)）
- Apache OpenNLP：NLP 工具库（[https://github.com/apache/opennlp](https://github.com/apache/opennlp)）
- RxJava：JVM 反应式编程框架（[https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)）
- JProfiler：性能分析库（[https://www.ej-technologies.com/products/jprofiler/overview.html](https://www.ej-technologies.com/products/jprofiler/overview.html)）
- jsoup：HTML 文档解析库（[https://jsoup.org/](https://jsoup.org/)）
- webmagic：Java 爬虫框架（[https://github.com/code4craft/webmagic/](https://github.com/code4craft/webmagic/)）

### IDEA 插件

综合实用性、易用性、流行度、维护频率，精选了以下插件，简单分类为天地二品。

#### 精选地品插件

简单好用、增强功能

- Background Image Plus +
  - 描述：给编辑器设置背景图片（小姐姐图片）
  - 官网：[https://plugins.jetbrains.com/plugin/11247-background-image-plus-](https://plugins.jetbrains.com/plugin/11247-background-image-plus-)
- Chinese Language Pack
  - 描述：中文支持
  - 官网：[https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----](https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----)
- Translation
  - 描述：翻译插件，鼠标选中文本，点击右键即可自动翻译成多国语言。
  - 官网：[https://plugins.jetbrains.com/plugin/8579-translation/](https://plugins.jetbrains.com/plugin/8579-translation/)
- Key Promoter X
  - 描述：快捷键提示插件。当你执行鼠标操作时，如果该操作可被快捷键代替，会给出提示，帮助你自然形成使用快捷键的习惯，告别死记硬背。
  - 官网：[https://plugins.jetbrains.com/plugin/9792-key-promoter-x/](https://plugins.jetbrains.com/plugin/9792-key-promoter-x/)
- Rainbow Brackets
  - 描述：给括号添加彩虹色，使开发者通过颜色区分括号嵌套层级，便于阅读
  - 官网：[https://plugins.jetbrains.com/plugin/10080-rainbow-brackets/](https://plugins.jetbrains.com/plugin/10080-rainbow-brackets/)
- CodeGlance
  - 描述：在编辑器右侧生成代码小地图，可以拖拽小地图光标快速定位代码，阅读行数很多的代码文件时非常实用。
  - 官网：[https://plugins.jetbrains.com/plugin/7275-codeglance/](https://plugins.jetbrains.com/plugin/7275-codeglance/)
- WakaTime
  - 描述：代码统计和跟踪插件
  - 官网：[https://plugins.jetbrains.com/plugin/7425-wakatime](https://plugins.jetbrains.com/plugin/7425-wakatime)
- Statistic
  - 描述：代码统计
  - 官网：[https://plugins.jetbrains.com/plugin/4509-statistic](https://plugins.jetbrains.com/plugin/4509-statistic)

#### 精选天品插件

提高开发效率和代码质量

- String Manipulation
  - 描述：字符串快捷处理
  - 官网：[https://plugins.jetbrains.com/plugin/2162-string-manipulation](https://plugins.jetbrains.com/plugin/2162-string-manipulation)
- Tabnine AI Code Completion
  - 描述：使用 AI 去自动提示和补全代码，比 IDEA 自带的代码补全更加智能化
  - 官网：[https://plugins.jetbrains.com/plugin/12798-tabnine-ai-code-completion-js-java-python-ts-rust-go-php--more](https://plugins.jetbrains.com/plugin/12798-tabnine-ai-code-completion-js-java-python-ts-rust-go-php--more)
- GsonFormatPlus
  - 描述：根据 json 生成对象
  - 官网：[https://plugins.jetbrains.com/plugin/14949-gsonformatplus](https://plugins.jetbrains.com/plugin/14949-gsonformatplus)
- JUnitGenerator V2.0
  - 描述：自动生成单元测试
  - 官网：[https://plugins.jetbrains.com/plugin/3064-junitgenerator-v2-0](https://plugins.jetbrains.com/plugin/3064-junitgenerator-v2-0)
- RestfulTool
  - 描述：辅助 web 开发的工具集
  - 官网：[https://plugins.jetbrains.com/plugin/14280-restfultool](https://plugins.jetbrains.com/plugin/14280-restfultool)
- SequenceDiagram
  - 描述：自动生成方法调用时序图
  - 官网：[https://plugins.jetbrains.com/plugin/8286-sequencediagram](https://plugins.jetbrains.com/plugin/8286-sequencediagram)
- CheckStyle-IDEA
  - 描述：自动检查 Java 代码规范
  - 官网：[https://plugins.jetbrains.com/plugin/1065-checkstyle-idea](https://plugins.jetbrains.com/plugin/1065-checkstyle-idea)
- Alibaba Java Coding Guidelines
  - 描述：代码规范检查插件
  - 官网：[https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines](https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines)
- SonarLint
  - 描述：帮助你发现和修复代码的错误和漏洞
  - 官网：[https://plugins.jetbrains.com/plugin/7973-sonarlint](https://plugins.jetbrains.com/plugin/7973-sonarlint)
- MybatisX
  - 描述：MyBatis 增强插件，支持自动生成 entity、mapper、service 等常用操作的代码，优化体验
  - 官网：[https://plugins.jetbrains.com/plugin/10119-mybatisx](https://plugins.jetbrains.com/plugin/10119-mybatisx)

#### 美化类

- Extra Icons
  - 描述：图标美化插件，支持更多文件类型
  - 官网：[https://plugins.jetbrains.com/plugin/11058-extra-icons](https://plugins.jetbrains.com/plugin/11058-extra-icons)
- Chinese Language Pack
  - 描述：中文支持
  - 官网：[https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----](https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----)
- Grep Console
  - 描述：自定义设置控制台输出颜色
  - 官网：[https://plugins.jetbrains.com/idea/plugin/7125-grep-console](https://plugins.jetbrains.com/idea/plugin/7125-grep-console)
- Material Theme UI
  - 描述：美观的主题
  - 官网：[https://plugins.jetbrains.com/plugin/8006-material-theme-ui](https://plugins.jetbrains.com/plugin/8006-material-theme-ui)
- Nyan Progress Bar
  - 描述：进度条美化
  - 官网：[https://plugins.jetbrains.com/plugin/8575-nyan-progress-bar](https://plugins.jetbrains.com/plugin/8575-nyan-progress-bar)
- activate-power-mode
  - 描述：打字特效
  - 官网：[https://plugins.jetbrains.com/plugin/8330-activate-power-mode](https://plugins.jetbrains.com/plugin/8330-activate-power-mode)
- Power Mode II
  - 描述：打字特效插件升级版
  - 官网：[https://plugins.jetbrains.com/plugin/8251-power-mode-ii](https://plugins.jetbrains.com/plugin/8251-power-mode-ii)
- Rainbow Brackets
  - 描述：给括号添加彩虹色，使开发者通过颜色区分括号嵌套层级，便于阅读
  - 官网：[https://plugins.jetbrains.com/plugin/10080-rainbow-brackets/](https://plugins.jetbrains.com/plugin/10080-rainbow-brackets/)
- Background Image Plus +
  - 描述：给编辑器设置背景图片
  - 官网：[https://plugins.jetbrains.com/plugin/11247-background-image-plus-](https://plugins.jetbrains.com/plugin/11247-background-image-plus-)

#### 代码生成类

- Codota AI Autocomplete for Java and JavaScript
  - 描述：使用 AI 去自动提示和补全代码，比 IDEA 自带的代码补全更加智能化
  - 官网：[https://plugins.jetbrains.com/plugin/7638-codota-ai-autocomplete-for-java-and-javascript](https://plugins.jetbrains.com/plugin/7638-codota-ai-autocomplete-for-java-and-javascript)
- Tabnine AI Code Completion
  - 描述：使用 AI 来自动提示和补全代码，比 IDEA 自带的代码补全更加智能化
  - 官网：[https://plugins.jetbrains.com/plugin/12798-tabnine-ai-code-completion-js-java-python-ts-rust-go-php--more](https://plugins.jetbrains.com/plugin/12798-tabnine-ai-code-completion-js-java-python-ts-rust-go-php--more)
- UUID Generator
  - 描述：生成随机的 UUID
  - 官网：[https://plugins.jetbrains.com/plugin/8320-uuid-generator](https://plugins.jetbrains.com/plugin/8320-uuid-generator)
- Randomness
  - 描述：生成随机值
  - 官网：[https://plugins.jetbrains.com/plugin/9836-randomness](https://plugins.jetbrains.com/plugin/9836-randomness)
- .ignore
  - 描述：生成不同语言的版本控制忽略文件
  - 官网：[https://plugins.jetbrains.com/plugin/7495--ignore](https://plugins.jetbrains.com/plugin/7495--ignore)
- Auto filling Java call arguments
  - 描述：通过快捷键自动补全函数的调用参数
  - 官网：[https://plugins.jetbrains.com/plugin/8638-auto-filling-java-call-arguments/](https://plugins.jetbrains.com/plugin/8638-auto-filling-java-call-arguments/)
- GenerateAllSetter
  - 描述：快速生成调用对象 setter 方法的代码
  - 官网：[https://plugins.jetbrains.com/plugin/9360-generateallsetter](https://plugins.jetbrains.com/plugin/9360-generateallsetter)
- GenerateSerialVersionUID
  - 描述：一键为实现 Serializable 接口的类生成 SerialVersionUID
  - 官网：[https://plugins.jetbrains.com/plugin/185-generateserialversionuid/](https://plugins.jetbrains.com/plugin/185-generateserialversionuid/)
- GsonFormatPlus
  - 描述：根据 json 生成对象
  - 官网：[https://plugins.jetbrains.com/plugin/14949-gsonformatplus](https://plugins.jetbrains.com/plugin/14949-gsonformatplus)
- Lombok
  - 描述：配合 Lombok 依赖及注解使用，能够大大减少 Java 对象的代码量。IDEA 已自带，无需安装。
  - 官网：[https://plugins.jetbrains.com/plugin/6317-lombok/](https://plugins.jetbrains.com/plugin/6317-lombok/)
- Easy Code
  - 描述：根据数据库表生成 Java entity、dao、mapper、service、controller 等代码
  - 官网：[https://plugins.jetbrains.com/plugin/10954-easy-code](https://plugins.jetbrains.com/plugin/10954-easy-code)
- Easy Javadoc
  - 描述：快速生成 Javadoc 文档
  - 官网：[https://plugins.jetbrains.com/plugin/12977-easy-javadoc](https://plugins.jetbrains.com/plugin/12977-easy-javadoc)
- JavaDoc
  - 描述：生成 Javadoc 文档
  - 官网：[https://plugins.jetbrains.com/plugin/7157-javadoc](https://plugins.jetbrains.com/plugin/7157-javadoc)
- Json2Pojo
  - 描述：根据 JSON 生成 POJO，根据 POJO 生成 JSON
  - 官网：[https://plugins.jetbrains.com/plugin/8533-json2pojo](https://plugins.jetbrains.com/plugin/8533-json2pojo)
- JUnitGenerator V2.0
  - 描述：自动生成单元测试
  - 官网：[https://plugins.jetbrains.com/plugin/3064-junitgenerator-v2-0](https://plugins.jetbrains.com/plugin/3064-junitgenerator-v2-0)
- Jindent - Source Code Formatter
  - 描述：根据自定义模板来生成 javadoc 注释
  - 官网：[https://plugins.jetbrains.com/plugin/8309-jindent--source-code-formatter](https://plugins.jetbrains.com/plugin/8309-jindent--source-code-formatter)
- MybatisX
  - 描述：MyBatis 增强插件，支持自动生成 entity、mapper、service 等常用操作的代码，优化体验
  - 官网：[https://plugins.jetbrains.com/plugin/10119-mybatisx](https://plugins.jetbrains.com/plugin/10119-mybatisx)
- MyBatisCodeHelperPro
  - 描述：MyBatis 增强插件，支持自动生成 entity、mapper、service 等常用操作的代码（收费）
  - 官网：[https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro](https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro)

#### 功能提效类

##### 源码阅读

- Call Graph
  - 描述：生成调用关系图，便于查看源码
  - 官网：[https://plugins.jetbrains.com/plugin/12304-call-graph](https://plugins.jetbrains.com/plugin/12304-call-graph)
- Jump to Line
  - 描述：支持跳转到任意行进行调试
  - 官网：[https://plugins.jetbrains.com/plugin/14877-jump-to-line](https://plugins.jetbrains.com/plugin/14877-jump-to-line)
- SequenceDiagram
  - 描述：自动生成方法调用时序图
  - 官网：[https://plugins.jetbrains.com/plugin/8286-sequencediagram](https://plugins.jetbrains.com/plugin/8286-sequencediagram)
- jclasslib Bytecode Viewer
  - 描述：字节码查看器
  - 官网：[https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer](https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer)
- BrowseWordAtCaret
  - 描述： 快速在相同单词间进行跳转
  - 官网：[https://plugins.jetbrains.com/plugin/201-browsewordatcaret](https://plugins.jetbrains.com/plugin/201-browsewordatcaret)
- CodeGlance
  - 描述：在编辑器右侧生成代码小地图，可以拖拽小地图光标快速定位代码，阅读行数很多的代码文件时非常实用。
  - 官网：[https://plugins.jetbrains.com/plugin/7275-codeglance/](https://plugins.jetbrains.com/plugin/7275-codeglance/)

##### 代码规范

- CheckStyle-IDEA
  - 描述：自动检查 Java 代码规范
  - 官网：[https://plugins.jetbrains.com/plugin/1065-checkstyle-idea](https://plugins.jetbrains.com/plugin/1065-checkstyle-idea)
- Alibaba Java Coding Guidelines
  - 描述：代码规范检查插件
  - 官网：[https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines](https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines)
- SonarLint
  - 描述：帮助你发现和修复代码的错误和漏洞
  - 官网：[https://plugins.jetbrains.com/plugin/7973-sonarlint](https://plugins.jetbrains.com/plugin/7973-sonarlint)
- FindBugs-IDEA
  - 描述：帮你找出代码中潜藏的 Bug
  - 官网：[https://plugins.jetbrains.com/plugin/3847-findbugs-idea](https://plugins.jetbrains.com/plugin/3847-findbugs-idea)
- MetricsReloaded
  - 描述：代码复杂度分析
  - 官网：[https://plugins.jetbrains.com/plugin/93?pr=idea](https://plugins.jetbrains.com/plugin/93?pr=idea)

##### 格式处理

- CamelCase
  - 描述：快速字符串格式转换工具，如驼峰式
  - 官网：[https://plugins.jetbrains.com/plugin/7160-camelcase](https://plugins.jetbrains.com/plugin/7160-camelcase)
- Json Parser
  - 描述：验证和格式化 Json 字符串的工具
  - 官网：[https://plugins.jetbrains.com/plugin/10650-json-parser](https://plugins.jetbrains.com/plugin/10650-json-parser)
- Properties to YAML Converter
  - 描述：把 Properties 文件的格式转为 YAML 格式
  - 官网：[https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter](https://plugins.jetbrains.com/plugin/8000-properties-to-yaml-converter)
- String Manipulation
  - 描述：字符串快捷处理
  - 官网：[https://plugins.jetbrains.com/plugin/2162-string-manipulation](https://plugins.jetbrains.com/plugin/2162-string-manipulation)

##### 代码统计

- WakaTime
  - 描述：代码统计和跟踪插件
  - 官网：[https://plugins.jetbrains.com/plugin/7425-wakatime](https://plugins.jetbrains.com/plugin/7425-wakatime)
- Statistic
  - 描述：代码统计
  - 官网：[https://plugins.jetbrains.com/plugin/4509-statistic](https://plugins.jetbrains.com/plugin/4509-statistic)

##### 代码检索

- OnlineSearch
  - 描述：选择文本后支持不同搜索引擎进行搜索
  - 官网：[https://plugins.jetbrains.com/plugin/8298-onlinesearch/](https://plugins.jetbrains.com/plugin/8298-onlinesearch/)
- CodeSearch
  - 描述：快捷地打开搜索引擎进行搜索
  - 官网：[https://plugins.jetbrains.com/plugin/12578-codesearch](https://plugins.jetbrains.com/plugin/12578-codesearch)

##### 其他

- Leetcode Editor
  - 描述：在 IDEA 里刷算法题
  - 官网：[https://plugins.jetbrains.com/plugin/12132-leetcode-editor](https://plugins.jetbrains.com/plugin/12132-leetcode-editor)
- File Watchers
  - 描述：监听文件，当其发生变化时自动执行命令
  - 官网：[https://plugins.jetbrains.com/plugin/7177-file-watchers](https://plugins.jetbrains.com/plugin/7177-file-watchers)
- PlantUML integration
  - 描述：UML 建模工具，只需简单的代码就能画出复杂的 UML 类图
  - 官网：[https://plugins.jetbrains.com/plugin/7017-plantuml-integration](https://plugins.jetbrains.com/plugin/7017-plantuml-integration)
- Bytecode Editor
  - 描述：字节码编辑工具
  - 官网：[https://plugins.jetbrains.com/plugin/8461-bytecode-editor](https://plugins.jetbrains.com/plugin/8461-bytecode-editor)
- Alibaba Cloud Toolkit
  - 描述：阿里云工具集
  - 官网：[https://plugins.jetbrains.com/plugin/11386-alibaba-cloud-toolkit](https://plugins.jetbrains.com/plugin/11386-alibaba-cloud-toolkit)
- Tencent Cloud Toolkit
  - 描述：腾讯云工具集
  - 官网：[https://plugins.jetbrains.com/plugin/15653-tencent-cloud-toolkit](https://plugins.jetbrains.com/plugin/15653-tencent-cloud-toolkit)
- EduTools
  - 描述：面向教育者，允许创建、分享和加入练习
  - 官网：[https://plugins.jetbrains.com/plugin/10081-edutools](https://plugins.jetbrains.com/plugin/10081-edutools)
- IDE Features Trainer
  - 描述：IntelliJ IDEA 官方出的学习辅助插件
  - 官网：[https://plugins.jetbrains.com/plugin/8554-ide-features-trainer](https://plugins.jetbrains.com/plugin/8554-ide-features-trainer)
- JRebel Plugin
  - 描述：项目热更新，提高效率（可惜要收费）
  - 官网：[https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel-for-intellij](https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel-for-intellij)
- Key Promoter X
  - 描述：快捷键提示插件。当你执行鼠标操作时，如果该操作可被快捷键代替，会给出提示，帮助你自然形成使用快捷键的习惯，告别死记硬背。
  - 官网：[https://plugins.jetbrains.com/plugin/9792-key-promoter-x/](https://plugins.jetbrains.com/plugin/9792-key-promoter-x/)
- Translation
  - 描述：翻译插件，鼠标选中文本，点击右键即可自动翻译成多国语言。
  - 官网：[https://plugins.jetbrains.com/plugin/8579-translation/](https://plugins.jetbrains.com/plugin/8579-translation/)
- idea_seat
  - 描述：自动提醒，防止你久坐不动
  - 官网：[https://github.com/s-unscrupulous/idea_seat](https://github.com/s-unscrupulous/idea_seat)
- RestfulTool
  - 描述：辅助 web 开发的工具集
  - 官网：[https://plugins.jetbrains.com/plugin/14280-restfultool](https://plugins.jetbrains.com/plugin/14280-restfultool)
- Multirun
  - 描述：同时启动多应用
  - 官网：[https://plugins.jetbrains.com/plugin/7248-multirun](https://plugins.jetbrains.com/plugin/7248-multirun)

#### 扩展增强类

- Free Mybatis Plugin
  - 描述：MyBatis 增强插件，支持 mapper => xml 的跳转、代码生成等功能
  - 官网：[https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin](https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin)
- MyBatis Log Plugin
  - 描述：MyBatis SQL 提取和格式化输出
  - 官网：[https://plugins.jetbrains.com/plugin/10065-mybatis-log-plugin](https://plugins.jetbrains.com/plugin/10065-mybatis-log-plugin)
- Maven Helper
  - 描述：Maven 辅助插件
  - 官网：[https://plugins.jetbrains.com/plugin/7179-maven-helper](https://plugins.jetbrains.com/plugin/7179-maven-helper)
- Gradle View
  - 描述：Gradle 项目管理工具的扩展
  - 官网：[https://plugins.jetbrains.com/plugin/7150-gradle-view](https://plugins.jetbrains.com/plugin/7150-gradle-view)
- Arthas Idea
  - 描述： Arthas 命令生成插件。Arthas 是阿里开源的 Java 在线诊断工具，该插件可以自动生成 Arthas 在线 Java 代码诊断命令，不用再到官网翻文档拼命令啦！
  - 官网：[https://plugins.jetbrains.com/plugin/13581-arthas-idea/](https://plugins.jetbrains.com/plugin/13581-arthas-idea/)
- GitToolBox
  - 描述： Git 增强插件。在自带的 Git 功能之上，新增了查看 Git 状态、自动拉取代码、提交通知等功能。最好用的是可以查看到每一行代码的最近一次提交信息。
  - 官网：[https://plugins.jetbrains.com/plugin/7499-gittoolbox/](https://plugins.jetbrains.com/plugin/7499-gittoolbox/)
- BashSupport
  - 描述：支持 Bash 脚本文件的高亮和提示等
  - 官网：[https://plugins.jetbrains.com/plugin/4230-bashsupport](https://plugins.jetbrains.com/plugin/4230-bashsupport)
- Git Flow Integration
  - 描述：Git Flow 的图形界面操作
  - 官网：[https://plugins.jetbrains.com/plugin/7315-git-flow-integration](https://plugins.jetbrains.com/plugin/7315-git-flow-integration)
- Gitee
  - 描述：开源中国的码云插件
  - 官网：[https://plugins.jetbrains.com/plugin/8383-gitee](https://plugins.jetbrains.com/plugin/8383-gitee)
- Drools
  - 描述：规则引擎的扩展
  - 官网：[https://plugins.jetbrains.com/plugin/16871-drools](https://plugins.jetbrains.com/plugin/16871-drools)
- EnvFile
  - 描述：对多环境配置文件的支持
  - 官网：[https://plugins.jetbrains.com/plugin/7861-envfile](https://plugins.jetbrains.com/plugin/7861-envfile)
- Kubernetes
  - 描述：容器管理的扩展
  - 官网：[https://plugins.jetbrains.com/plugin/10485-kubernetes](https://plugins.jetbrains.com/plugin/10485-kubernetes)
- Vue.js
  - 描述：Vue.js 前端框架的扩展
  - 官网：[https://plugins.jetbrains.com/plugin/9442-vue-js](https://plugins.jetbrains.com/plugin/9442-vue-js)
- Scala
  - 描述：Scala 语言的扩展
  - 官网：[https://plugins.jetbrains.com/plugin/1347-scala](https://plugins.jetbrains.com/plugin/1347-scala)
- Zookeeper
  - 描述：Zookeeper 中间件的扩展
  - 官网：[https://plugins.jetbrains.com/plugin/7364-zookeeper](https://plugins.jetbrains.com/plugin/7364-zookeeper)
- Jms messenger
  - 描述：对 Java 消息服务的扩展
  - 官网：[https://plugins.jetbrains.com/plugin/10949-jms-messenger](https://plugins.jetbrains.com/plugin/10949-jms-messenger)
- MapStruct Support
  - 描述：对 MapStruct 对象转换的支持
  - 官网：[https://plugins.jetbrains.com/plugin/10036-mapstruct-support](https://plugins.jetbrains.com/plugin/10036-mapstruct-support)
- Big Data Tools
  - 描述：提供了 HDFS 等大数据框架的工具集
  - 官网：[https://plugins.jetbrains.com/plugin/12494-big-data-tools](https://plugins.jetbrains.com/plugin/12494-big-data-tools)
- CSV
  - 描述：支持 CSV 文件的高亮和提示等
  - 官网：[https://plugins.jetbrains.com/plugin/10037-csv](https://plugins.jetbrains.com/plugin/10037-csv)
- Ideolog
  - 描述：识别和格式化 log 日志文件
  - 官网：[https://plugins.jetbrains.com/plugin/9746-ideolog](https://plugins.jetbrains.com/plugin/9746-ideolog)
- Toml
  - 描述：支持 toml 文件的高亮和提示等
  - 官网：[https://plugins.jetbrains.com/plugin/8195-toml](https://plugins.jetbrains.com/plugin/8195-toml)
- .env files support
  - 描述：支持 .env 文件的高亮和提示等
  - 官网：[https://plugins.jetbrains.com/plugin/9525--env-files-support](https://plugins.jetbrains.com/plugin/9525--env-files-support)

### 常用软件

##### 开发相关

- JetBrains IDEA：Java 集成开发环境，凭学生邮箱可申请免费使用（[https://www.jetbrains.com/idea/）](https://www.jetbrains.com/idea/）)
- Reset Jetbrains：你懂的
- Visual Studio Code：插件化代码编辑器（[https://code.visualstudio.com/）](https://code.visualstudio.com/）)
- Sublime Text：轻量代码编辑器（[https://www.sublimetext.com/）](https://www.sublimetext.com/）)
- Navicat：数据库管理软件（[https://www.navicat.com.cn/）](https://www.navicat.com.cn/）)
- JMeter：Java 性能测试工具（[https://jmeter.apache.org/）](https://jmeter.apache.org/）)
- JVisual VM：Java 运行状态可视化工具（[https://visualvm.github.io/）](https://visualvm.github.io/）)
- XShell：SSH 连接软件（[https://www.netsarang.com/zh/xshell/）](https://www.netsarang.com/zh/xshell/）)
- XFtp：FTP 连接软件（[https://www.netsarang.com/zh/xftp/）](https://www.netsarang.com/zh/xftp/）)
- Redis Desktop Manager：Redis 可视化管理工具（[https://github.com/uglide/RedisDesktopManager）](https://github.com/uglide/RedisDesktopManager）)
- Postman：接口测试工具（[https://www.postman.com/）](https://www.postman.com/）)
- VMware：虚拟机软件（[https://www.vmware.com/）](https://www.vmware.com/）)
- Chocolatey：Windows 软件包管理器（[https://chocolatey.org/）](https://chocolatey.org/）)
- Typora：写文档软件（[https://typora.io/）](https://typora.io/）)

##### 效率

- Ditto：强大的剪切板（[https://ditto-cp.sourceforge.io/）](https://ditto-cp.sourceforge.io/）)
- uTools：插件化的效率工具（[https://u.tools/）](https://u.tools/）)
- XMind：思维导图软件（[https://www.xmind.cn/）](https://www.xmind.cn/）)
- Qdir：Windows 多窗口管理器（[https://q-dir.en.softonic.com/）](https://q-dir.en.softonic.com/）)

### 项目源码（50 套）

#### 鱼皮原创项目

- [项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd)
- SQL 数据生成器（React + Java）：[https://github.com/liyupi/sql-father-frontend-public](https://github.com/liyupi/sql-father-frontend-public)
- 结构化 SQL 语句生成器：[https://github.com/liyupi/sql-generator](https://github.com/liyupi/sql-generator)
- AI 自动回复工具（Java 项目）：[https://github.com/liyupi/yu-auto-reply](https://github.com/liyupi/yu-auto-reply)
- 表情包网站（Vue + Java）：[https://github.com/liyupi/father](https://github.com/liyupi/father)

#### 电商秒杀

- 天猫整站 J2EE：[https://how2j.cn/module/115.htm](https://how2j.cn/module/115.htm)
- 天猫整站 SSM：[https://how2j.cn/module/134.html](https://how2j.cn/module/134.html)
- 天猫整站 Springboot：[https://how2j.cn/module/156.html](https://how2j.cn/module/156.html)
- mall-learning：[https://github.com/macrozheng/mall-learningmall](https://github.com/macrozheng/mall-learningmall) （学习教程，架构、业务、技术要点全方位解析）
- SpringBoot 电商商城系统 Mall4j：[https://github.com/gz-yami/mall4j](https://github.com/gz-yami/mall4j)
- SpringBoot 完整电商系统 Mall：[https://github.com/macrozheng/mall](https://github.com/macrozheng/mall) （包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现）
- newbee-mall：[https://github.com/newbee-ltd/newbee-mall](https://github.com/newbee-ltd/newbee-mall) （一套电商系统，包括 newbee-mall 商城系统及 newbee-mall-admin 商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发）
- paascloud-master：[https://github.com/paascloud/paascloud-master](https://github.com/paascloud/paascloud-master) （基于 spring cloud + vue + oAuth2.0，前后端分离商城系统）
- mall-swarm：[https://github.com/macrozheng/mall-swarm](https://github.com/macrozheng/mall-swarm) （一套微服务商城系统，采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台方便快速搭建系统）
- onemall：[https://github.com/YunaiV/onemall](https://github.com/YunaiV/onemall) （mall 商城，基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba）
- litemall：[https://github.com/linlinjava/litemall](https://github.com/linlinjava/litemall) （又一个小商城，litemall = Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端）
- xmall：[https://github.com/Exrick/xmall](https://github.com/Exrick/xmall) （基于 SOA 架构的分布式电商购物商城 前后端分离 前台商城:Vue 全家桶 后台管理系统）
- miaosha：[https://github.com/qiurunze123/miaosha](https://github.com/qiurunze123/miaosha) （秒杀系统设计与实现）
- SecKill：[https://github.com/hfbin/Seckill](https://github.com/hfbin/Seckill) （基于 SpringBoot+Mybatis+Redis+RabbitMQ 秒杀系统）

#### 博客论坛

- [Mblog](https://github.com/langhsu/mblog)：开源 Java 博客系统
- [halo](https://github.com/halo-dev/halo)：一个优秀的开源博客发布应用
- [forum-java](https://github.com/Qbian61/forum-java)：一款用 Java（spring boot） 实现的现代化社区（论坛/问答/BBS/社交网络/博客）系统平台
- [vhr](https://github.com/lenve/vhr)：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。
- [favorites-web](https://github.com/cloudfavorites/favorites-web):云收藏 Spring Boot 2.X 开源项目。云收藏是一个使用 Spring Boot 构建的开源网站，可以让用户在线随时随地收藏的一个网站，在网站上分类整理收藏的网站或者文章。
- [community](https://github.com/codedrinker/community)：码问，开源论坛、问答系统，现有功能提问、回复、通知、最新、最热、消除零回复功能。技术栈 Spring、Spring Boot、MyBatis、MySQL/H2、Bootstrap
- [NiterForum](https://github.com/yourkevin/NiterForum)：尼特社区-NiterForum-一个论坛/社区程序。后端 Springboot/MyBatis/Maven/MySQL，前端 Thymeleaf/Layui。可供初学者，学习、交流使用。
- [VBlog](https://github.com/lenve/VBlog)：V 部落，Vue+SpringBoot 实现的多用户博客管理平台!
- [NiceFish](https://github.com/damoqiongqiu/NiceFish)：SpringBoot/SpringCloud 前后端分离项目
- [My-Blog](https://github.com/ZHENFENG13/My-Blog)： My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验。
- [My-Blog-layui](https://github.com/ZHENFENG13/My-Blog-layui)：layui 版本的 My-Blog : A simple & beautiful blogging system implemented with spring-boot & layui & thymeleaf & mybatis My Blog 是由  SpringBoot + Layui + Mybatis + Thymeleaf 等技术实现的 Java   博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验
- [symphony](https://github.com/88250/symphony)：Java 实现的现代化社区

#### 管理系统

- [Spring-Cloud-Admin](https://github.com/wxiaoqi/Spring-Cloud-Admin)：Cloud-Admin 是国内首个基于 Spring Cloud 微服务化开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关 API 管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。核心技术采用 Spring Boot2 以及 Spring Cloud Gateway 相关核心组件，前端采用 vue-element-admin 组件。
- [bootshiro](https://github.com/tomsun28/bootshiro)：基于 springboot+shiro+jwt 的资源无状态认证权限管理系统后端
- [悟空 CRM](https://github.com/72crm/72crm-java)：基于 jfinal+vue+ElementUI 的前后端分离 CRM 系统
- [EL-ADMIN](https://github.com/elunez/eladmin)：基于 SpringBoot 的后台管理系统
- [pig](https://gitee.com/log4j/pig)：基于 Spring Boot 2.2、 Spring Cloud Hoxton & Alibaba、 OAuth2 的 RBAC 权限管理系统。
- [FEBS-Shiro](https://github.com/wuyouzhuguli/FEBS-Shiro)：Spring Boot 2.1.3，Shiro1.4.0 & Layui 2.5.4 权限管理系统。
- [Spring Boot-Shiro-Vue](https://github.com/Heeexy/SpringBoot-Shiro-Vue)：基于 Spring Boot-Shiro-Vue 的权限管理
- [studentmanager](https://github.com/ZeroWdd/studentmanager)：基于 springboot+mybatis 学生管理系统
- [jshERP](https://github.com/jishenghua/jshERP)：华夏 ERP 基于 SpringBoot 框架和 SaaS 模式，立志为中小企业提供开源好用的 ERP 软件，目前专注进销存+财务功能。主要模块有零售管理、采购管理、销售管理、仓库管理、财务管理、报表查询、系统管理等。支持预付款、收入支出、仓库调拨、组装拆卸、订单等特色功能。拥有库存状况、出入库统计等报表。同时对角色和权限进行了细致全面控制，精确到每个按钮和菜单。
- [HotelSystem](https://github.com/misterchaos/HotelSystem)：酒店管理系统 Java,tomcat,mysql,servlet,jsp 实现，没有使用任何框架

#### 开发平台

- [open-capacity-platform](https://github.com/2014shijina2014/open-capacity-platform)：微服务能力开发平台
- [jeecg-boot](https://github.com/zhangdaiscott/jeecg-boot)：JeecgBoot 是一款基于 BPM 的低代码平台！前后端分离架构 SpringBoot 2.x，SpringCloud，Ant  Design&Vue，Mybatis-plus，Shiro，JWT，支持微服务。强大的代码生成器让前后端代码一键生成，实现低代码开发！

#### 其他

- [学之思在线考试系统](https://github.com/mindskip/xzs)：一款 java + vue 的前后端分离的考试系统
- [PassJava-Platform](https://github.com/Jackson0714/PassJava-Platform)：一款面试刷题的 Spring Cloud 开源系统
- [kkFileView](https://github.com/kekingcn/kkFileView)：使用 spring boot 打造文件文档在线预览项目
- [dynamic-datasource](https://github.com/baomidou/dynamic-datasource-spring-boot-starter)：一个基于 springboot 的快速集成多数据源的启动器
- [moti-cloud](https://github.com/373675032/moti-cloud)：莫提网盘，基于 SpringBoot+MyBatis+ThymeLeaf+BootStrap，适合初学者
- [threadandjuc](https://github.com/qiurunze123/threadandjuc)：three-high-import 高可用\高可靠\高性能，三高多线程导入系统（该项目意义为理论贯通)
- [proxyee-down](https://github.com/proxyee-down-org/proxyee-down)：http 下载工具，基于 http 代理，支持多连接分块下载
- [hosp_order](https://github.com/sfturing/hosp_order)：医院预约挂号系统，基于 SSM 框架
- [趋势投资 SpringCloud](https://how2j.cn/module/170.html)
- [DiyTomcat](https://how2j.cn/module/176.html)

## 阶段 6：Java 高级

### 目标

不满足于能做，而是通过更 **深入** 和 **广泛** 的学习，实现高质量的代码和更优秀的架构，培养解决问题的能力。

已经到了这个阶段，建议除了看完成的教程外，平时多自主搜索信息去学习，积少成多。比如遇到了一个不了解的名词，可以去网上搜一下，感兴趣的话再进行下一步的学习。

### 🌖 并发编程（21 天）

对 Java 后端开发程序员来说，懂得如何利用有限的系统资源来提高系统的性能是很重要的，也是大厂面试考察的重点，因此并发编程（尤其是 Java 并发包的使用）这块的知识很重要。

把它放到高级，是因为在学并发编程前，需要有一定的编程经验、了解一定的操作系统知识。

#### 知识

- 线程和进程
- 线程状态
- 并行和并发
- 同步和异步
- Synchronized
- Volatile 关键字
- Lock 锁
- 死锁
- 可重入锁
- 线程安全
- 线程池
- JUC 的使用
- AQS
- Fork Join
- CAS

#### 学习建议

并发编程入门不难，依然是 **先学会使用** 基础的 Java 并发包， 再通过大量地实践和测试，了解一些原理，才能真正掌握何时使用、如何更合理地使用并发编程。而不是张口闭口多线程，上天入地高并发。

#### 经典面试题

1. volatile 关键字的作用
2. 使用线程池有哪些好处？
3. 线程池参数如何设置？
4. 什么是线程安全问题，如何解决？
5. 介绍 synchronized 的锁升级机制
6. CopyOnWriteArrayList 适用于哪种场景？

#### 资源

- 项目实战
  - [项目实战 - 鱼皮原创项目教程系列](https://yuyuanweb.feishu.cn/wiki/SePYwTc9tipQiCktw7Uc7kujnCd) 中的伙伴匹配系统、智能 BI 项目、OJ 判题系统都运用了并发编程解决实际问题，推荐学习
- 视频
  - ⭐【尚硅谷】大厂必备技术之 JUC 并发编程 2021 最新版：[https://www.bilibili.com/video/BV1Kw411Z7dF](https://www.bilibili.com/video/BV1Kw411Z7dF) （特点是短、精、新）
  - 黑马程序员全面深入学习 Java 并发编程：[https://www.bilibili.com/video/BV16J411h7Rd](https://www.bilibili.com/video/BV16J411h7Rd) （讲的很细、全面深入）
- 书籍
  - ⭐《Java 并发编程实战》（国外的经典）
  - ⭐《Java 并发编程艺术》（国人写的，理论思想内容较多，有时间建议反复看）
  - ⭐《图解 Java 多线程设计模式》：[https://www.aliyundrive.com/s/MBKzUxWWBbe](https://www.aliyundrive.com/s/MBKzUxWWBbe) 提取码: 9gc7（如果已经学了 Java 并发编程，可以额外学习，这里的设计模式）
- 项目
  - ⭐ Java 并发知识点总结：[https://github.com/CL0610/Java-concurrency](https://github.com/CL0610/Java-concurrency)

### 🌖 JVM（30 天）

想要深入理解 Java，探秘 Java 跨平台的奥秘，一定要了解 Java 底层的虚拟机技术。

了解虚拟机、掌握虚拟机性能调优方法，有助于你写出更高性能、资源占用更小的优质程序。

在学习 JVM 的过程中，也能学到很多精妙的设计，开拓思路。

#### 知识

- JVM 内存结构
- JVM 生命周期
- 主流虚拟机
- Java 代码执行流程
- 类加载
  - 类加载器
  - 类加载过程
  - 双亲委派机制
- 垃圾回收
  - 垃圾回收器
  - 垃圾回收策略
  - 垃圾回收算法
  - StopTheWorld
- 字节码
- 内存分配和回收
- JVM 性能调优
  - 性能分析方法
  - 常用工具
  - 参数设置
- Java 探针
- 线上故障分析

#### 学习建议

JVM 的知识略显枯燥，建议先看视频，有实操的地方一定要实操！自己多去分析。

第一遍不理解没有关系，可以再看书来巩固，想要真正学好，《深入理解 Java 虚拟机（第三版）》一定要读。

如果只是为了通过面试可以直接看更精简的视频，比如狂神的。

#### 经典面试题

1. 介绍 JVM 的内存模型？
2. JVM 内存为什么要分代？
3. 介绍一次完整的 GC 流程
4. 介绍双亲委派模型，为什么需要它？

#### 资源

- 视频
  - ⭐ 尚硅谷宋红康 - JVM 全套教程详解：[https://www.bilibili.com/video/BV1PJ411n7xZ](https://www.bilibili.com/video/BV1PJ411n7xZ) （讲得相当全面！附有实操）
  - 【狂神说 Java】JVM 快速入门篇：[https://www.bilibili.com/video/BV1iJ411d7jS](https://www.bilibili.com/video/BV1iJ411d7jS) （讲得有点浅，但都是面试重点，时间紧的小伙伴可以直接看这个）
- 书籍
  - ⭐《深入理解 Java 虚拟机（第三版）》（有理论有实践，内容丰富，不可多得的 JVM 学习神书，就是有点废头发）
- 项目
  - ⭐ Java 虚拟机底层原理知识总结：[https://github.com/doocs/jvm](https://github.com/doocs/jvm)
- 实战
  - 阿里云 JVM 实战：[https://developer.aliyun.com/graph/java/point/64](https://developer.aliyun.com/graph/java/point/64)
- 工具
  - Arthas 开源 Java 诊断工具：[https://github.com/alibaba/arthas](https://github.com/alibaba/arthas)

### 🌖 Java 高级知识

> 通过阅读文章了解即可

#### 知识

- 动态代理
- Java 探针
- 字节码，参考：[https://github.com/fuzhengwei/itstack-demo-bytecode](https://github.com/fuzhengwei/itstack-demo-bytecode)
- UnSafe 类
- 协程 / 纤程

### 架构设计

#### 🌖 分布式

- 分布式理论
  - CAP
  - BASE
- 分布式缓存
  - Redis
  - Memcached
  - Etcd
- 一致性算法
  - Raft
  - Paxos
  - 一致性哈希
- 分布式事务
  - 解决方案
    - 2PC
    - 3PC
    - TCC
    - 本地消息表
    - MQ 事务消息
    - 最大努力通知
  - LCN 分布式事务框架：[https://github.com/codingapi/tx-lcn](https://github.com/codingapi/tx-lcn)
- 分布式 id 生成
  - Leaf 分布式 id 生成服务：[https://github.com/Meituan-Dianping/Leaf](https://github.com/Meituan-Dianping/Leaf)
- 分布式任务调度
  - XXL-JOB 调度平台：[https://www.xuxueli.com/xxl-job/](https://www.xuxueli.com/xxl-job/)
  - elastic-job：[https://gitee.com/elasticjob/elastic-job](https://gitee.com/elasticjob/elastic-job)
- 分布式服务调用
  - trpc
- 分布式存储
  - HDFS
  - Ceph
- 分布式数据库
  - TiDB
  - OceanBase
- 分布式文件系统
  - HDFS
- 分布式协调
  - Zookeeper
- 分布式监控
  - Prometheus
  - Zabbix
- 分布式消息队列
  - RabbitMQ
  - Kafka
  - Apache Pulsar
- 分布式日志收集
  - Elastic Stack
  - Loki
- 分布式搜索引擎
  - Elasticsearch
- 分布式链路追踪
  - Apache SkyWalking
- 分布式配置中心
  - Apollo
  - Nacos

#### 🌗 高可用

- 限流
- 降级熔断
- 冷备
- 双机热备
- 同城双活
- 异地双活
- 异地多活
- 容灾备份

#### 🌗 高并发

- 数据库
  - 分库分表
    - MyCat 中间件
    - Apache ShardingSphere 中间件
  - 读写分离
- 缓存
  - 缓存雪崩
  - 缓存击穿
  - 缓存穿透
- 负载均衡
  - 负载均衡算法
  - 软硬件负载均衡（2、3、4、7 层）

#### 🌘 服务网格

服务网格用来描述组成应用程序的微服务网络以及它们之间的交互。服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理，常见的需求包括服务发现、负载均衡、故障恢复、度量和监控等。

##### 知识

- Istio
  - 流量管理
  - 安全性
  - 可观测性
- Envoy（开源的边缘和服务代理）

##### 资源

- 资料大全：[https://www.servicemesher.com/awesome-servicemesh/](https://www.servicemesher.com/awesome-servicemesh/)
- istio 官方文档：[https://preliminary.istio.io/latest/zh](https://preliminary.istio.io/latest/zh)
- istio 视频教程：[https://www.bilibili.com/video/BV1Lf4y1x7j8](https://www.bilibili.com/video/BV1Lf4y1x7j8)
- 在线体验 istio：[https://katacoda.com/courses/istio/](https://katacoda.com/courses/istio/)

#### 🌘 DDD 领域驱动设计

将数据、业务流程抽象成容易理解的领域模型，通过用代码实现领域模型，来组成完整的业务系统。

##### 知识

- DDD 的优势
- DDD 的适用场景
- DDD 核心概念
  - 领域模型分类：失血、贫血、充血、涨血
  - 子域划分：核心域、通用域、支撑域
  - 限界上下文
  - 实体和值对象
  - 聚合设计
  - 领域事件
- DDD 实践

##### 资源

- DDD 入门：[https://juejin.cn/post/7004002483601145863](https://juejin.cn/post/7004002483601145863)
- DDD 编码实践：[https://juejin.cn/post/6844903903104860174](https://juejin.cn/post/6844903903104860174)
- DDD 实践教程：[https://www.bilibili.com/video/BV1Y341167Xp](https://www.bilibili.com/video/BV1Y341167Xp)

#### 🌘 其他

- Sidecar
- Serverless
- 云原生

#### 学习建议

架构设计的学习没有顶点，多看文章，思考每种设计的优缺点和适用场景，有机会的话在企业中实践即可。

还在学校、或者初入这行的同学切记，千万不要一味地去背诵架构设计的八股文。你可以背，但是这一块的知识只有结合具体的项目才有意义，所以要多做项目去实践设计的合理性，而不是什么设计都咔咔往系统里去怼。比如面试问到分布式事务，能结合自己项目中用分布式事务解决问题的经验去回答最好。

### 🌘 其他技术

- 热数据探测技术：京东 HotKey
- 数据库流水订阅：阿里 Canal
- 监控告警
- 应用安全
- 故障演练
- 流量回放

## 阶段 7：Java 求职

### 目标

找到好工作

### 建议

1. 尽早做规划，可以通过大厂招聘官网的岗位描述来了解岗位的要求
2. 雕琢一份优秀的简历，推荐阅读：[https://mp.weixin.qq.com/s/wfabzdpOPdq89faFFpZ4NA](https://mp.weixin.qq.com/s/wfabzdpOPdq89faFFpZ4NA)
3. 多读面经，坚持刷算法
4. 多参与面试，持续复盘总结

### 资源

#### 校招岗位

- 阿里 Java 开发：[https://campus.alibaba.com/position.htm?refno=12699](https://campus.alibaba.com/position.htm?refno=12699)
- 腾讯后台开发：[https://join.qq.com/post_detail.html?pid=1&id=101&tid=2](https://join.qq.com/post_detail.html?pid=1&id=101&tid=2)
- 腾讯全栈开发：[https://join.qq.com/post_detail.html?pid=1&id=137&tid=2](https://join.qq.com/post_detail.html?pid=1&id=137&tid=2)
- 腾讯运营开发：[https://join.qq.com/post_detail.html?pid=1&id=105&tid=2](https://join.qq.com/post_detail.html?pid=1&id=105&tid=2)
- 美团后端开发：[https://campus.meituan.com/jobs?jobFamily=1&jobId=4005&jobType=1&pageNo=2](https://campus.meituan.com/jobs?jobFamily=1&jobId=4005&jobType=1&pageNo=2)
- 华为软件开发：[https://career.huawei.com/reccampportal/portal5/campus-recruitment-detail.html?jobId=176044](https://career.huawei.com/reccampportal/portal5/campus-recruitment-detail.html?jobId=176044)

#### 社招岗位

- 阿里社招：[https://job.alibaba.com/zhaopin/positionList.htm](https://job.alibaba.com/zhaopin/positionList.htm)
- 腾讯社招：[https://careers.tencent.com/search.html](https://careers.tencent.com/search.html)

#### 实习

- 实习僧：[https://www.shixiseng.com/](https://www.shixiseng.com/)

#### 鱼皮经历

- 从 0 开始的编程学习进大厂经历
  - ⭐ 我学计算机的四年，共勉：[https://mp.weixin.qq.com/s/Nc7Ee2UyrPg6hGseQUCzeg](https://mp.weixin.qq.com/s/Nc7Ee2UyrPg6hGseQUCzeg)
- 实习经历
  - ⭐ 我的第一份实习：[https://mp.weixin.qq.com/s/SwGiRzyTkCOOCUXfXPR1Pw](https://mp.weixin.qq.com/s/SwGiRzyTkCOOCUXfXPR1Pw)
  - ⭐ 我的第二份实习，字节跳动：[https://mp.weixin.qq.com/s/3q-YIfuZBjPjSnamNwOraw](https://mp.weixin.qq.com/s/3q-YIfuZBjPjSnamNwOraw)

#### 知识总结

- ⭐ JavaGuide：[https://snailclimb.gitee.io/javaguide/#/](https://snailclimb.gitee.io/javaguide/#/)
- ⭐ CS-Notes：[http://www.cyc2018.xyz/](http://www.cyc2018.xyz/)
- 阿里 Java 技术图谱：[https://developer.aliyun.com/graph/java](https://developer.aliyun.com/graph/java)

#### 面经

编程导航面经汇总：[https://yuyuanweb.feishu.cn/wiki/PLHrwcEPCiJcxXk7Ki4csRoJn2f](https://yuyuanweb.feishu.cn/wiki/PLHrwcEPCiJcxXk7Ki4csRoJn2f)

#### 面试题解

编程导航精选面试题汇总：[https://yuyuanweb.feishu.cn/wiki/CmFywXs0Oi0MS9kU3yocJugFn2e](https://yuyuanweb.feishu.cn/wiki/CmFywXs0Oi0MS9kU3yocJugFn2e)

#### 视频

- ⭐ 尚硅谷 2021 逆袭版 Java 面试题第三季：[https://www.bilibili.com/video/BV1Hy4y1B78T](https://www.bilibili.com/video/BV1Hy4y1B78T)
- ⭐ 阿里大佬透彻讲解 Java 面试 500 道必考题：[https://www.bilibili.com/video/BV1yU4y1J7Bb](https://www.bilibili.com/video/BV1yU4y1J7Bb)

## 阶段 8：持续学习

### 目标

持续追求技术的深度和广度，培养自己的 **核心竞争力** 和 **不可替代性** ，学无止境！

### 学习建议

自主学习，自主搜索教程，多看书，多阅读技术博客，多实践。

### 学习方向

#### 框架源码

- Spring
- SpringBoot
- SpringMVC
- MyBatis
- Netty
- Dubbo
- SpringCloud

#### 计算机原理

- 《算法导论》：[https://www.bilibili.com/video/av48922404](https://www.bilibili.com/video/av48922404)
- 《现代操作系统》：[https://www.bilibili.com/video/av9555596](https://www.bilibili.com/video/av9555596)
- 《深入理解计算机系统》：[https://www.bilibili.com/video/av31289365](https://www.bilibili.com/video/av31289365)
- 《编译原理》： [https://www.bilibili.com/video/av17649289](https://www.bilibili.com/video/av17649289)
- 《计算机网络：自顶向下方法》：[https://www.bilibili.com/video/BV1JV411t7ow](https://www.bilibili.com/video/BV1JV411t7ow)
- 《计算机程序的构造和解释》：[https://www.bilibili.com/video/av8515129](https://www.bilibili.com/video/av8515129)
- 《数据库系统概论》：[https://www.bilibili.com/video/BV1G54y1d7ZK](https://www.bilibili.com/video/BV1G54y1d7ZK)

#### 数据库 / 中间件 / 分布式

- 数据库
  - MySQL
  - PostgreSQL
- 缓存
  - Redis
- 队列
  - Apache Kafka
  - Apache Pulsar
- 搜索引擎
  - Elastic Stack
    - Elasticsearch
    - logstash
    - kibana
    - beats
- 容器
  - Docker
  - K8S

#### 解决方案

- 广告系统
- 电商系统
- 搜索系统
- 支付转账
- 游戏后台
- 即时通讯
- 社交系统
- CMS 系统
- ERP 系统
- OA 系统
- 代码生成
- 权限管理
- 秒杀活动

#### 架构设计

同阶段 6 架构设计部分

#### 大数据

- 5V 特点
- Hadoop
- HDFS
- MapReduce
- Spark
- Flink
- Storm
- Hive
- HBase
- Druid
- Kylin
- Pig
- Mahout

#### 前沿技术

- 云原生：[https://www.jianshu.com/p/a37baa7c3eff](https://www.jianshu.com/p/a37baa7c3eff)
  - Quasar Framework：[http://www.quasarchs.com/](http://www.quasarchs.com/)
- 服务网格：[https://www.redhat.com/zh/topics/microservices/what-is-a-service-mesh](https://www.redhat.com/zh/topics/microservices/what-is-a-service-mesh)
  - istio：[https://github.com/istio/istio](https://github.com/istio/istio)
- GraalVM：[https://juejin.cn/post/6850418120570437646](https://juejin.cn/post/6850418120570437646) （高性能的通用虚拟机）
  - 官网：[https://www.graalvm.org/](https://www.graalvm.org/)
- ZGC：[https://juejin.cn/post/6859276583656980493](https://juejin.cn/post/6859276583656980493) （新一代垃圾回收器）
  - 官网：[http://openjdk.java.net/projects/zgc/](http://openjdk.java.net/projects/zgc/)

### 自学 Java 专题资源

- ⭐ GitHub Java 专区：[https://github.com/topics/java](https://github.com/topics/java)
- ⭐ GitHub Java 合集：[https://github.com/akullpp/awesome-java](https://github.com/akullpp/awesome-java)
- StackOverflow：[https://stackoverflow.com/questions/tagged/java](https://stackoverflow.com/questions/tagged/java) （解决问题必备）
- ⭐ 掘金 Java 专区：[https://juejin.cn/tag/Java](https://juejin.cn/tag/Java)
- 美团技术团队：[https://tech.meituan.com/](https://tech.meituan.com/)
- 阿里技术团队：[https://102.alibaba.com/tech/list/](https://102.alibaba.com/tech/list/)
- 有赞技术团队：[https://tech.youzan.com/tag/back-end/](https://tech.youzan.com/tag/back-end/)
]]></content:encoded>
            <author>295563358@qq.com (Yoran Wu)</author>
        </item>
    </channel>
</rss>