# 内置组件

## 参考资料

- [Transition](https://cn.vuejs.org/api/built-in-components.html#transition)
- [TransitionGroup](https://cn.vuejs.org/api/built-in-components.html#transitiongroup)
- [KeepAlive](https://cn.vuejs.org/api/built-in-components.html#keepalive)
- [Teleport](https://cn.vuejs.org/api/built-in-components.html#teleport)
- [Suspense](https://cn.vuejs.org/api/built-in-components.html#suspense)

## Transition & TransitionGroup

它的使用没有比官网更加的清晰了。

```html
<Transition
  name="fade"
  @before-enter="beforeEnter"
  @after-enter="afterEnter"
  @before-leave="beforeLeave"
  @after-leave="afterLeave"
>
</Transition>
```

```css
/* 进入阶段：从隐藏到显示 */
.fade-enter-from {
  opacity: 0;
} /* 初始状态 */
.fade-enter-to {
  opacity: 1;
} /* 目标状态 */

.fade-enter-active {
  transition: opacity 1s;
} /* 过渡动画 */

/* 离开阶段：从显示到隐藏 */
.fade-leave-from {
  opacity: 1;
} /* 初始状态 */

.fade-leave-to {
  opacity: 0;
} /* 目标状态 */

.fade-leave-active {
  transition: opacity 0.3s;
}
```

如果没有`name`的话，就默认以`v-`作为 class 的前缀。

## 生命周期如下

![](../../assets/posts/Pasted%20image%2020250814174646.png)

## Transition 和 TransitionGroup 的区别

```html
<TransitionGroup name="fadeTransform">
  <div v-for="item in list" :key="item">{{ item }}</div>
</TransitionGroup>
```

`TransitionGroup`可以作用于每一个 div，而`Transition`只能作用于一整个 Div。

## Teleport

### 父子组件使用 Teleport 的问题

存在无法正确插入到引入的父组件的位置上面，警告信息如下：

**_[Vue warn]: Failed to locate Teleport target with selector "#body". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree._**

这个是由于 vue3 的生命周期，父组件的 onMounted 在子组件渲染之后。所以我们只需要确保父组件上面要挂载的组件在`Teleport`中组件之前渲染就可以了。

```html
<Teleport to="#body" v-if="hasTargetElement">
  <div>teleport 组件</div>
</Teleport>
```

```js
const hasTargetElement = ref(false);
onMounted(() => {
  hasTargetElement.value = !!document.querySelector("#body");
});
```

上面可以处理在同一个生命周期之中，把`onMounted`换成`nextTick`也是一样的。

但是如果想要挂载的 dom 和当前的`Teleport` 不在同一个生命周期的话，那么就需要监听目标 Dom 什么时候渲染的，方法如下：

```js
const targetElement = ref(null);
// 检查目标元素的辅助函数
function checkTargetElement() {
  const element = document.querySelector("#body");
  targetElement.value = element;
}
watchEffect(() => {
  const timer = setTimeout(() => {
    checkTargetElement();
  }, 100);
  return () => {
    clearTimeout(timer);
  };
});

const showTeleport = computed(() => {
  return !!targetElement.value;
});
```

**_setTimeout 可以换成 MutationObserver 监听目标元素的变化或者 inject ，等等_**
