# 内置指令

## 参考资料

- [内置指令](https://cn.vuejs.org/api/built-in-directives.html)

## v-text & 插值语法

> 插值语法就是 `{{ message }}`

v-text 相比插值语法最大的作用就是语义化更加的好，理论上它的性能可能要比插值语法好，不过可以忽略不计。

当我们在`v-text`的元素中添加子节点，这个子节点包括`textContent`或者其他节点类型的话，会在编译时就报错，报错信息如下：

![[Pasted image 20250813143743.png]]

这个是从语法层面的规范，利好团队协作，然后其他开发看一眼就知道这个 dom 的意图，不要往它子节点添加东西。

## v-html 和 xss

### 基础用法

```js
<template>
	<div v-html='richText'></div>
</template>
<script setup>
const richText = ref(`
	<div style="font-family: Arial, sans-serif;">
		<h1 style="color: #333;">这是富文本标题</h1>
		<p>这是一段<strong>加粗文本</strong>和<em>斜体文本</em>。</p>
		<ul style="list-style-type: circle;">
			<li>列表项 1</li>
			<li>列表项 2</li>
		</ul>
		<p>
			<a href="https://wyc7758775.github.io/yoran-secret/" style="color: blue;">
				这是一个链接
			</a>
		</p>
	</div>
`);
</script>
```

和`v-text` 最大的不同，就是不转移标签`<`这些，直接渲染。所以这也带来了一个问题，那么就是 [[xss]] 攻击。

### xss 攻击

```HTML
<!-- v-html 面对图片的攻击 -->
<button @click="changeHtml">开始攻击</button>
<div v-if="isAttack" v-html="xssHtml"></div>
```

```js
// xss 攻击测试
const xssHtml = ref(
  `<img src="x" onerror="alert('XSS攻击成功!');window.location.href='https://wwww.baidu.com'">`
);
const isAttack = ref(false);
const changeHtml = () => {
  isAttack.value = true;
};
```

点击"开始攻击"之后，就会触发`alert`以及后面的页面跳转。如果这个图片公共显示的，那么每一个用户打开这页面都会出发 `alert`，然后就跳转到什么乱七八糟的地址上面去。

而如果使用插值指令的话, 就会直接显示出来，因为插值指令会自动转义。

```html
<button @click="changeHtml">开始攻击</button>
<div v-if="isAttack2">{{ xssHtml }}</div>
```

![[Screenshot 2025-08-13 at 16.50.23.png]]

上面的例子不足够贴近实际业务，它通常出现在评论区中。

```html
<<textarea v-model="xssRichTextType" />
<button @click="saveRichText">保存</button>
<div v-html="xssRichText"></div>
```

`textarea`作为输入框，而下面的`xssRichText`作为评论区渲染的插值。JS 如下：

```js
const xssRichText = ref("请输出内容");
const saveRichText = () => {
  const rawHTML = document.getElementById("rich").innerHTML;
  xssRichText.value = xssRichTextType.value;
};
```

随后在输入框 中输入“\<img src="x" onerror="alert('XSS 攻击成功!') /\>”，点击保存按钮，会立即触发`alert` 时间，造成[[xss]]攻击。

> 如果将 textarea 替换成`<div contenteditable> </div>` 构成了多文本输入框的时候，它也是会自动转义标签的，这个是基于浏览器自身的安全策略。[[tiptap]] 这个第三方库的核心输入区域也是基于 HTML 的 contenteditable 属性实现的。所以如果是基于输入框中输入的文本是不会造成 xss 攻击的，所以只需要后端对于他们数据进行防范即可。

基于 html 的 contenteditable 属性的值为“&lt;imgsrc=\"x\" onerror=\"alert('XSS 触发成功')\"&gt;”。

**&lt; 转化为 \&lt;**

### 如何防范[[xss]]攻击

应对 xss 攻击，后台比前端更加的合适，这个是基于逻辑内聚的工程角度思考的。因为前端可以只需要面对 xss 攻击，但是后台还需要面对其他各种安全问题，所以集中在后台处理是更加好的选择。双端都处理的话，无疑会造成的资源的浪费。

前端的话，可以使用`import DOMPurify from "dompurify";` 来解决。使用方式如下：

```js
const sanitizedHtml = computed(() => DOMPurify.sanitize(xssRichText.value));
```

## v-if & v-else & v-else-if 和 v-show

### `display: none` 和 `visibility: hidden`

v-show 为 false 本质就是`display: none`。一般是用来和`v-if`来进行对比，`v-if`是一种惰性指令，如初始化为 false 的时候，不会渲染出来，而 `v-show` 为 false 的时候，组件依然会被渲染，只是不展示而已。

`visibility: hidden`属性还没有内置的指令。还是它任何值得一提，它也会隐藏组件，但是依旧保留原本的位置。

频繁切换显示/隐藏时，优先考虑  `v-show`（需完全移除布局）或  `opacity: 0`（需保留交互）。

> opacity: 0 会保留布局占位，和 visibility 一样。

## v-once & v-memo

`v-once` 等同于 `v-memo='[]'`。`[]` 意味着没有因为任何元素改变。所以一旦初始化渲染之后，就不再改变, 响应式变量的改变也不会引起界面的变化。

### 基本使用

```html
<button @click="updateItem">更新数据</button>
<ul>
  <li
    v-for="(item, index) in list"
    :key="item.id"
    v-memo="[index === 0 && item.name === '马总']"
  >
    <span>id:</span>{{ item.id }} ----<span>nickname:</span>{{ item.name }}
  </li>
</ul>
```

```js
const list = ref(getData());
list.value.unshift({
  id: 1,
  name: "马总",
});
let index = 0;
const updateItem = () => {
  list.value[index].name = "测试修改";
  index++;
};
```

`v-memo="[index === 0 && item.name === '马总']"`的意思是 index 等于 0，并且 item.name 初始化的时候为‘马总’的时候值的时候，只要有变化，这个对应的 DOM 就会经过 diff 算法，然后渲染界面。

也就是说，不需要判断`index === 0 && item.name === '马总'` 这个是为 true 还是为 false，只要有了变化就会经过 diff 的算法。以下几种情况都会渲染：

- **初始非“马总” → 改为“马总”​**, 触发重新渲染
- **初始非“马总” → 仍非“马总”​**, 复用缓存
- **初始是“马总” → 改为其他值 ​**，触发重新渲染

还有其他的一些使用的方法：
`v-memo='[product.id, product.price]'`, 这是比较常用的方式，表示只要 product.id 和 product.price 任意一个值有了变化就触发重新渲染。

`v-memo` 指令会根据指令的依赖数组来判断是否需要对比虚拟 DOM。如果依赖数组中的值没有发生变化，Vue 会直接跳过对比，从而避免不必要的 DOM 操作。所以对于性能优化而言，它的作用在于减少 diff 算法哪一部分。

> [[vapor]]出来之后，v-memo 的使用场景可以更加的少，需要更加新的精细化。

### 业务场景

可以具体看`v-memo-business-demo.vue`这个文件。

## v-slot

### 基本使用

#### 默认插槽

```html
<SlotChild>
  <template #default>
    <div>
      <h3>1.1 带 template 默认插槽的内容1</h3>
    </div>
  </template>
</SlotChild>
```

`SlotChild.vue`

```html
<div>
  slot-child 默认插槽
  <slot :data="data"></slot>
</div>
```

渲染如下：
![[Pasted image 20250813204503.png]]

#### 具名插槽

```html
<SlotChild>
  <template v-slot:header>
    <div>
      <h3>2.1 带 template 具名插槽的内容1</h3>
    </div>
  </template>
</SlotChild>
```

`v-slot:header` = `#header`

支持动态插槽名，如下：

```html
<SlotChild>
  <template v-slot:[dynamicSlotName]>
    <div>
      <h3>2.1 带 template 具名插槽的内容1</h3>
    </div>
  </template>
</SlotChild>
```

#### 作用域插槽

```html
<SlotChild v-slot="{ data }">
  <p>{{ data.nickName }}</p>
  <p>{{ data.age }}</p>
</SlotChild>
```

或者如下写法：

```html
<template>
  <Child>
    <!-- 作用域插槽：v-slot 可简写为 # -->
    <template #default="scope">
      <p>用户：{{ scope.data.nickName }}</p>
      <p>消息：{{ scope.data.age }}</p>
    </template>
  </Child>
</template>
```

SlotChild.vue 中如下：

```html
<slot :data="data"></slot>
<script setup>
  const data = ref({
    nickName: "yoran",
    age: 18,
  });
</script>
```

也可以用在具名插槽中：

```html
<slot name="header" :data="headerData"></slot>
```

使用的时候如下：

```html
<SlotChild>
  <template #header="headerScope">
    <h1>{{ headerScope.data.title }}</h1>
  </template>
</SlotChild>
```

## v-cloak

**_本质：通过 CSS 隐藏带有  `v-cloak`属性的元素（例如  `[v-cloak] { display: none; }`）。_**

用于判断当前组件是否依旧渲染完毕了，渲染完毕再漏出来，避免界面出现如下的样子：

```
<div>
	{{ msg }}
</div>
```

让用户直接看到插值指令。

现在基本已经不需要使用到`v-cloak` 这个内置的指令了，过时了，vue3 时代不存在这样的情况。
