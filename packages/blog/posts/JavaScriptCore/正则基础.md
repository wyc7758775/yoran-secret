# 正则基础

要学习正则内置对象的话,需要了解一下 js 中[[转义符]]的概念.它是学习正则表达式的前置知识。

## 一、转义符

使用转义符的场景如下如下：

```js
const a = '我就蹭蹭，绝不'进去'哦'
console.log(a)
```

我们的目的是要打印`我就蹭蹭，绝不'进去'`. 但是事与愿违，这样写会直接报错。
`Uncaught SyntaxError: Unexpected identifier`. 这是因为 JS 引擎把这串代码分成 了前后两部，`进去`被识别成了变量，这个时候报错说的是你应该要在`进入`的两边加上`+`号。

如果加上了加号的话，`const a = '我就蹭蹭，绝不'+ 进去 + '哦'`. 会接着报错：

```js
Uncaught ReferenceError: 进去 is not defined
```

面对这样的情况，我们可以让里面的单引号变成双引号，这是一种解决的办法。除此之外，我们还可以借助转义符来解决。

```js
const a = "我就蹭蹭，绝不'进去'哦";
```

转义符 = 改变这个符号本来的意义。

转义符`\`的意义也可以被自己给转移

```js
const a = "我是好人\\真的\\啊";
console.log(a); // '我是好人\真的\啊'
```

> 转义符转义自己，让 console.log 成功打印出自己

### 转义字符

也叫转义符的特殊功能

`\n`: 换行
`\r` : 回车
`\t`: 制表符，也就是键盘上的`tab`按键

这些转义字符存在我么的每一个编辑器当中，但凡是有换行功能的， 制表符的，都在每一个编辑器当中，只不过一般来说是隐藏的罢了。

所以想要 console.log()的内容也出现换行的话，就需要手动的添加这些转义字符。

## 二、创建正则表达式

**RegExp = regular expression**

和对象、数组、字符串这些一样。正则表达式也是有两种创建的方式。

```js
// 构造函数法
const reg = new RegExp("test");

// 直接声明对象，对象字面量, 对象直接量
const reg = /test/;
```

两种创建方法基本是一样的，第二种比第一种简洁一些。但是第一种可以放变量为主体；

```js
const testData = "test";
const reg = new RegExp(testData);
const reg = /testData/; // 报错
```

对象直面量直接的报错了。

### 2.1 正则变量比较的过程

类似于冒泡的过程，一旦匹配之后，就不会再拿该字符来进行下一轮的匹配了。

```js
const str = "abcde";
const reg = /[abc][cde]/gi;

console.log(str.match(reg));
```

匹配的过程如下图所示：

![[Pasted image 20220118184635.png|300]]

图上面只有一个交叉点，即 b.这是因为正则的匹配模式就是根据你的主体内容返回的数字来一格格右移的。一旦匹配成功，就把前面比较过的抛出去，从用全新的字符串来作为 start

### 2.2 正则表达式的参数

```js
// 构造方法
const reg = new RegExp('test', gim)

// 字面对象
cosnt reg = /test/gim
```

> 之后都使用字面量表达式来代替构造方法

第一个参数就是我们正则的主体判断了，第二参数可以称呼之**装饰符**, 或者叫正则属性。如图所示的三个字母，每一个字母都代表一个含义。

- i: 忽略大小写,不写的话，默认是 I，即区分大小写。
- g: 全局匹配
- m multi-line 多行匹配

### 2.3 表达式

```js
const str = "12345";
const reg = /[123][321]/;
```

[]代表在匹配 123 中的一个，上面是要匹配两个字符。连续的两个。

如果想要写区间的话，

```JS
const reg = /[0-9][a-zA-Z]/
```

0 到 9 的整 k 数

a 到 z, 大写 A 到大写 Z

- ^ 非得意思: 一定要在[]表达式中，如果是在外面的话，表示的是是否以 0 开头

  ```js
  const reg = /[^0]/;
  ```

  不是零任何字符串

- | 或

### 2.4 元字符

可以看做内置的常用变量

1.  \w: 0-9A-z\_ 和 **\W**: [^\w]

```js
const reg1 = /[0-9A-z_][1]/;
const reg2 = /\w/;
```

上面两者相等。

2. **\d**: [0-9] && **\D**: [^\d]

3. - \s: [/r/n/t/v/f]

     \v: 垂直换行符;
     \f: 换页符

   - \S: [^\s]

4. \b 单词边界 && \B: 非单词边界

#### 元字符下的全匹配

```js
const reg = /[\w|\W]/;
```

### 2.4 量表达式

量，量词。

- n+ => {1, 正无穷}
- n\* => {0, 正无穷}
  - 贪婪模式
-

## 三、对于两种创建正则方法的讨论

```js
const reg1 = /test/;
const newReg = RegExp(reg1);
const newReg1 = new RegExp(reg1);

reg1.a = 10;
console.log(newReg.a); // 10
console.log(newReg1.a); // undefinedzz
```

```js
// 贪婪模式：先多后面少
// n+ => {1,正无穷}. 就是说至少存在一个符合n的字符串就算，
// n* => {0,正无穷}. 就算是零也会挨卵
// n? => {0,1}. 就是存在和不存在的问题了
// n{x,y} => {1,正无穷} - n+ 、 {0,正无穷} - n*、{0,1} -n?
// const reg = /1[1345789][\d]{9}$/g
// (?=n). 匹配任何其后紧接着制定字符串N的字符串
// \1\1\2. 匹配叠字字符串
// const reg = /(\w)\1(\w)\1/g
```

## 四、正向预查

这个是一种查询方式的总结。

```JS
const str = '1sff1234',
	  reg = /1(?=s)/g
```

我们要匹配的是有条件的 1, 后面必须要跟着 s,不然就不算匹配成功.这种方法就叫做`正向预查`

## 五、贪婪模式和非贪婪模式

> . 这个点,是除了换行符和结束符,其他都匹配.

*贪婪模式*是正则默认的模式,但凡能够匹配多也不会匹配少.和它对应的自然就是*非贪婪模式*.

```js
const str = "safs{{name}} 史蒂夫123{{age}}123",
  reg = /{{.*}}/g;
console.log(str.match(reg)); // {{name}} 史蒂夫123{{age}}
```

正应了那句话,正则表达式的默认形式就是贪婪模式.在 name 后面就有了一个}},但是它并不满足,它会遍历到最后, 发现 age}}这里的也匹配规则,虽然结果就是取这么长一块.

如果这时候我们需要的是只要出现在这样的就抛出呢?那么我们就不需要贪婪模式了,需要使用非贪婪模式.

```js
const reg = /{{.*?}}/g;
```

只要在后面加上`?`号,JS 引擎就可以识别该正则表达式是非贪婪模式了.

打印的结果就是:

```js
console.log(str.match(reg)); // ['{{name}}', '{{age}}']
```

而非贪婪模式就是我们字符串模版匹配的基础.

## 六、replace

这个字符串方法有两点值得注意的:

1.  如果不使用正则的话,只能匹配一次就返回

    ```js
    const str = "123bs123";
    const reg = /123/g;
    console.log(str.replace("123", "替换")); // '替换bs123'
    console.log(str.replace(reg, "替换")); // '替换bs替换'
    ```

2.  replace 的第二个参数可以是一个回调函数

    ```js
    const str = "我叫{{name}}, 今年{{age}}岁";
    const Vue = function (params) {
      this.str = params.str;
      this.targetStr = null;
      this.name = params.name;
      this.age = params.age;
    };
    Vue.prototype = {
      reg() {
        return /{{(.*?)}}/g;
      },

      build() {
        const that = this;
        this.targetStr = this.str.replace(this.reg(), function (node, key) {
          return that[key];
        });
      },

      getStr() {
        this.build();
        return this.targetStr;
      },
    };

    const a = new Vue({
      str,
      name: "吴雨村",
      age: "18",
    });

    console.log(a.getStr());
    ```

## 七、子表达式的运用

```JS
// xxyycc => XxYyCc
const str = 'xxyycc'
	  reg = /(\w)\1(\w)\2(\w)\3/g
```

### {{}}的的变量替换实例

就是模板替换的具体实现

和上面的`replace`的例子一致

## 八、捕获分组和不捕获分组

不捕获分组:

```js
const str = "abcabc1",
  reg = /(ab)(?:c)/g;
console.log(str.repalce(reg, "$1$2")); // ab$2ab$21
```

捕获分组:

```js
const str = "abcabc1",
  reg = /(ab)(c)/g;
console.log(str.repalce(reg, "$1$2")); // abcabc1
```

捕获不捕获是相对于 replace 这个返回的回调函数而言的. 如果在()中前面加上`?:`的话,就代表在回调函数上面没有这个对应的形参.

## 九、exec 方法

手操式 g.

```js
const str = "123123aaaabbaabsdfasdf123ac";
const reg = /\d/g;

// console.log(str.match(reg))
console.log(reg.exec(str));
console.log(reg.exec(str));
console.log(reg.exec(str));
console.log(reg.exec(str));
console.log(reg.exec(str));
console.log(reg.exec(str));
```

有点像迭代器的操作
