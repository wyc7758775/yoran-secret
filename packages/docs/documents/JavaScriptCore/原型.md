(当前个人理解,仅仅供参考)

## 一、函数的调用方式

要知道原型和原型链是什么.首先是需要知道函数的调用方式,所有知识点都不应该是孤立存在的,有了对于函数调用全盘的了解才能够明白原型链产生的过程发生了啥.这里简单做一些表述.

### 1.1 直接调用方式

```JavaScript
function fn() {}
fn()

const a = {
  name: '妈咋',
  fn: function() {
    console.log(this.name)
  }
}
a.fn() // 妈咋
```

这种方式是绝大多数人学习函数第一个学会的.但是我在看B站某个老师的视频上面有说到,函数直接调用方法,其实默认是`fn.apply(null)` 来进行调用的.只是隐藏了`.apply(null)`.

但是我自己没有在MDN上面找到答案,不知道是否如此,仅供参考.

> 在对象中的函数约定俗成也可以叫做方法.

直接调用函数的话, 默认是不用显性的return一个值的.它会默认给你返回一个基础类型`undefined`.

This指向windows全局

### 1.2 call和apply

```
function Test1() {
    this.name = '蚂蚱精'
}

function Test2() {
    Test1.apply(this)
}

const test = new Test2()
console.log(test) // 蚂蚱精
```

直接作用于this的指向`call`和apply的差别,在于,它后面跟着的是数组形式.

```js
function Test1(name, color) {
    this.name = name
    this.color = color
}

function Test2() {
    Test1.apply(this, '蚂蚱', 'red')
    Test1.call(this, ['蚂蚱', 'red'])
}

```

有传闻,call调用方式效率比apply高, 下面是别人实践的结果,

[call和apply的性能对比 · Issue #6 · noneven/__ (github.com)](https://github.com/noneven/__/issues/6)

### 1.3 构造调用方式

这个方式就是我们形成原型链的调用方式,构造函数的过程: 内部函数顶部创建this,然后返回它.

**由上面四种方式可以知道,它们主要的不同在于****This****指向.排除这一点的话, **函数**的调用应该只有一种方式.**

![](https://secure2.wostatic.cn/static/wVqKzik5nzfgxva8t5GFGr/image.png?auth_key=1641727576-h9DMqK2m3oxW2SD6UFEBuN-0-f000f117d54c70ff6db7f23d258a1bc6&image_process=format,webp)

## 二、原型
要学习原型和原型链的话,还需要接触到这几个名词:

`prototype、__proto__、constructor`

-   prototype:  **构造函数实例化** 返回的属性,** 属于构造函数实例化,而不是构造函数的**
    
-   **protp**: 构造函数实例化过程中,return 的this中的一个属性,这个属性的值是 `.prototype`, 它就相当于一个指针名,可以叫做a、b、bb;在浏览器的控制器中打开显示的是`[[prototype]]`.
    
-   constructor: 指向构造函数本身,重点是该属性可以更改
    ![](https://secure2.wostatic.cn/static/e1G6hctLPtRh36mXZaak1T/image.png?auth_key=1641727775-uBAbyUzekBAY9VmbzjV3Tt-0-668aec8c247a622790e0c08521b223f2&image_process=format,webp)

```JavaScript
function Person() {
  this.name = '羊羊'
}
Person.prototype = {
  age: 26
}
const girl = new Person()

console.log(girl.age) // 26

```

其中`prototype` 就叫做原型. 它是一个对象.所以引用类型有的特性它都有.

成功打印出`age` 这个属性的值. 实现的过程和之前说过的构造函数不能说一模一样,只能说是相差无几. `.prototype` 也是通过了某种神秘的方法, 在构造函数实例化中挂在在了this上面.

> 这种神秘的方法, 前端可以不用了解

```JavaScript
function Person() {
  var this = {
    name: '羊羊',
    __proto__: Person.prototype
  }
  return this
}

const girl = new Person()
```

Person构造函数中, this是在实例化过程中产生的.

如果在.age在this.第一层找不到的时候,会通过某种不需要前端知道的方法,进而去到__proto__上面找.

> 不知道从什么时候开始很多教材和视频说原型的例子,控制台打印的都是__proto__,但是我现在打印的都是`[[prototype]]`.

有一个很重要的一点, 就是`原型是挂载在实例上面的,而不是构造函数上面的`

```JavaScript
fucntino Car() {}
Car.prototype = {
  color: 'white'
}

cons a = new car()
console.log(a.color) // 'white'

car.prototype.color = 'red;
console.log(a.color) // 'red'
```

直接改变原型上面的值,是会引起实例属性的变化的, 毕竟你只是修改值.

但是下面这种情况就会出现问题了

```JavaScript
functino Car() {}
Car.prototype = {
  color: 'white'
}
const a = new Car()
Car.prototype = {
  color: 'red'
}
console.log(a.color) // white
```

### 原型赋值的混淆点

上面的例子直接的指出了对象a上面的[[prototype]]的值是原型. 重要的是这个过程不是一个**复制**的过程.

而是一个关联的过程.在创建过程中,或者说是new的过程中,a和内部的__proto__都会关联到Car.prototype上面.

这一知识点出自《你不知道的Javascript》上卷5.2.3

正是因为如此,下面的代码才会成立:

```JavaScript
function Car() {
  this.color = 'red'
}

Car.prototype = {
  age: 18,
  constructor: Motorcycle
}

let car = new Car()
car.__proto__.age = 30
console.log(car) // [[prototype]]中的age 为30

```

原型上面的`age` 被改变了. 进而也导致了同样实例化`Car` 的变量也跟着改变.

```JavaScript
let car2 = new Car()
console.log(car2.age) // 30
```

这不是儿子打老子,小儿子跟着受罪么?

![](https://secure2.wostatic.cn/static/5D1cNQJeQUhj2Wo8J4uFY5/image.png?auth_key=1641727820-oUgHgbKBmRYrtmq2gS3utY-0-07011cec50d5310c88bca71de5fe4898&image_process=format,webp)
有人说,原型的存在就是为了继承.所以我们必须要屏蔽掉原型的**共享属性**的副作用.

### 原型链中this的问题

```JavaScript
functino Car() {
  this.brand = 'benz'
}
Car.prototype = {
  brand: 'Mazda',
  intro: function() {
    console.log(this.brand)
  }
}

car.intro() // 'benz'
car.__proto__.intor() // 'Mazda'
```

## 三、原型链

```
function Car() {
  this.name = 'one'
}
Car.prototype = {
  color = 'red'
}
const car = new Car()
```
![](https://secure2.wostatic.cn/static/pyHbxwwHuGq7hyTD9QdzZb/image.png?auth_key=1641727873-fgbYSx9GbL65mR4v25k2yB-0-9bd999df5109a04337ec3a3d16526403&image_process=format,webp)
左边一路下来的就是原型链了.

```
console.log(car.color) // 'red'
```

在对象上面找不到的属性,会找到上一个原型上面继续找,知道找到位置,不然就是`undefined`.

从上面的图片也可以知道,car上面有Object.prototype,就是说,Object.prototype上面有啥属性,car都可以使用.
![](https://secure2.wostatic.cn/static/7dL4syWyPMUvjgDFw6nzLz/截屏2021-12-25%2022.31.59.png?auth_key=1641727927-a6s6yPnrnGGZfxsTEhkQ2n-0-d1259eaf2f0bf6e2b55259eea87d4fd9&image_process=format,webp)
![]([https://secure2.wostatic.cn/static/7dL4syWyPMUvjgDFw6nzLz/截屏2021-12-25](https://secure2.wostatic.cn/static/7dL4syWyPMUvjgDFw6nzLz/%E6%88%AA%E5%B1%8F2021-12-25) 22.31.59.png)

> __**proto****是 [[prototype]] 的具体表现属性. 所以图中的[[prototype]] 就是代表__proto**

情况似乎有点不对.上面这么没有`Function` 构造函数呀...

这是因为实例化生成的是一个对象,所以原型链上面自然没有`Functino`才对,直接指向`Object`.正确的原型链图应该如下:
![](https://secure2.wostatic.cn/static/f3RQHZWtiyaPU7b58f3sgF/image.png?auth_key=1641727580-c2CCgFUxu1RaqbrqDFYvBW-0-3e4e7419afa7f0713c39302c97be2d2a&image_process=format,webp)
![](https://secure2.wostatic.cn/static/f3RQHZWtiyaPU7b58f3sgF/image.png)

所以下面这题就能够理解了.

```js
var F = function() {};

Object.prototype.a = function() {
  console.log('a');
};

Function.prototype.b = function() {
  console.log('b');
}

var f = new F();

f.a(); // 'a'
f.b(); // 报错, b 为定义

F.a(); // 'a'
F.b(); // 'b'
```