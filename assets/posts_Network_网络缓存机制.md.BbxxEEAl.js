import{_ as i,c as a,o as n,b2 as h}from"./chunks/framework.BpzV57uv.js";const g=JSON.parse('{"title":"缓存机制","description":"","frontmatter":{},"headers":[],"relativePath":"posts/Network/网络缓存机制.md","filePath":"posts/Network/网络缓存机制.md"}'),t={name:"posts/Network/网络缓存机制.md"};function e(l,s,p,k,d,r){return n(),a("div",null,s[0]||(s[0]=[h(`<h1 id="缓存机制" tabindex="-1">缓存机制 <a class="header-anchor" href="#缓存机制" aria-label="Permalink to “缓存机制”">​</a></h1><p>\b 所谓机制,就是说有这么一套规则来束约缓存的逻辑. 束约的工具是浏览器内部实现的. 束约的参数就是我们 HTTP 和 HTTPS 协议的报文内容. 结果就是用户看到的资源.</p><p>所以说我们在讨论的浏览器缓存机制的时候,就是在讨论 HTTP 报文中的某些对应字段的发挥的作用, 辅以一套处理这些字段的逻辑.</p><p>这套处理的逻辑可以分为两种强制缓存和协商缓存</p><h2 id="强制缓存" tabindex="-1">强制缓存 <a class="header-anchor" href="#强制缓存" aria-label="Permalink to “强制缓存”">​</a></h2><p>在 http1.0 时代,通过配置<code>expires</code>相应头的属性,设置过期的时间,只要超过这个时间,资源就从服务器上获取.反之就从本地获取.</p><p>很简单,但是问题也很多</p><p>对本地时间戳过分的依赖,如果客户端本地的时间和服务器的时间不一致的话,那么缓存过期的判断就无法和预期相符</p><blockquote><p>浏览器中的这个时间叫做格林威治时间</p></blockquote><p>所以为了解决这个问题. 在 http1.1 时代,出现了<code>cache-control</code>字段. 其中的<code>max-age</code>属性就是对于<code>expires</code>的补充.</p><p>不是进行替代,而是补充.<code>expires</code>因为简单依旧存在它的使用场景</p><p>如下配置, 单位是<strong>秒</strong>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeHead</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(200m {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Cache-control&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;max-age:5&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>这个<code>max-age</code>的含义超过相对时间. 每一次刷新都更新初始化时间，类似防抖函数的作用，当你渲染界面之后的 5 秒钟内，都是可以从缓存中拿到数据的。一旦渲染界面之后，再超出 5 秒钟才再点击拿资源的话，就会重新从服务器上面拿该资源。</p><p>很多时候还是需要加上<code>public</code>属性的. <code>&quot;public, max-age:5&quot;</code>的. 含义是: <strong>响应可以被任何对象缓存(包括发送请求的客户端、代理服务器等)</strong></p><p>如果只是使用<code>max-age</code>依旧是存在问题的.如果你后台的接口,资源就是在配置的的几秒钟更新了你怎么办?GG 了. 所以出现了下面的协商缓存</p><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to “协商缓存”">​</a></h2><p>协商缓存就要求每次都向服务器要结果. 缓存的有效性决定权交给后台.这样自然缓存存在的意义就很大的问题了.对于这个问题暂时不表,先来看看它是如果进行协商缓存的逻辑处理的.</p><h3 id="last-modified-实现的协商缓存" tabindex="-1">last-modified 实现的协商缓存 <a class="header-anchor" href="#last-modified-实现的协商缓存" aria-label="Permalink to “last-modified 实现的协商缓存”">​</a></h3><p>这是最简单的协商缓存的方案, 根据文件的修改时间来进行判断. 如下配置</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;last-modified&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mtime.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUTCString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Cache-Control&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;no-cache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>配置成功了之后, 响应头会生成一个属性 <code>if-modified-since</code>. 然后后台再进行如下的判断:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ifModifiedSince</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> req.headers[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;if-modified-since&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ifModifiedSince </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mtime) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 缓存生效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.statusCode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 304</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如此一来,是能够满足绝大多是的场景的. 但是还是有如下的不足:</p><ol><li>它只是根据时间戳来进行判断,如果只是改变了文件名,而实际内容没有任何改变的情况下,还是会进行服务器的请求拿取.这实在是太蠢了.</li><li>它的单位是秒.如果修改文件的速度非常快,在一些自动化文件处理中.在几百毫秒就完成了.那么它的单位就没有办法通过验证了.</li></ol><p>所以为了解决这两点问题, HTTP1.1 在随后更新版本中提供<code>etag</code>响应头字段来处理</p><h3 id="etag-实现协商缓存" tabindex="-1">ETag 实现协商缓存 <a class="header-anchor" href="#etag-实现协商缓存" aria-label="Permalink to “ETag 实现协商缓存”">​</a></h3><p>处理逻辑和<code>last-modified</code>基本一致</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> etag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;etag&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./img4.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> etagContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> etag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ifNoneMatch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> req.headers[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;if-none-match&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ifNoneMatch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> etagContent) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 缓存生效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    res.statusCode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 304</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;etag&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, etagContent);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Cache-Control&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;no-cache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span></code></pre></div><p>etag 表示的是对文件内容的解析进而生成的一个 id，只要文件内容有了改变才会进行变更。自然就能够改变 last-modified 的两点的不足。它是对其的一个补充方案，而不是替代方案。</p><p>etag 依旧带来了新的问题:</p><ol><li>服务器生成文件资源 Etag 需要付出额外的计算开销，如果资源尺寸比较大，数量较多且修改比较频繁的话，那么生成 Etag 的过程显然会印象服务器的性能。</li><li>Etag 字段值的生成两种类型，一种是强验证，即更具资源内容的每一个字节来进行验证，最可靠，性能消耗也最大。相对应的就是弱验证，它使用资源内容的部分的属性值来进行生成，生成速度快，但是没有办法很高的成功率。尤其是在服务器集群场景下。</li></ol><p>所以说不管哪种缓存方式都有不足,结合具体的场景使用才是正确对待它们的方式. 一般来说,<code>etag</code>和<code>last-modified</code>都是使用的. 所以说对于它们的使用还有一个优先级的问题.</p><h3 id="etag-和-last-modified-的优先级" tabindex="-1">ETag 和 Last-Modified 的优先级 <a class="header-anchor" href="#etag-和-last-modified-的优先级" aria-label="Permalink to “ETag 和 Last-Modified 的优先级”">​</a></h3><p>一般来说,默认配置的话. 是先进行<code>etag</code>的判断的,如果返回的是 true 的话,再判断<code>last-modified</code>. 当然这个可以后台自己实现自己喜欢的策略.</p><h3 id="协商缓存过程的简单总结" tabindex="-1">协商缓存过程的简单总结 <a class="header-anchor" href="#协商缓存过程的简单总结" aria-label="Permalink to “协商缓存过程的简单总结”">​</a></h3><p>可以总结如下图</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8bda1eb17fa4a7baeb17c437a8d6c08~tplv-k3u1fbpfcp-watermark.image?" alt="截屏2022-02-25 16.10.36.png"></p><h2 id="其他相关配置的豹纹字段" tabindex="-1">其他相关配置的豹纹字段 <a class="header-anchor" href="#其他相关配置的豹纹字段" aria-label="Permalink to “其他相关配置的豹纹字段”">​</a></h2><p>Paragma: no-cache(响应头) HTTP/1.0 版本的字段</p><p>Cache-Control: 也是操作缓存的.是 HTTP/1.1 版本字段,向下兼容的,所以说 Paragma 还是存在的.</p><p>Cache-Control 的优先级是比前者高的.</p><p>Expires: Mon, 15 Aug2016 03:56:47 GMT(格林威治时间)</p><p>在 HTTP/1.1 使用 Cache-control 中的 max-age 来代替</p><p>Cache-Control 的相关属性</p><ul><li><p>no-cache: <strong>忽略缓存在本地的副本,强制从服务器上拿资源</strong></p></li><li><p>no-store: <strong>强制缓存在任何情况下都不要保留任何副本</strong></p></li><li><p>max-age=314600: 知识缓存副本的有效时长,从请求时间开始到过期时间之间的描述</p></li><li><p>public: 表明响应可以被任何对象缓存(包括:发送请求的客户端、代理服务器等)</p></li><li><p>private: 表明响应只能被耽搁用户缓存,不能作为共享缓存(即代理服务器不能缓存它)</p></li></ul><h2 id="我们前端需要做些什么" tabindex="-1">我们前端需要做些什么 <a class="header-anchor" href="#我们前端需要做些什么" aria-label="Permalink to “我们前端需要做些什么”">​</a></h2><p>这里是熟悉前端工程话的知识点了.很多 Webpack 基础已经帮我们做了. 我们只需要进行进行对应的配置就可以了. 比如说,修改每次打包都修改生成的入口文件的文字</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  entry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./main.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      vendor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./dist&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      publicPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/dist/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      filname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bundle.[chunkhash].js&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p><code>chunkhash</code>就代表出口文件没有打包都会生层对应的 hash 值. 还有另外两个值可以替换它.<code>hash</code>、<code>contenthash</code></p><p>三者的差别可以用一句话来概括:</p><ul><li><code>hash</code> 计算和整个项目的构建相关</li><li><code>chunkhash</code>计算同一 chunk 内容相关</li><li><code>contenthash</code>计算和文件内容本身相关 详情可以自己尝试一下.看官网.</li></ul><p>还有一些前端世界常听到的:</p><ul><li>html 使用协商缓存</li><li>css、js、静态资源 使用强缓存,文件名带上 hash 值</li></ul>`,54)]))}const o=i(t,[["render",e]]);export{g as __pageData,o as default};
