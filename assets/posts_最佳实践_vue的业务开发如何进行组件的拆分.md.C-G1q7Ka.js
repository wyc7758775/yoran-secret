import{_ as e,I as h,c as k,o as r,be as p,j as i,a,J as l,w as t}from"./chunks/framework.BhXXfD0-.js";const F=JSON.parse('{"title":"Vue2 业务开发组件拆分实战","description":"","frontmatter":{},"headers":[],"relativePath":"posts/最佳实践/vue的业务开发如何进行组件的拆分.md","filePath":"posts/最佳实践/vue的业务开发如何进行组件的拆分.md"}'),E={name:"posts/最佳实践/vue的业务开发如何进行组件的拆分.md"};function d(o,s,g,c,y,u){const n=h("font");return r(),k("div",null,[s[10]||(s[10]=p(`<h1 id="vue2-业务开发组件拆分实战" tabindex="-1">Vue2 业务开发组件拆分实战 <a class="header-anchor" href="#vue2-业务开发组件拆分实战" aria-label="Permalink to “Vue2 业务开发组件拆分实战”">​</a></h1><p>组件化是一种思维的表现，这种技能映射到人的本质是，<strong>一个人是否有能力把一个复杂的问题拆解、简单化的能力。</strong></p><h2 id="一、组件化诞生的历史" tabindex="-1">一、组件化诞生的历史 <a class="header-anchor" href="#一、组件化诞生的历史" aria-label="Permalink to “一、组件化诞生的历史”">​</a></h2><p>我们在讨论如何拆分组件之前，是有必要简单的了解一下组件化诞生的一个历史。</p><p>前端娱乐圈有一个独有的生态：框架。每年出现的框架层出不穷，根本学不完。但是总的来说还是可以分成两个阶段。</p><p><strong>第一阶段</strong>：JQ 和 PrototypeJS。 该阶段解决了浏览器的兼容性问题以及 API 的遍历程度</p><p>**第二阶段: ** Vue、React、Angular。解决了组件化、解耦、复用等问题</p><p>在大陆，主要讨论的是 Vue 和 React。 有些人说 Vue 是 framework,而 React 是 library，前者有更多的约束和更加齐全的工具链。而后者更加的自由。但是真的要投入生产的话，依旧需求认为的给 React 添加很多的约束，而且 Vue 也是支持 jsx 的，所以我一直不太赞同 React 更加自由这样的说话。</p><p>在我看来，它们在实际生产开发过程中，在那一堆工具链中，<strong>只是 API 的不同而已</strong>。</p><p>它们都为前端提供了很好的组件化。而且近一年来两者都不约而同朝着函数式跟进。它们带来的各种 hook,给我们带来了不一致的组件化的写法。</p><h2 id="二、为什么业务组件越开发越难维护" tabindex="-1">二、为什么业务组件越开发越难维护 <a class="header-anchor" href="#二、为什么业务组件越开发越难维护" aria-label="Permalink to “二、为什么业务组件越开发越难维护”">​</a></h2><p>当然是人的问题. 或许产品的问题,或许整个工作流程的问题,或许上面的问题. 这些我们暂且不提,我作为开发, 首先是要管好自己的代码组织.</p><p>再次我们先排除其他外界的因素,比如产品经常改需求. 仅从编码阶段来说.</p><p>以我们团队为例，我们团队内部员工 2 个，8 个外包，外包兄弟们的招聘标准是远低于内部的。团队人员每个人的编码能力差距还是很大的。项目都是长期维护的，一个业务模块就会有很多人维护，在上面不断的填尿加屎。</p><blockquote><p>在这里并不是说外包人员的编码能力差，我们组就有一个外包的兄弟编码能力、解决问题的能力相当厉害的，比很多内部的都好很多。这里只是从平局值上面来说。</p></blockquote><p>团队成员的水平层次不齐, 估计到团队协作, 我们在写业务组件中弄过做的,就是设定一些源码.</p><h3 id="_2-1-项目现状" tabindex="-1">2.1 项目现状 <a class="header-anchor" href="#_2-1-项目现状" aria-label="Permalink to “2.1 项目现状”">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1669737578936-58556351-edf6-4549-81d6-fb4cf2f02eef.png" alt="">以该图为例, A B C 分别是父子孙组件. 当我们要控制其中一个组件的状态的是, 可以通过很多方式来进行控制. 这些方式的来源有可能是<strong>全局变量</strong>、<strong>vuex</strong>、<strong>时间总线</strong>、<strong>来自自己父组件或子组件的改变</strong>等等.</p><p>可以看出, 改变它组件内部状态的来源非常的多, 维护或者修改的时候,需要翻阅的文件目录和范围就很广. 自然就很难维护.</p><p>举一个 mixins 的例子：</p><p>假设它混入了这么多功能。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mixins: [a, b, c, d, e, f, g],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.whoAreYou);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>这个<code>this.whoAreYou</code>你能够知道来源于哪一个么？</p><p>而如果改成<code>hook</code>的写法来引入某个 JS 中的变量：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IamI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myHome</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IamI</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> me</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myHome</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>这就很简洁干净。在你维护代码的时候，可以很好的进行溯源。</p><p>而上面的一切，导致难以维护的原因总结来说有两个：</p><ul><li>混用业务变量和 UI 变量</li><li>不区分受控组件和非受控组件</li></ul><p>下面我会实际例子分别介绍这个两个概念。而基于<code>hooks</code>的复用才是我们现在解决组件化复用的更好的选择。</p><h3 id="_2-2-理想目标" tabindex="-1">2.2 理想目标 <a class="header-anchor" href="#_2-2-理想目标" aria-label="Permalink to “2.2 理想目标”">​</a></h3><p>基于<code>hook</code>的理想模型</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1669738146798-78c6d796-233b-4281-8e50-835e67188cb5.png" alt=""></p><p>依旧是 A B C 三个组件.但是 A B C 三个组件外边飘的那些箭头不存在了. 所有能够控制它们的内部状态的方式都集中在了<code>controllers</code>上面.</p><p>其中<code>controllers</code>部分的组织形式和 vue 的<code>composition api</code>宣传图表现一致。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1669776438338-feb8af6b-2b04-4c02-8f9a-cd8a07827a4c.png" alt=""></p><p>将相似的功能以及用到的变量都封装在一个函数当中。这一切也更加好的迎合了</p><p>实际代码如下:</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">B</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{setC}</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;B.js&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cController </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;cController.js&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(props)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// cController.js</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">export default c(props) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  const c = ref(&#39;&#39;)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  const setC() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c.value = &#39;I an cController&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  return {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    c,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    setC,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>cController.js</code>就是<code>controllers</code>中的一个<code>void</code>. 引入到 A 组件当中,然后将里面的方法通过 props 传给 B 组件.</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">C</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{setC}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> C </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;C.js&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  	setC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Number,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>也就是说,控制 C 组件内部状态的是通过引入到 A 组件中的<code>controller</code>来进行通过,中间的 B 组件不做任何的处理,仅仅作为一个中转站. 操作起来和理论都很简单。但是想要更好的拆分的话，还需要了解三个概念：</p><ul><li>业务变脸和 UI 变量</li><li>受控组件和非受控组件</li><li>控制反转 ioc</li></ul><p>下面我通过一个实际的业务场景来描述。</p><h2 id="三、举一个实际的例子" tabindex="-1">三、举一个实际的例子 <a class="header-anchor" href="#三、举一个实际的例子" aria-label="Permalink to “三、举一个实际的例子”">​</a></h2><h3 id="_3-1-需求背景" tabindex="-1">3.1 需求背景 <a class="header-anchor" href="#_3-1-需求背景" aria-label="Permalink to “3.1 需求背景”">​</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1669799527274-fbdc2ba8-d0d8-481c-9ec8-83c8b14cbf1f.png" alt=""></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1669800209694-ecf04a1c-e290-47eb-889b-c05d20927c58.png" alt=""></p><p>简单的截两张图. 需求大致如下:</p><ul><li>功能就是典型的笔记软件的功能,右边可以放各种类型的文件,点击就可以在右边渲染出对应的内容.</li><li>目录树有两个彩蛋,会根据当前文件类型出现不同的操作</li><li>目录树下面有一个固定的收藏夹,目录树可以在这其中滚动</li></ul><h3 id="_3-2-开发之前-前端设计文档" tabindex="-1">3.2 开发之前: 前端设计文档 <a class="header-anchor" href="#_3-2-开发之前-前端设计文档" aria-label="Permalink to “3.2 开发之前: 前端设计文档”">​</a></h3><h4 id="数据流向图" tabindex="-1">数据流向图 <a class="header-anchor" href="#数据流向图" aria-label="Permalink to “数据流向图”">​</a></h4><p>功能还是很清楚的,但是功能其实很多.</p><p>我认为我们团队在开发之前是必须要有的. 作为一个前端, 可以没有流程图,但是一定要下面这样的图. 我在别的地方没有见过这样的图,所以自己给这样的图做了一个定义,叫<strong>数据流向图</strong>.</p><blockquote><p>关于完整的工作流程,之后再写一篇文章进行描述</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1669912582986-3671f3d3-a7b4-42ca-854d-7797e7404738.png" alt=""></p><p>它是有两部分构成:</p><ul><li>组件的模块</li><li>组件之间的控制关系</li></ul><p>第一点, 还是比较清楚,就是这个需求可以拆成哪几个模块.</p><p>第二点, tree 组件和 content 组件是同级组件, tree 可以控制 content 组件内的状态, content 组件也可以改变 tree 内的状态. 再深入一点说,就是 tree 点击不同的文件类型, content 组件部分就会渲染不同的模块; 而当在 content 组件内对当前阅读的文件进行删除操作的时候,tree 作为目录树自然是要刷新最新的目录信息的.</p><h4 id="目录结构" tabindex="-1">目录结构 <a class="header-anchor" href="#目录结构" aria-label="Permalink to “目录结构”">​</a></h4><p>通过上面的结构图,可以得到下面这样目录结构.</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1669940918346-49ab45fe-1811-48ee-9e72-2c789ef4c333.png" alt=""></p><h4 id="逻辑控制" tabindex="-1">逻辑控制 <a class="header-anchor" href="#逻辑控制" aria-label="Permalink to “逻辑控制”">​</a></h4><p>数据流向图中的各个组件都放在根目录下<code>index.vue</code>中挂载. 如下入<img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1670061371190-782d65a7-2c51-444e-94d9-378c5a3eb2e4.png" alt=""></p><p>控制目录树的相关逻辑都放在<code>listTreeController</code>控制器里边, 和右边内容 content 相关逻辑都放入到<code>renderContentController</code>的方法当中.</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1670061591951-06c51152-80b2-4355-bc3a-bfdbaf15b6d2.png" alt=""></p><p>随后将 controller 中公共方法都传进到组件当中. <code>doc-aside</code>是包括<code>search</code>和<code>tree</code>已经<code>other</code>三个模块的中转组件. 不在这个组件中做任何的逻辑处理. 如下图:</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/654315/1670061777032-3f7e7fdc-25aa-41f7-8103-57052b5487bd.png" alt=""></p><p>举一个例子, <strong>控制按钮的权限.</strong></p><p><strong>[背景]</strong></p><ul><li>所有功能点都受控挂载在 vuex 的 store 上面的一个变量, 没有权限的话,就直接通过<code>v-if</code>来隐藏对应的入口</li></ul><p><strong>[之前实现]</strong></p><ul><li>直接找到对应的按钮在<code>v-if</code>上,通过<code>root.docAuth(&#39;createDoc&#39;)</code>来判断</li></ul><p><strong>[修改之后]</strong></p><ul><li>创建来一个<code>authoControllers.js</code>在<code>index.vue</code>引入, 需要用的地方是应用的是</li></ul><p><strong>[具体实现]</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> authController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> menuAuth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MENTY_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.rename]: root.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docAuth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;rename&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MENTY_TYPE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.delete]: root.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docAuth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;delete&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ....</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>虽然在 Index.vue 中引入,不管是通过 props,还是通过依赖注入来给子组件来使用,都不重要.重要的是,它统一管理, 并在 index.vue 中引入是唯一一个入口.</p><p>当我们维护的时候, 只需要通过子组件一路找到对应的<code>controller</code>就可以找到对应的逻辑了.</p><h4 id="拆分的原则" tabindex="-1">拆分的原则 <a class="header-anchor" href="#拆分的原则" aria-label="Permalink to “拆分的原则”">​</a></h4><ul><li>对于组件的拆分一开始不需要太细</li><li>拆分好受控组件和非受控组件</li></ul><h3 id="_3-3-受控组件和非受控组件" tabindex="-1">3.3 受控组件和非受控组件 <a class="header-anchor" href="#_3-3-受控组件和非受控组件" aria-label="Permalink to “3.3 受控组件和非受控组件”">​</a></h3><p>我们使用的任何 UI 框架都是受控组件, 受控组件的概念就是它里面的状态都是受调用它的组件来控制的. 非受控组件反之.</p><h3 id="_3-4-开发进行-逻辑变量和-ui-变量" tabindex="-1">3.4 开发进行: 逻辑变量和 UI 变量 <a class="header-anchor" href="#_3-4-开发进行-逻辑变量和-ui-变量" aria-label="Permalink to “3.4 开发进行: 逻辑变量和 UI 变量”">​</a></h3><p>UI 变量其实很好理解. 像 element-ui 的组件中所需要的属性就是 UI 变量. 但是对于我们实际业务当中, 会对这些进行一定扩展.</p>`,85)),i("p",null,[s[3]||(s[3]=a("举一个例子, 在上面的目录中",-1)),s[4]||(s[4]=i("code",null,"dialog组件",-1)),s[5]||(s[5]=a("的显示或隐藏,是通过",-1)),s[6]||(s[6]=i("code",null,'<font style="color:rgb(48, 49, 51);">model-value / v-model</font>',-1)),l(n,{style:{color:"rgb(48, 49, 51)"}},{default:t(()=>s[0]||(s[0]=[a("来进行控制的, ",-1)])),_:1,__:[0]}),s[7]||(s[7]=i("code",null,'<font style="color:rgb(48, 49, 51);">true</font>',-1)),l(n,{style:{color:"rgb(48, 49, 51)"}},{default:t(()=>s[1]||(s[1]=[a("就显示, ",-1)])),_:1,__:[1]}),s[8]||(s[8]=i("code",null,'<font style="color:rgb(48, 49, 51);">false</font>',-1)),l(n,{style:{color:"rgb(48, 49, 51)"}},{default:t(()=>s[2]||(s[2]=[a("就隐藏起来. ",-1)])),_:1,__:[2]})]),i("blockquote",null,[l(n,{style:{color:"rgb(48, 49, 51)"}},{default:t(()=>s[9]||(s[9]=[a("隐藏和显示的渐入渐出效果是 elementUI 框架内置的.",-1)])),_:1,__:[9]})]),s[11]||(s[11]=p(`<p>平时工作中很多人是这样传的:</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">el-dialog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">v-model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> XXXX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  // code</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">el-dialog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">props = { data: { type: Object } }</span></span></code></pre></div><p>通过通过接口拿到的,或者自己组件的数据传进来之后,再进行对<code>v-model</code>的控制. <code>data.id</code>这样的变量就是业务变量, 通过业务变量来直接控制 UI 的组件的显示和隐藏,就是业务变量和 UI 变量的混用. 或者说**业务逻辑和交互逻辑的混用. **</p><p>混用之后的后果,就是我们进行维护的时候, 需要查看的变量或者说字段就成倍的增加, 交互变量和业务变量交织在一起. 这部分的代码<strong>同时承载了业务逻辑和交互逻辑.</strong></p><blockquote><p><strong>DDD 领域模型也是可以解决这个问题, 之后我会再开篇幅聊一聊.</strong></p></blockquote><p>所以我们就需要将业务逻辑和交互逻辑给拆开. 如下:</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">el-dialog</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :v-model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;isShow&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;header&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {{ dialogTitle }}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> slot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;content&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      // type === 创建表单</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      // type === 移动文件夹目录</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">el-dialog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">temaplte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">props = {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  isShow: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type : Boolean,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    desc: &#39;是否显示弹窗&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  type: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type: String,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    desc: &#39;弹窗的类型&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>其中<code>ishow</code>和<code>type</code> 就可以视为 UI 变量, 它们不关心外界是通过了什么判断, 只关系传进来的是 true 还是 false.</p><h2 id="四、持续的优化" tabindex="-1">四、持续的优化 <a class="header-anchor" href="#四、持续的优化" aria-label="Permalink to “四、持续的优化”">​</a></h2><p>不管一开始代码是如何规划的,如何组织的.最重要的还是要持续的去维护. 屎山到了之后, 前面的维护者没有一个人是无辜的. 但是也不需要过早的去维护.什么时候到了维护重构的时机呢?</p><ul><li>当碰到这里用的代码别的地方也用到的时候</li><li>这个变量出现在好几个地方,被好几个地方都 set 的时候, 而自己搞不懂它们 set 的顺序的时候</li><li>函数复杂到自己看了半天都看不明白的时候</li></ul><h2 id="五、可能的问题" tabindex="-1">五、可能的问题 <a class="header-anchor" href="#五、可能的问题" aria-label="Permalink to “五、可能的问题”">​</a></h2><p>**问题一: **中转的组件没有挂载任何逻辑，为什么还存在?</p><ol><li>为了之后可能的拆分</li><li>让结构更加的清晰</li></ol><p>**问题二: **中转的组件要挂载这么多办法, 或许太难看?</p><ol><li>实在是太多可以使用 vue 的<code>$attr</code>和 <code>$listeners</code></li><li>为了维护对于数据的溯源</li></ol><h2 id="五、实践是学习前端的捷径" tabindex="-1">五、实践是学习前端的捷径 <a class="header-anchor" href="#五、实践是学习前端的捷径" aria-label="Permalink to “五、实践是学习前端的捷径”">​</a></h2><p>前端是一门手艺活,只有实践才能够提高技术. 前端的天花板确实相比其他方向的低,但是也不是我这样的普通人说能够触碰就能触碰到的. 就算很多高端大佬嗤之以鼻的业务代码, 写的时候如果不多思考如何写的简洁,怎么写优雅,写十年和写三年也是没有差别的.</p><p>业务才能创造价值, 有了价值才能有我们前端工程师生存的空间. 所以为了提升自己的价值, 提升自己的工资. 平时写业务代码的时候,想想这样写会有什么问题, 如何写才能够更加好. 在这个基础上, 才能看明白那些框架存在的意义. 业务是在轮子之上的,如果对业务的代码都不理解, 又怎么能够真正的写好轮子呢?</p><p>我们在保障业务按时完成的情况下,应该多尝试,多实践.</p>`,20))])}const C=e(E,[["render",d]]);export{F as __pageData,C as default};
