import{_ as e,c as t,o as r,be as i}from"./chunks/framework.CneAHPKZ.js";const p=JSON.parse('{"title":"作用域（链）、执行上下文、闭包","description":"","frontmatter":{},"headers":[],"relativePath":"posts/JavaScriptCore/作用域（链）、执行上下文、闭包.md","filePath":"posts/JavaScriptCore/作用域（链）、执行上下文、闭包.md"}'),l={name:"posts/JavaScriptCore/作用域（链）、执行上下文、闭包.md"};function o(_,a,s,n,c,d){return r(),t("div",null,a[0]||(a[0]=[i('<h1 id="作用域-链-、执行上下文、闭包" tabindex="-1">作用域（链）、执行上下文、闭包 <a class="header-anchor" href="#作用域-链-、执行上下文、闭包" aria-label="Permalink to “作用域（链）、执行上下文、闭包”">​</a></h1><ul><li>{} == {} 不需要使用内存管理那一套来作为理解。它就是一个语法规范，内存管理是引擎的实现细节。规范就是这么规定的，如何实现就是另外一个问题，不需要用什么基础数据类型存在栈内存中，引用类型存储在内存中来理解。只要规范可以让 {} == {} 为 true，在现在的内存管理的基础上面一样可以让它成立。</li><li>我们平时的工作时候，基本的算法的涉及不到，更加不用说 JS 引擎的实现了，所以当我们在讨论基础类型是储存在栈内存或者引用类型存储在堆内存的时候，其实的不出什么结果的。 什么样的工作需要深入了解呢？ts39 部门，制定 JS 规范的那些人。</li><li><blockquote><p>可以说高级脚本语言(shell 那类除外）就没有真正意义上的基本数据类型(比如 Java 中的 int 之类)，因为如果定义了基本数据类型，那么引用数据类型就没办法复制给基本数据类型了(内存中长度不一样，操作方式也没法一样)。</p></blockquote></li><li>当我们在谈论局部变量和执行上下文的时候，执行上下文是包括局部变量的。</li></ul><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to “参考资料”">​</a></h2><h2 id="作用域、作用域链、以及执行上下文的关系" tabindex="-1">作用域、作用域链、以及执行上下文的关系 <a class="header-anchor" href="#作用域、作用域链、以及执行上下文的关系" aria-label="Permalink to “作用域、作用域链、以及执行上下文的关系”">​</a></h2><h2 id="再次理解闭包" tabindex="-1">[[再次理解闭包]] <a class="header-anchor" href="#再次理解闭包" aria-label="Permalink to “[[再次理解闭包]]”">​</a></h2>',5)]))}const m=e(l,[["render",o]]);export{p as __pageData,m as default};
