import{_ as e,c as s,o as n,be as i}from"./chunks/framework.ohYmeG42.js";const m=JSON.parse('{"title":"微前端样式覆盖问题解决","description":"","frontmatter":{},"headers":[],"relativePath":"posts/微前端/样式覆盖问题解决.md","filePath":"posts/微前端/样式覆盖问题解决.md"}'),p={name:"posts/微前端/样式覆盖问题解决.md"};function l(c,a,t,o,d,r){return n(),s("div",null,a[0]||(a[0]=[i(`<h1 id="微前端样式覆盖问题解决" tabindex="-1">微前端样式覆盖问题解决 <a class="header-anchor" href="#微前端样式覆盖问题解决" aria-label="Permalink to “微前端样式覆盖问题解决”">​</a></h1><h2 id="一、背景" tabindex="-1">一、背景 <a class="header-anchor" href="#一、背景" aria-label="Permalink to “一、背景”">​</a></h2><p>现在没有哪家公司不使用微前端来进行作为项目的组织架构了。</p><p>但是这个东西的出现也带来了新的问题。</p><p>比如说各个业务团队使用的 UI 框架不一样的时候，就会导致如下这样的样式污染。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d11950d8419c4a8c9bc23615dc3c8684~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>样式的污染，css-scoped 或者 css module 解决了绝大部分，但是对于多子应用同时加载，主子应用之间的冲突，导致了所有的弹窗样式都是有问题的。</p><h2 id="二、解决方案" tabindex="-1">二、解决方案 <a class="header-anchor" href="#二、解决方案" aria-label="Permalink to “二、解决方案”">​</a></h2><h3 id="使用-qiankun-沙盒模式隔离" tabindex="-1">使用 qiankun 沙盒模式隔离 <a class="header-anchor" href="#使用-qiankun-沙盒模式隔离" aria-label="Permalink to “使用 qiankun 沙盒模式隔离”">​</a></h3><p>这是一个坑。神光最近也写过相关的文章，想要详细的了解，可以自寻查找。下面我简单的总结一下：</p><ul><li><code>qiankun</code> 的 <code>css</code> 沙箱的原理是重写 <code>HTMLHeadElement.prototype.appendChild</code> 事件，记录子项目运行时新增的 <code>style/link</code> 标签，卸载子项目时移除这些标签。</li></ul><p>思路就是将子项目的样式局限到子项目的容器范围，不在这个范围样式不生效。但是对于一些弹窗就无能为力了，它们需要挂载到 <code>body</code> 上面，不在子应用容器中，样式就无法生效。</p><ul><li>使用换肤的思路来解决 ：在子项目给 <code>body</code> 加一个唯一的 <code>id</code> 或<code>class</code>），在对应的全局的样式前面加上这个 <code>id/class</code>。而 <code>single-spa</code> 模式则在 <code>mount</code> 周期给 <code>body/html</code> 加上这个唯一的 <code>id/class</code>，在 <code>unmount</code> 周期去掉，这样就可以保证这个全局 <code>css</code> 只对这个项目生效了。</li></ul><p>这两个方案的致命点都在于无法解决多个子项目同时运行时的 <code>css</code> 污染，以及子项目对主项目的 <code>css</code> 污染。</p><p>这两个方案已经能够把绝大多数问题解决。但是我们的项目中，是有一个看板的业务的。看板的业务就会把多个子应用同时加载。如果使用上面的两种方案，那么谁的包大，谁加载得慢，那么 body 的 id/class 就归谁的。物尽天择？</p><h3 id="添加自定义命名空间" tabindex="-1">添加自定义命名空间 <a class="header-anchor" href="#添加自定义命名空间" aria-label="Permalink to “添加自定义命名空间”">​</a></h3><p>如果使用了 element plus 版本的简单很多了。2.20 版本以上的，详情可以点击<a href="https://element-plus.gitee.io/zh-CN/guide/namespace.html#%E8%AE%BE%E7%BD%AE-elconfigprovider" target="_blank" rel="noreferrer">https://element-plus.gitee.io/zh-CN/guide/namespace.html#设置-elconfigprovider</a></p><p>核心代码如下：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>// styles/element/index.scss</span></span>
<span class="line"><span>// we can add this to custom namespace, default is &#39;el&#39;</span></span>
<span class="line"><span>@forward &#39;element-plus/theme-chalk/src/mixins/config.scss&#39; with (</span></span>
<span class="line"><span>  $namespace: &#39;ep&#39;</span></span>
<span class="line"><span>);</span></span>
<span class="line"><span>// ...</span></span></code></pre></div><h3 id="使用-postcss-plugin-namespace-插件添加自定义命名空间" tabindex="-1">使用 postcss-plugin-namespace 插件添加自定义命名空间 <a class="header-anchor" href="#使用-postcss-plugin-namespace-插件添加自定义命名空间" aria-label="Permalink to “使用 postcss-plugin-namespace 插件添加自定义命名空间”">​</a></h3><p>其他版本就需要借助插件来实现自定义命名空间了。有很多可以实现相同功能的插件，下面我以插件为例子。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>npm i postcss-plugin-namespace -D</span></span></code></pre></div><p>在根目录创建<code>postcss.config.js</code> 文件。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>module.exports = (ctx) =&gt; {</span></span>
<span class="line"><span>  return {</span></span>
<span class="line"><span>    plugins: [</span></span>
<span class="line"><span>      require(&#39;postcss-plugin-namespace&#39;)(&#39;#lee_project&#39;, {</span></span>
<span class="line"><span>        ignore: [</span></span>
<span class="line"><span>          &#39;html&#39;, /body/, &#39;span&#39;, &#39;el-form-item&#39;, /[data/,</span></span>
<span class="line"><span>        ]</span></span>
<span class="line"><span>      }),</span></span>
<span class="line"><span>    ]</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>ignore 顾名思义就是忽略的 class,也可以使用正则，如 <code>/body/</code> 。里面有一个 data，这是使用了 style scroped 之后，会给节点上面添加 data-xxxx 。所以它也需要忽略掉。</p><h3 id="直接覆盖样式" tabindex="-1">直接覆盖样式 <a class="header-anchor" href="#直接覆盖样式" aria-label="Permalink to “直接覆盖样式”">​</a></h3><p>我劝你不要冲动，这是我们统计一部分样式污染的 class 名称：</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91142fee4c644af0ae06e3e46e5ce9ea~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="30%"><p>主应用使用了和子应用不同的 UI 框架。我们为了让样式在加载我的应用的时候，需要全局复写上面的这些 class 名，并放在全局。</p><p>上面这些污染的 class 只是冰山一角哦，可自行评估一下需要多少工时。</p><h2 id="三、容易疏忽的问题" tabindex="-1">三、容易疏忽的问题 <a class="header-anchor" href="#三、容易疏忽的问题" aria-label="Permalink to “三、容易疏忽的问题”">​</a></h2><p>字体属于静态资源。项目肯定是开启了协商缓存的。所以说，加载过之后的静态资源也是会污染全局的。而这个时候我们就需要处理两个问题。</p><h3 id="自己从-iconfont-中下载下来的字体图标" tabindex="-1">自己从 iconfont 中下载下来的字体图标 <a class="header-anchor" href="#自己从-iconfont-中下载下来的字体图标" aria-label="Permalink to “自己从 iconfont 中下载下来的字体图标”">​</a></h3><p>直接修改 iconfont 的前缀即可。如下图配置：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ede642e497242fbb39e814a551b9dff~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" width="50%"><h3 id="element-ui-内置的图标" tabindex="-1">element ui 内置的图标 <a class="header-anchor" href="#element-ui-内置的图标" aria-label="Permalink to “element ui 内置的图标”">​</a></h3><p>并没有搞明白为什么什么的插件没有自动添加修改前缀。所以我们使用了最暴力的解决办法。不用 element ui 内置的图标，全部替换成 iconfont 的。问题解决就行。</p><p>这是因为我们项目的图标很少，所以能够这样干。如果你项目中有大量的图标的话，还是想想怎么使用插件来解决吧。解决了求求教教我。求求了！</p><p>改为使用 <strong>按需引入</strong> 问题即可解决。</p><h2 id="四、总结" tabindex="-1">四、总结 <a class="header-anchor" href="#四、总结" aria-label="Permalink to “四、总结”">​</a></h2><ul><li>编程没有银弹，引入的 qiankun 解决了多团队协作的问题，也带来了新的问题。但是也要有我们在做技术选项的时候要有这样的心理预期。</li><li>自定义命名空间本质依旧是约定样式规范。</li></ul>`,41)]))}const g=e(p,[["render",l]]);export{m as __pageData,g as default};
