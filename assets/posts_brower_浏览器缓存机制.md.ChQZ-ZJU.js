import{_ as i,c as a,o as n,ah as e}from"./chunks/framework.5RKWivQp.js";const c=JSON.parse('{"title":"浏览器缓存机制","description":"","frontmatter":{},"headers":[],"relativePath":"posts/brower/浏览器缓存机制.md","filePath":"posts/brower/浏览器缓存机制.md"}'),l={name:"posts/brower/浏览器缓存机制.md"};function t(h,s,p,k,r,d){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="浏览器缓存机制" tabindex="-1">浏览器缓存机制 <a class="header-anchor" href="#浏览器缓存机制" aria-label="Permalink to “浏览器缓存机制”">​</a></h1><ul><li>\b 所谓机制,就是说有这么一套规则来束约缓存的逻辑. 束约的工具是浏览器内部实现的. 束约的参数就是我们 [[HTTP和HTTPS协议]]的报文内容. 结果就是用户看到的资源.</li><li>所以说我们在讨论的浏览器缓存机制的时候,就是在讨论[[HTTP报文]]中的某些对应字段的发挥的作用, 辅以一套处理这些字段的逻辑.</li><li>这套处理的逻辑可以分为两种[[强制缓存]]和[[协商缓存]]</li></ul><h2 id="强制缓存" tabindex="-1">强制缓存 <a class="header-anchor" href="#强制缓存" aria-label="Permalink to “强制缓存”">​</a></h2><ul><li><p>在 http1.0 时代,通过配置<code>expires</code>相应头的属性,设置过期的时间,只要超过这个时间,资源就从服务器上获取.反之就从本地获取.</p></li><li><p>很简单,但是问题也很多</p><ul><li><p>对本地时间戳过分的依赖,如果客户端本地的时间和服务器的时间不一致的话,那么缓存过期的判断就无法和预期相符</p></li><li><blockquote><p>浏览器中的这个时间叫做格林威治时间</p></blockquote></li></ul></li><li><p>所以为了解决这个问题. 在 http1.1 时代,出现了<code>cache-control</code>字段. 其中的<code>max-age</code>属性就是对于<code>expires</code>的补充.</p><ul><li>不是进行替代,而是补充.<code>expires</code>因为简单依旧存在它的使用场景</li></ul></li></ul><p><strong>如下配置, 单位是秒:</strong></p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeHead</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(200m {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;Cache-control&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;max-age:5&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><pre><code>- 这个\`max-age\`的含义超过相对时间. 每一次刷新都更新初始化时间，类似防抖函数的作用，当你渲染界面之后的 5 秒钟内，都是可以从缓存中拿到数据的。一旦渲染界面之后，再超出 5 秒钟才再点击拿资源的话，就会重新从服务器上面拿该资源。
- 很多时候还是需要加上\`public\`属性的. \`&quot;public, max-age:5&quot;\`的. 含义是: **响应可以被任何对象缓存(包括发送请求的客户端、代理服务器等)**
- 如果只是使用\`max-age\`依旧是存在问题的.如果你后台的接口,资源就是在配置的的几秒钟更新了你怎么办?GG了. 所以出现了下面的协商缓存
</code></pre><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to “协商缓存”">​</a></h2><ul><li>协商缓存就要求每次都向服务器要结果. 缓存的有效性决定权交给后台.这样自然缓存存在的意义就很大的问题了.对于这个问题暂时不表,先来看看它是如果进行协商缓存的逻辑处理的.</li></ul><h3 id="last-modified-实现的协商缓存" tabindex="-1">last-modified 实现的协商缓存 <a class="header-anchor" href="#last-modified-实现的协商缓存" aria-label="Permalink to “last-modified 实现的协商缓存”">​</a></h3><pre><code>- 这是最简单的协商缓存的方案, 根据文件的修改时间来进行判断. 如下配置

-
</code></pre><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>res.setHeader(&#39;last-modified&#39;, mtime.toUTCString())</span></span>
<span class="line"><span>res.setHeader(&#39;Cache-Control&#39;, &#39;no-cache&#39;)</span></span></code></pre></div><pre><code>- 配置成功了之后, 响应头会生成一个属性 \`if-modified-since\`. 然后后台再进行如下的判断:

-
</code></pre><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ifModifiedSince</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> req.headers[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;if-modified-since&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ifModifiedSince </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mtime) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 缓存生效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.statusCode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 304</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><pre><code>- 如此一来,是能够满足绝大多是的场景的. 但是还是有如下的不足:
    - 1. 它只是根据时间戳来进行判断,如果只是改变了文件名,而实际内容没有任何改变的情况下,还是会进行服务器的请求拿取.这实在是太蠢了.
        1. 它的单位是秒.如果修改文件的速度非常快,在一些自动化文件处理中.在几百毫秒就完成了.那么它的单位就没有办法通过验证了.
- 所以为了解决这两点问题, HTTP1.1在随后更新版本中提供\`etag\`响应头字段来处理
</code></pre><h3 id="etag-实现协商缓存" tabindex="-1">ETag 实现协商缓存 <a class="header-anchor" href="#etag-实现协商缓存" aria-label="Permalink to “ETag 实现协商缓存”">​</a></h3><pre><code>- 处理逻辑和\`last-modified\`基本一致
</code></pre><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> etag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;etag&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./img4.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> etagContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> etag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ifNoneMatch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> req.headers[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;if-none-match&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ifNoneMatch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> etagContent) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 缓存生效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.statusCode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 304</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;etag&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, etagContent);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHeader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Cache-Control&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;no-cache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span></code></pre></div><pre><code>- etag 表示的是对文件内容的解析进而生成的一个 id，只要文件内容有了改变才会进行变更。自然就能够改变last-modified的两点的不足。它是对其的一个补充方案，而不是替代方案。
- etag 依旧带来了新的问题:
    - 1. 服务器生成文件资源 Etag 需要付出额外的计算开销，如果资源尺寸比较大，数量较多且修改比较频繁的话，那么生成 Etag 的过程显然会印象服务器的性能。
        1. Etag 字段值的生成两种类型，一种是强验证，即更具资源内容的每一个字节来进行验证，最可靠，性能消耗也最大。相对应的就是弱验证，它使用资源内容的部分的属性值来进行生成，生成速度快，但是没有办法很高的成功率。尤其是在服务器集群场景下。
- 所以说不管哪种缓存方式都有不足,结合具体的场景使用才是正确对待它们的方式. 一般来说,\`etag\`和\`last-modified\`都是使用的. 所以说对于它们的使用还有一个优先级的问题.
</code></pre><h3 id="etag-和-last-modified-的优先级" tabindex="-1">ETag 和 Last-Modified 的优先级 <a class="header-anchor" href="#etag-和-last-modified-的优先级" aria-label="Permalink to “ETag 和 Last-Modified 的优先级”">​</a></h3><pre><code>- 一般来说,默认配置的话. 是先进行\`etag\`的判断的,如果返回的是true的话,再判断\`last-modified\`.
- 当然这个可以后台自己实现自己喜欢的策略.
</code></pre><h3 id="协商缓存过程的简单总结" tabindex="-1">协商缓存过程的简单总结 <a class="header-anchor" href="#协商缓存过程的简单总结" aria-label="Permalink to “协商缓存过程的简单总结”">​</a></h3><pre><code>- 可以总结如下图

![](https://secure2.wostatic.cn/static/uAtCi1KDZYYPijhV37Uqb2/image.png?auth_key=1755803199-icU1rsNaTFbg4viRzkW6oo-0-304ce8cebaee3474c3a8b5dd9b925d99)
</code></pre><h2 id="其他相关配置的豹纹字段" tabindex="-1">其他相关配置的豹纹字段 <a class="header-anchor" href="#其他相关配置的豹纹字段" aria-label="Permalink to “其他相关配置的豹纹字段”">​</a></h2><ul><li>Paragma: no-cache(响应头) HTTP/1.0 版本的字段</li><li>Cache-Control: 也是操作缓存的.是 HTTP/1.1 版本字段,向下兼容的,所以说 Paragma 还是存在的. Cache-Control 的优先级是比前者高的.</li><li>Expires: Mon, 15 Aug2016 03:56:47 GMT(格林威治时间)</li><li>在 HTTP/1.1 使用 Cache-control 中的 max-age 来代替</li><li>Cache-Control 的相关属性 <ul><li>no-cache: <strong>忽略缓存在本地的副本,强制从服务器上拿资源</strong></li><li>no-store: <strong>强制缓存在任何情况下都不要保留任何副本</strong></li><li>max-age=314600: 知识缓存副本的有效时长,从请求时间开始到过期时间之间的描述</li><li>public: 表明响应可以被任何对象缓存(包括:发送请求的客户端、代理服务器等)</li><li>private: 表明响应只能被耽搁用户缓存,不能作为共享缓存(即代理服务器不能缓存它)</li></ul></li></ul><h2 id="我们前端需要做些什么" tabindex="-1">我们前端需要做些什么 <a class="header-anchor" href="#我们前端需要做些什么" aria-label="Permalink to “我们前端需要做些什么”">​</a></h2><p>这里是熟悉前端工程话的知识点了.很多 [[Webpack基础]]已经帮我们做了. 我们只需要进行进行对应的配置就可以了. 比如说,修改每次打包都修改生成的入口文件的文字</p><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>entry:{</span></span>
<span class="line"><span>    main: path.join(__dirname,&#39;./main.js&#39;),</span></span>
<span class="line"><span>    vendor: [&#39;react&#39;]</span></span>
<span class="line"><span>},</span></span>
<span class="line"><span>output:{</span></span>
<span class="line"><span>    path:path.join(__dirname,&#39;./dist&#39;),</span></span>
<span class="line"><span>    publicPath: &#39;/dist/&#39;,</span></span>
<span class="line"><span>    filname: &#39;bundle.[chunkhash].js&#39;</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li><code>chunkhash</code>就代表出口文件没有打包都会生层对应的 hash 值. 还有另外两个值可以替换它.<code>hash</code>、<code>contenthash</code></li><li>三者的差别可以用一句话来概括: <ul><li><code>hash</code> 计算和整个项目的构建相关</li><li><code>chunkhash</code>计算同一 chunk 内容相关</li><li><code>contenthash</code>计算和文件内容本身相关</li></ul></li><li>详情可以自己尝试一下.看官网.</li><li>还有一些前端世界常听到的: <ul><li>html 使用协商缓存</li><li>css、js、静态资源 使用强缓存,文件名带上 hash 值</li></ul></li></ul><h2 id="用户行为对浏览器缓存的影响" tabindex="-1">用户行为对浏览器缓存的影响 <a class="header-anchor" href="#用户行为对浏览器缓存的影响" aria-label="Permalink to “用户行为对浏览器缓存的影响”">​</a></h2><ul><li><ol><li>打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li></ol></li><li><ol start="2"><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</li></ol></li><li><ol start="3"><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache),服务器直接返回 200 和最新内容。</li></ol></li></ul>`,31)]))}const g=i(l,[["render",t]]);export{c as __pageData,g as default};
