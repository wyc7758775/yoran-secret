import{_ as s,c as a,o as n,ah as o}from"./chunks/framework.z4R-vjjm.js";const b=JSON.parse('{"title":"用函数调用的方式来分析 this","description":"","frontmatter":{},"headers":[],"relativePath":"posts/JavaScriptCore/用函数调用的方式来分析this.md","filePath":"posts/JavaScriptCore/用函数调用的方式来分析this.md"}'),c={name:"posts/JavaScriptCore/用函数调用的方式来分析this.md"};function i(p,e,t,l,d,r){return n(),a("div",null,e[0]||(e[0]=[o(`<h1 id="用函数调用的方式来分析-this" tabindex="-1">用函数调用的方式来分析 this <a class="header-anchor" href="#用函数调用的方式来分析-this" aria-label="Permalink to “用函数调用的方式来分析 this”">​</a></h1><blockquote><p>每个函数都有一个隐式的 <code>this</code> 形参。将函数作为方法调用时，这个参数会被设置为用于访问该方法的对象。这和大多数<a href="https://www.zhihu.com/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%221539325572%22%7D" target="_blank" rel="noreferrer">面向对象语言</a>中的 <code>this</code>（或 <code>self</code>）含义相同。但是 JavaScript 在「关联到对象的方法」与「独立函数」这两者之间，使用了单一的定义形式。<strong>这使 **</strong><code>this</code>*<strong>* 导致了许多程序员的困惑和 bug。 ——————Brendan Eich(JS 之父)</strong></p></blockquote><p>this 指向到问题是公认的！创造 JS 的人都这么说它。所谓的灵活指向不过是缝合怪。</p><p>所以说，对于 <code>this</code> 的强限制是非常有必要的，比如 ES6 的发布。</p><p>现在面试还在考查 <code>this</code> 的使用作为主要晒人的手段是不理智不合理的，<strong>希望各位面试官能提升自己的修养！</strong></p><p>当然，现在依旧有大量的老项目充斥着各种 <code>this</code> 。面对这样的项目，我建议面试者另选公司，建议面试官早日理智。</p><blockquote><p>如果在现在的市场有其他更好的选择的话</p></blockquote><h2 id="它所谓的灵活是什么" tabindex="-1">它所谓的灵活是什么？ <a class="header-anchor" href="#它所谓的灵活是什么" aria-label="Permalink to “它所谓的灵活是什么？”">​</a></h2><p>new 关键字让我在批量创造对象的时候省却了 4 个步骤；函数不用显性的写上 return,它自己会添加，并且 return undeinfed。在调用函数的时候，自然也会有有类似的操作。</p><p>我们想来看调用函数的四种方式：</p><ul><li><code>fn(a, b)</code></li><li><code>obj.fn(a,b)</code></li><li><code>fn.call(Object, a, b)</code></li><li><code>fn.apply(Object, [a, b])</code></li></ul><p>其中<code>apply</code>和<code>call</code> 的差别只是参数的类型不一样。它们的第一个参数<code>Object</code> 大多数的是直接传 this 进去。和<code>fn(a, b)</code> 和<code>obj.fn(a,b )</code> 有<code>this</code> 和<code>arguments</code> 两个隐式的参数不同，它们是显式的！</p><p>那是不是可以说 <code>fn(a, b)</code> 和<code>obj.fn(a, b)</code> 以及<code>fn.apply(Object, [a. b])</code> 都是 <code>fn.call(Object, a, b)</code> 的语法糖！！！</p><ul><li><strong>fn(a, b) ⇒ fn.call(undefine, a, b)</strong></li><li><strong>obj.fn(a, b) ⇒ fn.call(obj, a, b)</strong></li><li><strong>fn.apply(Object, [a, b]) ⇒ fn.call(Object, a, b)</strong></li></ul><p>也就是说，其实我们调用函数的时候，只有一种方式，就是<code>fn.call(Object, a, b)</code> ！</p><p>在这个前提之下， 我们来看看下面的这个经典面试题：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>const obj = {</span></span>
<span class="line"><span>  foo: function() {</span></span>
<span class="line"><span>    console.log(this)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const myObj = obj.foo</span></span>
<span class="line"><span>myObj() // window</span></span>
<span class="line"><span>obj.foo() // function foo() {}</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>myObj(undefined)</span></span>
<span class="line"><span>obj.foo(obj)</span></span></code></pre></div><p>我们用上面的来定义一下：</p><p><code>myObj()</code> ⇒ <code>myObj.call(undefined)</code></p><p><code>obj.foo()</code> ⇒ <code>obj.foo.call(obj)</code></p><p>所以说，obj.foo()答应出来的就是 <em>function foo() {</em> }。由于在浏览器当中，当传入的 Object 是<code>undefined</code> 或者 <code>null</code> 的时候，它默认指向<code>windows</code> 。</p><p>基于这样的现象，我们可以引用《你不知道的 JavaScript》中对于 <code>this</code> 的概括：</p><ol><li>上下文是在函数被调用的时候创建的</li><li>上下文中包括了 <code>this</code></li></ol><p>换一句话说就是： <strong><code>this</code>**</strong> 的行为是在运行时决定的！**</p><p>造成它们的打印的结果的不同，就是函数的运行的时候创建的上下文不同，在这里，我们完全可以把上下文这个概念等同于 <code>this</code>。</p><p>myObj 运行的时候，foo 函数已经挂载到了上下文全局中，所以它的 <code>this</code> 打印的结果是 window。而 obj.foo 运行时，foo 函数挂载在对象内部，所以 this 打印是函数自己。</p><blockquote><p>上面例子说明的 Object 就是上下文，一般写作 context。</p></blockquote><h2 id="它带来了什么灾难" tabindex="-1">它带来了什么灾难 <a class="header-anchor" href="#它带来了什么灾难" aria-label="Permalink to “它带来了什么灾难”">​</a></h2><p>当它和事件循环机制在一起的时候，如下题：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>const object = {</span></span>
<span class="line"><span>  message: &#39;Hello, World!&#39;,</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  logMessage() {</span></span>
<span class="line"><span>    console.log(this.message); // =&gt; ?</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setTimeout(object.logMessage, 1000);</span></span></code></pre></div><p>按照说明的分析，既然是方法的调用，那么这里打印的是不是 object 的属性呢 ？</p><p>结果很遗憾， 是 window。setTimeout 属于宏任务，它会等待微任务在执行栈中执行完毕再将<code>object.logMessage</code> 放入执行栈当中。可是此时它已经变成了函数的调用,因为 object 对象已经被销毁，所以是<code>object.logMessage.call(undefined)</code> 。</p><p>所以我们在 ES6 中迎来了箭头函数！</p><p>它没有<code>this</code> 这个隐式的参数。也就意味着，如果它会延着作用域链一直忘找 <code>this</code> 这个参数的存在。纯粹得太多了。善莫大焉！</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><ul><li>只有一种调用函数的方式，<code>fn.call(Object, a, b)</code></li></ul>`,37)]))}const f=s(c,[["render",i]]);export{b as __pageData,f as default};
