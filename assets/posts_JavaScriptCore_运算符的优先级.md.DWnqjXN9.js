import{_ as a,c as r,o as t,be as o}from"./chunks/framework.CneAHPKZ.js";const h=JSON.parse('{"title":"运算符的优先级","description":"","frontmatter":{},"headers":[],"relativePath":"posts/JavaScriptCore/运算符的优先级.md","filePath":"posts/JavaScriptCore/运算符的优先级.md"}'),l={name:"posts/JavaScriptCore/运算符的优先级.md"};function i(p,e,c,s,n,d){return t(),r("div",null,e[0]||(e[0]=[o('<h1 id="运算符的优先级" tabindex="-1">运算符的优先级 <a class="header-anchor" href="#运算符的优先级" aria-label="Permalink to “运算符的优先级”">​</a></h1><h3 id="我们在讨论的是一个什么问题" tabindex="-1">我们在讨论的是一个什么问题 <a class="header-anchor" href="#我们在讨论的是一个什么问题" aria-label="Permalink to “我们在讨论的是一个什么问题”">​</a></h3><ul><li><p>我们在讨论的是处理计算的优先级.</p><p>比如说<code>1 + 2 * 3</code> 等价于 <code>1 + (2 * 3)</code>. 计算的过程还是从左到右</p></li><li><p>所以说,在实际开发中,你想要谁优先处理,就用括号包裹住,准没错.而且也推荐在实际发开着么干.</p></li><li><p>如果从编译器的角度上看的话,我们讨论的是[[AST节点]]和根的距离的问题.</p><ul><li>简单的说就是在求值的过程中,对于整个 AST 树的遍历是[[后序遍历]], 就是说,理根节点越远就越早被求值.</li><li>具体可以查看[[JavaScript中运算符优先级]]这篇文章</li></ul></li></ul><h3 id="如何记忆" tabindex="-1">如何记忆 <a class="header-anchor" href="#如何记忆" aria-label="Permalink to “如何记忆”">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></p><ul><li>这个是总表. 其实没有必要记忆,因为实际中真的这样写, 得下地狱的.</li><li>真要用的话,直接去 MDN 查表就行</li></ul><blockquote><p>话说,我工作了四年,也就 2021 年才有意识查 MDN 来学习,之前都是直接谷歌百度,有代码报错最多就是 stackoverflow 定向查查看.果然是混了四年.😭</p></blockquote><ul><li><p>关于记忆的口诀,无意间看到掘金上面的这篇文章上面的 <a href="https://juejin.cn/post/6844904048773201927#heading-0" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904048773201927#heading-0</a></p><blockquote><p><strong>括点油调一成做衣 叫等位裸跳服展昭</strong></p></blockquote><p>感觉比我之前想的好太多了,居然的记忆方法可以点开链接去看看.掘金大佬就是有才.</p></li></ul>',8)]))}const u=a(l,[["render",i]]);export{h as __pageData,u as default};
