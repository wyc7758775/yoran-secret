import{_ as s,c as a,o as e,b2 as t}from"./chunks/framework.BpzV57uv.js";const d=JSON.parse('{"title":"响应式 API：工具","description":"","frontmatter":{},"headers":[],"relativePath":"posts/Vue/响应式API：工具.md","filePath":"posts/Vue/响应式API：工具.md"}'),l={name:"posts/Vue/响应式API：工具.md"};function n(r,i,h,p,o,c){return e(),a("div",null,i[0]||(i[0]=[t(`<h1 id="响应式-api-工具" tabindex="-1">响应式 API：工具 <a class="header-anchor" href="#响应式-api-工具" aria-label="Permalink to “响应式 API：工具”">​</a></h1><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to “参考资料”">​</a></h2><ul><li><a href="https://cn.vuejs.org/api/reactivity-utilities.html#isref" target="_blank" rel="noreferrer">isRef()</a></li><li><a href="https://cn.vuejs.org/api/reactivity-utilities.html#unref" target="_blank" rel="noreferrer">unref()</a></li><li><a href="https://cn.vuejs.org/api/reactivity-utilities.html#toref" target="_blank" rel="noreferrer">toRef()</a></li><li><a href="https://cn.vuejs.org/api/reactivity-utilities.html#tovalue" target="_blank" rel="noreferrer">toValue()</a></li><li><a href="https://cn.vuejs.org/api/reactivity-utilities.html#torefs" target="_blank" rel="noreferrer">toRefs()</a></li><li><a href="https://cn.vuejs.org/api/reactivity-utilities.html#isproxy" target="_blank" rel="noreferrer">isProxy()</a></li><li><a href="https://cn.vuejs.org/api/reactivity-utilities.html#isreactive" target="_blank" rel="noreferrer">isReactive()</a></li><li><a href="https://cn.vuejs.org/api/reactivity-utilities.html#isreadonly" target="_blank" rel="noreferrer">isReadonly()</a></li></ul><p>这些 API 的用法非常的简单，而且通过这些命名就可以知道它们属于可有可无的一些方法。</p><h3 id="防御性编程-api" tabindex="-1">防御性编程 API <a class="header-anchor" href="#防御性编程-api" aria-label="Permalink to “防御性编程 API”">​</a></h3><ul><li><code>isRef()</code> : 检车某个值是否为 <code>ref</code>。</li><li><code>isProxy()</code> : 检测某个值是否为<code>reactive</code>、<code>shallowReactive</code>、<code>readonly</code>，以及<code>shallowReaonly</code>。</li><li><code>isReactive()</code> : 检测某个值是否为<code>reactive</code>、<code>shallowReactive</code>。</li><li><code>isReadonly()</code> : 检测某个值是否为<code>readonly</code>，<code>shallowReaonly</code>。</li></ul><p>这种 API 就是典型的类型判断的 API，多用于 Hook 函数中对于传入参数的值得类型的判断，不同的类型使用不同的取值逻辑。</p><h3 id="灵活性访问-api" tabindex="-1">灵活性访问 API <a class="header-anchor" href="#灵活性访问-api" aria-label="Permalink to “灵活性访问 API”">​</a></h3><ul><li><code>unref()</code>：等同于<code>const a = isRef(b) ? b.value : b</code> ，是为了拿到 ref 的值的语法糖。</li><li><code>toRef()</code>：将非响应式的变量，基础类系和引用类型都可以，转化为 ref。</li><li><code>toRefs()</code>：针对<code>reactive</code> 对响应式对象，让它的对象每一个解耦出来的属性都是 ref。</li><li><code>toValue()</code>: 比 <code>unref</code>多出一个转化的情况，可以转化<code>() =&gt; 9</code> 这样的而 <code>getter</code>函数的值。</li></ul><p>这一组 API，解决了响应式编程中的核心问题： 保持数据响应性的同时提供更灵活的访问方式。</p><p>其他<code>toRefs()</code> 典型的用法就是说明这个问题，可以让开发者直接解耦代码而不失去响应式，官网的例子如下：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useFeatureX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    foo: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    bar: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...基于状态的操作逻辑</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在返回时都转为 ref</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toRefs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以解构而不会失去响应性</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useFeatureX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div>`,12)]))}const g=s(l,[["render",n]]);export{d as __pageData,g as default};
